{"version":3,"file":"static/js/148.b64d0974.chunk.js","mappings":"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","sources":["../node_modules/@usedapp/core/src/hooks/useRawCalls.ts","../node_modules/@usedapp/core/src/hooks/useChainCalls.ts","../node_modules/@usedapp/core/src/hooks/useContractCall.ts","../node_modules/ethers/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/@usedapp/core/src/hooks/useContractFunction.ts","../node_modules/@usedapp/core/src/hooks/usePromiseTransaction.ts","../node_modules/@usedapp/core/src/constants/abi/index.ts","../node_modules/@usedapp/core/src/hooks/useEtherBalance.ts","../node_modules/@usedapp/core/src/hooks/useMulticallAddress.ts","../node_modules/@usedapp/core/src/hooks/useTransactions.ts","../node_modules/awesome-imperative-promise/src/index.ts","../node_modules/awesome-debounce-promise/node_modules/tslib/tslib.es6.js","../node_modules/awesome-debounce-promise/src/index.ts","../node_modules/awesome-only-resolves-last-promise/src/index.ts","../node_modules/debounce-promise/index.js","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/address/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/address/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/strings/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/strings/src.ts/utf8.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/hash/src.ts/id.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/properties/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/properties/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/abi/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/abi/src.ts/coders/abstract-coder.ts","../node_modules/ethers/node_modules/@ethersproject/abi/src.ts/coders/address.ts","../node_modules/ethers/node_modules/@ethersproject/abi/src.ts/coders/anonymous.ts","../node_modules/ethers/node_modules/@ethersproject/abi/src.ts/coders/array.ts","../node_modules/ethers/node_modules/@ethersproject/abi/src.ts/coders/boolean.ts","../node_modules/ethers/node_modules/@ethersproject/abi/src.ts/coders/bytes.ts","../node_modules/ethers/node_modules/@ethersproject/abi/src.ts/coders/fixed-bytes.ts","../node_modules/ethers/node_modules/@ethersproject/abi/src.ts/coders/null.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/constants/src.ts/bignumbers.ts","../node_modules/ethers/node_modules/@ethersproject/abi/src.ts/coders/number.ts","../node_modules/ethers/node_modules/@ethersproject/abi/src.ts/coders/string.ts","../node_modules/ethers/node_modules/@ethersproject/abi/src.ts/coders/tuple.ts","../node_modules/ethers/node_modules/@ethersproject/abi/src.ts/fragments.ts","../node_modules/ethers/node_modules/@ethersproject/abi/src.ts/abi-coder.ts","../node_modules/ethers/node_modules/@ethersproject/abi/src.ts/interface.ts","../node_modules/ethers/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/networks/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/networks/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/properties/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/properties/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/rlp/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/rlp/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/address/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/address/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/constants/src.ts/addresses.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/constants/src.ts/bignumbers.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/node_modules/minimalistic-assert/index.js","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/node_modules/minimalistic-crypto-utils/lib/utils.js","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/node_modules/elliptic/lib/elliptic/utils.js","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/node_modules/elliptic/lib/elliptic/curve/base.js","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/node_modules/inherits/inherits_browser.js","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/node_modules/elliptic/lib/elliptic/curve/short.js","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/node_modules/elliptic/lib/elliptic/curve/index.js","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/node_modules/elliptic/lib/elliptic/curves.js","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/node_modules/hmac-drbg/lib/hmac-drbg.js","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/node_modules/elliptic/lib/elliptic/ec/key.js","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/node_modules/elliptic/lib/elliptic/ec/signature.js","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/node_modules/elliptic/lib/elliptic/ec/index.js","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/node_modules/elliptic/lib/elliptic.js","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/signing-key/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/signing-key/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/transactions/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/transactions/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/formatter.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/strings/src.ts/utf8.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/abstract-signer/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/abstract-signer/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/hash/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/strings/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/hash/src.ts/id.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/hash/src.ts/typed-data.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/base64/src.ts/browser-base64.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/web/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/web/src.ts/browser-geturl.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/web/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/abstract-provider/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/abstract-provider/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/basex/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/strings/src.ts/idna.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/hash/src.ts/namehash.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/sha2/src.ts/browser-sha2.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/sha2/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/base-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/constants/src.ts/hashes.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/browser-ws.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/websocket-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/url-json-rpc-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/alchemy-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/cloudflare-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/etherscan-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/random/src.ts/shuffle.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/fallback-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/infura-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/nodesmith-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/pocket-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/web3-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/browser-ipc-provider.ts"],"sourcesContent":["import { useEffect, useMemo } from 'react'\nimport { RawCallResult, useChainState } from '../providers'\nimport { RawCall } from '../providers'\nimport { Falsy } from '../model/types'\n\nexport function useRawCalls(calls: (RawCall | Falsy)[]): RawCallResult[] {\n  const { dispatchCalls, value } = useChainState()\n\n  useEffect(() => {\n    const filteredCalls = calls.filter(Boolean) as RawCall[]\n    dispatchCalls({ type: 'ADD_CALLS', calls: filteredCalls })\n    return () => dispatchCalls({ type: 'REMOVE_CALLS', calls: filteredCalls })\n  }, [JSON.stringify(calls), dispatchCalls])\n\n  return useMemo(\n    () =>\n      calls.map((call) => {\n        if (call && value) {\n          return value.state?.[call.address]?.[call.data]\n        }\n      }),\n    [JSON.stringify(calls), value]\n  )\n}\n\nexport function useRawCall(call: RawCall | Falsy) {\n  return useRawCalls([call])[0]\n}\n","import { RawCall } from '../providers'\nimport { Falsy } from '../model/types'\nimport { useRawCalls } from './useRawCalls'\n\n/**\n * @deprecated It's recommended to use useRawCalls instead\n */\nexport function useChainCalls(calls: (RawCall | Falsy)[]) {\n  const results = useRawCalls(calls)\n  return results.map((result) => result?.value)\n}\n\n/**\n * @deprecated It's recommended to use useRawCall instead\n */\nexport function useChainCall(call: RawCall | Falsy) {\n  return useChainCalls([call])[0]\n}\n","import { Interface } from '@ethersproject/abi'\nimport { useMemo } from 'react'\nimport { Falsy } from '../model/types'\nimport { useChainCalls } from './useChainCalls'\nimport { RawCall } from '../providers/chainState/callsReducer'\n\nfunction warnOnInvalidContractCall(call: ContractCall | Falsy) {\n  console.warn(\n    `Invalid contract call: address=${call && call.address} method=${call && call.method} args=${call && call.args}`\n  )\n}\n\nfunction encodeCallData(call: ContractCall | Falsy): RawCall | Falsy {\n  if (!call) {\n    return undefined\n  }\n  if (!call.address || !call.method) {\n    warnOnInvalidContractCall(call)\n    return undefined\n  }\n  try {\n    return { address: call.address, data: call.abi.encodeFunctionData(call.method, call.args) }\n  } catch {\n    warnOnInvalidContractCall(call)\n    return undefined\n  }\n}\n\nexport interface ContractCall {\n  abi: Interface\n  address: string\n  method: string\n  args: any[]\n}\n\nexport function useContractCall(call: ContractCall | Falsy): any[] | undefined {\n  return useContractCalls([call])[0]\n}\n\nexport function useContractCalls(calls: (ContractCall | Falsy)[]): (any[] | undefined)[] {\n  const results = useChainCalls(calls.map(encodeCallData))\n\n  return useMemo(\n    () =>\n      results.map((result, idx) => {\n        const call = calls[idx]\n        if (result === '0x') {\n          warnOnInvalidContractCall(call)\n          return undefined\n        }\n        return call && result ? (call.abi.decodeFunctionResult(call.method, result) as any[]) : undefined\n      }),\n    [results]\n  )\n}\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.5.0\";\n","import { addressEqual, TransactionOptions } from '../../src'\nimport { Contract } from '@ethersproject/contracts'\nimport { JsonRpcProvider } from '@ethersproject/providers'\nimport { useCallback, useState } from 'react'\nimport { useEthers } from './useEthers'\nimport { usePromiseTransaction } from './usePromiseTransaction'\nimport { LogDescription } from 'ethers/lib/utils'\n\nexport function connectContractToSigner(contract: Contract, options?: TransactionOptions, library?: JsonRpcProvider) {\n  if (contract.signer) {\n    return contract\n  }\n\n  if (options?.signer) {\n    return contract.connect(options.signer)\n  }\n\n  if (library?.getSigner()) {\n    return contract.connect(library.getSigner())\n  }\n\n  throw new TypeError('No signer available in contract, options or library')\n}\n\nexport function useContractFunction(contract: Contract, functionName: string, options?: TransactionOptions) {\n  const { library, chainId } = useEthers()\n  const { promiseTransaction, state, resetState } = usePromiseTransaction(chainId, options)\n  const [events, setEvents] = useState<LogDescription[] | undefined>(undefined)\n\n  const send = useCallback(\n    async (...args: any[]) => {\n      const contractWithSigner = connectContractToSigner(contract, options, library)\n      const receipt = await promiseTransaction(contractWithSigner[functionName](...args))\n      if (receipt?.logs) {\n        const events = receipt.logs.reduce((accumulatedLogs, log) => {\n          try {\n            return addressEqual(log.address, contract.address)\n              ? [...accumulatedLogs, contract.interface.parseLog(log)]\n              : accumulatedLogs\n          } catch (_err) {\n            return accumulatedLogs\n          }\n        }, [] as LogDescription[])\n        setEvents(events)\n      }\n    },\n    [contract, functionName, options, library]\n  )\n\n  return { send, state, events, resetState }\n}\n","import { TransactionResponse } from '@ethersproject/abstract-provider'\nimport { useCallback, useState } from 'react'\nimport { useNotificationsContext, useTransactionsContext } from '../providers'\nimport { TransactionStatus, TransactionOptions } from '../../src'\nimport { TransactionState } from '../model'\nimport { errors } from 'ethers'\n\nconst isDroppedAndReplaced = (e: any) =>\n  e?.code === errors.TRANSACTION_REPLACED && e?.replacement && (e?.reason === 'repriced' || e?.cancelled === false)\n\nexport function usePromiseTransaction(chainId: number | undefined, options?: TransactionOptions) {\n  const [state, setState] = useState<TransactionStatus>({ status: 'None' })\n  const { addTransaction } = useTransactionsContext()\n  const { addNotification } = useNotificationsContext()\n\n  const resetState = useCallback(() => {\n    setState({ status: 'None' })\n  }, [setState])\n\n  const promiseTransaction = useCallback(\n    async (transactionPromise: Promise<TransactionResponse>) => {\n      if (!chainId) return\n      let transaction: TransactionResponse | undefined = undefined\n      try {\n        setState({ status: 'PendingSignature', chainId })\n\n        transaction = await transactionPromise\n\n        setState({ transaction, status: 'Mining', chainId })\n        addTransaction({\n          transaction: {\n            ...transaction,\n            chainId: chainId,\n          },\n          submittedAt: Date.now(),\n          transactionName: options?.transactionName,\n        })\n        const receipt = await transaction.wait()\n        setState({ receipt, transaction, status: 'Success', chainId })\n        return receipt\n      } catch (e: any) {\n        const errorMessage = e.error?.message ?? e.reason ?? e.data?.message ?? e.message\n        if (transaction) {\n          const droppedAndReplaced = isDroppedAndReplaced(e)\n\n          if (droppedAndReplaced) {\n            const status: TransactionState = e.receipt.status === 0 ? 'Fail' : 'Success'\n            const type = status === 'Fail' ? 'transactionFailed' : 'transactionSucceed'\n\n            addNotification({\n              notification: {\n                type,\n                submittedAt: Date.now(),\n                transaction: e.replacement,\n                receipt: e.receipt,\n                transactionName: e.replacement?.transactionName,\n                originalTransaction: transaction,\n              },\n              chainId,\n            })\n\n            setState({\n              status,\n              transaction: e.replacement,\n              originalTransaction: transaction,\n              receipt: e.receipt,\n              errorMessage,\n              chainId,\n            })\n          } else {\n            setState({ status: 'Fail', transaction, receipt: e.receipt, errorMessage, chainId })\n          }\n        } else {\n          setState({ status: 'Exception', errorMessage, chainId })\n        }\n        return undefined\n      }\n    },\n    [chainId, setState, addTransaction, options]\n  )\n\n  return { promiseTransaction, state, resetState }\n}\n","import { Interface } from '@ethersproject/abi'\nimport MultiCall from './MultiCall.json'\nimport MultiCall2 from './MultiCall2.json'\nimport ERC20 from './ERC20.json'\nimport ERC20Mock from './ERC20Mock.json'\n\nconst MultiCallABI = new Interface(MultiCall.abi)\n\nexport { MultiCall, MultiCallABI }\n\nconst MultiCall2ABI = new Interface(MultiCall2.abi)\n\nexport { MultiCall2, MultiCall2ABI }\n\nconst ERC20Interface = new Interface(ERC20.abi)\n\nexport { ERC20, ERC20Interface }\n\nconst ERC20MockInterface = new Interface(ERC20Mock.abi)\n\nexport { ERC20Mock, ERC20MockInterface }\n","import { MultiCallABI } from '../constants'\nimport { useMulticallAddress } from './useMulticallAddress'\nimport { Falsy } from '../model/types'\nimport { useContractCall } from './useContractCall'\nimport { BigNumber } from '@ethersproject/bignumber'\n\nexport function useEtherBalance(address: string | Falsy): BigNumber | undefined {\n  const multicallAddress = useMulticallAddress()\n  const [etherBalance] =\n    useContractCall(\n      multicallAddress &&\n        address && {\n          abi: MultiCallABI,\n          address: multicallAddress,\n          method: 'getEthBalance',\n          args: [address],\n        }\n    ) ?? []\n  return etherBalance\n}\n","import { useChainState } from '../providers'\n\nexport function useMulticallAddress(): string | undefined {\n  return useChainState().multicallAddress\n}\n","import { useMemo } from 'react'\nimport { useTransactionsContext } from '../providers'\nimport { useEthers } from './useEthers'\n\nexport function useTransactions() {\n  const { chainId, account } = useEthers()\n  const { addTransaction, transactions } = useTransactionsContext()\n\n  const filtered = useMemo(() => {\n    if (chainId === undefined || !account) {\n      return []\n    }\n    return (transactions[chainId] ?? []).filter((x) => x.transaction.from === account)\n  }, [transactions, chainId, account])\n\n  return {\n    transactions: filtered,\n    addTransaction,\n  }\n}\n","export type ResolveCallback<T> = (value: T | PromiseLike<T>) => void\nexport type RejectCallback = (reason?: any) => void\nexport type CancelCallback = () => void\n\nexport type ImperativePromise<T> = {\n  promise: Promise<T>\n  resolve: ResolveCallback<T>\n  reject: RejectCallback\n  cancel: CancelCallback\n}\n\nexport function createImperativePromise<T>(promiseArg?: Promise<T> | null | undefined): ImperativePromise<T> {\n  let resolve: ResolveCallback<T> | null = null\n  let reject: RejectCallback | null = null\n\n  const wrappedPromise = new Promise<T>((_resolve, _reject) => {\n    resolve = _resolve\n    reject = _reject\n  })\n\n  promiseArg && promiseArg.then(\n    val => {\n      resolve && resolve(val)\n    },\n    error => {\n      reject && reject(error)\n    }\n  )\n\n  return {\n    promise: wrappedPromise,\n    resolve: (value: T | PromiseLike<T>) => {\n      resolve && resolve(value)\n    },\n    reject: (reason?: any) => {\n      reject && reject(reason)\n    },\n    cancel: () => {\n      resolve = null\n      reject = null\n    }\n  }\n}\n\n\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import DebouncePromise from 'debounce-promise';\nimport { onlyResolvesLast } from 'awesome-only-resolves-last-promise';\n\ntype ArgumentsType<T> = T extends (...args: infer A) => any ? A : never;\n\nexport type AwesomeDebounceOptions = {\n  key: (...args: any[]) => string | null | undefined;\n  onlyResolvesLast: boolean;\n} & DebouncePromise.DebounceOptions;\n\n\nconst DefaultOptions = {\n  // One distinct debounced function is created per key and added to an internal cache\n  // By default, the key is null, which means that all the calls\n  // will share the same debounced function\n  key: (..._args: any[]) => null,\n\n  // By default, a debounced function will only resolve\n  // the last promise it returned\n  // Former calls will stay unresolved, so that you don't have\n  // to handle concurrency issues in your code\n  // Setting this to false means all returned promises will resolve to the last result\n  onlyResolvesLast: true,\n};\n\n\ntype CacheConfig<Fun extends (...args: any[]) => any> = {\n  func: Fun,\n  wait: number,\n  options: AwesomeDebounceOptions\n}\n\n// TODO not useful right now but will be useful if we want to support cancellation\ntype CacheFunction<Fun extends (...args: any[]) => any> = {\n  func: Fun,\n  // cancel: () => void,\n}\n\n// We create a debouncing function cache, because when wrapping the original function,\n// we may actually want to route the function call to different debounced functions depending function paameters\nclass DebounceCache<Fun extends (...args: any[]) => any> {\n  config: CacheConfig<Fun>;\n\n  debounceSingleton: CacheFunction<Fun> | null; // key not used\n  debounceCache: { [key: string]: CacheFunction<Fun> }; // key used\n\n  constructor(config: CacheConfig<Fun>) {\n    this.config = config;\n    this.debounceSingleton = null;\n    this.debounceCache = {}; // when key feature is used\n  }\n\n  _createDebouncedFunction(): CacheFunction<Fun> {\n    let debouncedFunc: Fun = DebouncePromise(this.config.func, this.config.wait, this.config.options) as any; // TODO TS\n    if (this.config.options.onlyResolvesLast) {\n      debouncedFunc = onlyResolvesLast(debouncedFunc);\n    }\n    return {\n      func: debouncedFunc,\n    };\n  };\n\n  getDebouncedFunction(\n    args: ArgumentsType<Fun>,\n  ): CacheFunction<Fun> {\n    const key = this.config.options.key(...args);\n    if (key === null || typeof key === 'undefined') {\n      if (!this.debounceSingleton) {\n        this.debounceSingleton = this._createDebouncedFunction();\n      }\n      return this.debounceSingleton;\n    }\n    else {\n      if (!this.debounceCache[key]) {\n        this.debounceCache[key] = this._createDebouncedFunction();\n      }\n      return this.debounceCache[key];\n    }\n  }\n}\n\n// extra methods are \"added\" to the the returned debounced async function\ntype ReturnedFunction<Fun> = Fun & {\n  // cancel: (key?: string) => void\n}\n\nfunction AwesomeDebouncePromise<Fun extends (...args: any[]) => any>(\n  func: Fun,\n  wait: number,\n  options?: Partial<AwesomeDebounceOptions>,\n): ReturnedFunction<Fun> {\n  const finalOptions: AwesomeDebounceOptions = {\n    ...DefaultOptions,\n    ...options,\n  };\n\n  const debounceCache = new DebounceCache<Fun>({\n    func,\n    wait,\n    options: finalOptions,\n  });\n\n  const AwesomeDebouncePromiseWrapper = ((...args: ArgumentsType<Fun>) => {\n    const debouncedFn = debounceCache.getDebouncedFunction(\n      args,\n    ).func;\n    return debouncedFn(...args);\n  }) as ReturnedFunction<Fun>; // TODO fix TS\n\n  /*\n  AwesomeDebouncePromiseWrapper.cancel = (key?: string) => {\n\n  };\n  */\n  return AwesomeDebouncePromiseWrapper;\n}\n\nexport default AwesomeDebouncePromise;\n","import {\n  createImperativePromise,\n  CancelCallback,\n} from 'awesome-imperative-promise';\n\ntype ArgumentsType<T> = T extends (...args: infer A) => any ? A : never;\n\n// see https://stackoverflow.com/a/54825370/82609\nexport function onlyResolvesLast<T extends (...args: any[]) => any>(\n  asyncFunction: T,\n): T {\n  let cancelPrevious: CancelCallback | null = null;\n\n  const wrappedFunction = (...args: ArgumentsType<T>) => {\n    cancelPrevious && cancelPrevious();\n    const initialPromise = asyncFunction(...args);\n    const { promise, cancel } = createImperativePromise(initialPromise);\n    cancelPrevious = cancel;\n    return promise;\n  };\n\n  return wrappedFunction as any; // TODO fix TS\n}\n","/* global setTimeout, clearTimeout */\n\nmodule.exports = function debounce (fn, wait = 0, options = {}) {\n  let lastCallAt\n  let deferred\n  let timer\n  let pendingArgs = []\n  return function debounced (...args) {\n    const currentWait = getWait(wait)\n    const currentTime = new Date().getTime()\n\n    const isCold = !lastCallAt || (currentTime - lastCallAt) > currentWait\n\n    lastCallAt = currentTime\n\n    if (isCold && options.leading) {\n      return options.accumulate\n        ? Promise.resolve(fn.call(this, [args])).then(result => result[0])\n        : Promise.resolve(fn.call(this, ...args))\n    }\n\n    if (deferred) {\n      clearTimeout(timer)\n    } else {\n      deferred = defer()\n    }\n\n    pendingArgs.push(args)\n    timer = setTimeout(flush.bind(this), currentWait)\n\n    if (options.accumulate) {\n      const argsIndex = pendingArgs.length - 1\n      return deferred.promise.then(results => results[argsIndex])\n    }\n\n    return deferred.promise\n  }\n\n  function flush () {\n    const thisDeferred = deferred\n    clearTimeout(timer)\n\n    Promise.resolve(\n      options.accumulate\n        ? fn.call(this, pendingArgs)\n        : fn.apply(this, pendingArgs[pendingArgs.length - 1])\n    )\n      .then(thisDeferred.resolve, thisDeferred.reject)\n\n    pendingArgs = []\n    deferred = null\n  }\n}\n\nfunction getWait (wait) {\n  return (typeof wait === 'function') ? wait() : wait\n}\n\nfunction defer () {\n  const deferred = {}\n  deferred.promise = new Promise((resolve, reject) => {\n    deferred.resolve = resolve\n    deferred.reject = reject\n  })\n  return deferred\n}\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.6.0\";\n","export const version = \"bytes/5.6.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0x0\" + hex.substring(2);\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        logger.checkNew(new.target, BigNumber);\n\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","export const version = \"bignumber/5.6.0\";\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","export const version = \"address/5.6.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexDataLength, hexDataSlice, isHexString, stripZeros } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish, _base16To36, _base36To16 } from \"@ethersproject/bignumber\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { encode } from \"@ethersproject/rlp\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction getChecksumAddress(address: string): string {\n    if (!isHexString(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    address = address.toLowerCase();\n\n    const chars = address.substring(2).split(\"\");\n\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n\n    const hashed = arrayify(keccak256(expanded));\n\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n\n    return \"0x\" + chars.join(\"\");\n}\n\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER: number = 0x1fffffffffffff;\n\nfunction log10(x: number): number {\n    if (Math.log10) { return Math.log10(x); }\n    return Math.log(x) / Math.LN10;\n}\n\n\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\n// Create lookup table\nconst ibanLookup: { [character: string]: string } = { };\nfor (let i = 0; i < 10; i++) { ibanLookup[String(i)] = String(i); }\nfor (let i = 0; i < 26; i++) { ibanLookup[String.fromCharCode(65 + i)] = String(10 + i); }\n\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\nfunction ibanChecksum(address: string): string {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) { checksum = \"0\" + checksum; }\n\n    return checksum;\n};\n\nexport function getAddress(address: string): string {\n    let result = null;\n\n    if (typeof(address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") { address = \"0x\" + address; }\n\n        result = getChecksumAddress(address);\n\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n\n    // Maybe ICAP? (we only support direct mode)\n    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n\n        result = _base36To16(address.substring(4));\n        while (result.length < 40) { result = \"0\" + result; }\n        result = getChecksumAddress(\"0x\" + result);\n\n    } else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    return result;\n}\n\nexport function isAddress(address: string): boolean {\n    try {\n        getAddress(address);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getIcapAddress(address: string): string {\n    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nexport function getContractAddress(transaction: { from: string, nonce: BigNumberish }) {\n    let from: string = null;\n    try {\n        from = getAddress(transaction.from);\n    } catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n\n    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));\n\n    return getAddress(hexDataSlice(keccak256(encode([ from, nonce ])), 12));\n}\n\nexport function getCreate2Address(from: string, salt: BytesLike, initCodeHash: BytesLike): string {\n    if (hexDataLength(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if (hexDataLength(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress(hexDataSlice(keccak256(concat([ \"0xff\", getAddress(from), salt, initCodeHash ])), 12))\n}\n","export const version = \"strings/5.6.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n\nexport enum UnicodeNormalizationForm {\n    current  = \"\",\n    NFC      = \"NFC\",\n    NFD      = \"NFD\",\n    NFKC     = \"NFKC\",\n    NFKD     = \"NFKD\"\n};\n\nexport enum Utf8ErrorReason {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    UNEXPECTED_CONTINUE   = \"unexpected continuation byte\",\n\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    BAD_PREFIX            = \"bad codepoint prefix\",\n\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    OVERRUN               = \"string overrun\",\n\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    MISSING_CONTINUE      = \"missing continuation byte\",\n\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    OUT_OF_RANGE          = \"out of UTF-8 range\",\n\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    UTF16_SURROGATE       = \"UTF-16 surrogate\",\n\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    OVERLONG              = \"overlong representation\",\n};\n\n\nexport type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number) => number;\n\nfunction errorFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n    return logger.throwArgumentError(`invalid codepoint at offset ${ offset }; ${ reason }`, \"bytes\", bytes);\n}\n\nfunction ignoreFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) { break; }\n            i++;\n        }\n        return i;\n    }\n\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n\n    // Nothing to skip\n    return 0;\n}\n\nfunction replaceFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n\n    // Put the replacement character into the output\n    output.push(0xfffd);\n\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n\n// Common error handing strategies\nexport const Utf8ErrorFuncs: { [ name: string ]: Utf8ErrorFunc } = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes: BytesLike, onError?: Utf8ErrorFunc): Array<number> {\n    if (onError == null) { onError = Utf8ErrorFuncs.error; }\n\n    bytes = arrayify(bytes);\n\n    const result: Array<number> = [];\n    let i = 0;\n\n    // Invalid bytes are ignored\n    while(i < bytes.length) {\n\n        const c = bytes[i++];\n\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            } else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            };\n\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n\n        // See above loop for invalid continuation byte\n        if (res === null) { continue; }\n\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        result.push(res);\n    }\n\n    return result;\n}\n\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nexport function toUtf8Bytes(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Uint8Array {\n\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n\n        if (c < 0x80) {\n            result.push(c);\n\n        } else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n\n        } else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n\n    return arrayify(result);\n};\n\nfunction escapeChar(value: number) {\n    const hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\n\nexport function _toEscapedUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8:  return \"\\\\b\";\n                case 9:  return \"\\\\t\";\n                case 10: return \"\\\\n\"\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\n\nexport function _toUtf8String(codePoints: Array<number>): string {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode(\n            (((codePoint >> 10) & 0x3ff) + 0xd800),\n            ((codePoint & 0x3ff) + 0xdc00)\n        );\n    }).join(\"\");\n}\n\nexport function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n\nexport function toUtf8CodePoints(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n","import { keccak256 } from \"@ethersproject/keccak256\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nexport function id(text: string): string {\n    return keccak256(toUtf8Bytes(text));\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n","export const version = \"properties/5.6.0\";\n","export const version = \"abi/5.5.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexConcat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\n\nexport interface Result extends ReadonlyArray<any> {\n    readonly [key: string]: any;\n}\n\nexport function checkResultErrors(result: Result): Array<{ path: Array<string | number>, error: Error }> {\n    // Find the first error (if any)\n    const errors: Array<{ path: Array<string | number>, error: Error }> = [ ];\n\n    const checkErrors = function(path: Array<string | number>, object: any): void {\n        if (!Array.isArray(object)) { return; }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n\n            try {\n                 checkErrors(childPath, object[key]);\n            } catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    }\n    checkErrors([ ], result);\n\n    return errors;\n\n}\n\nexport type CoerceFunc = (type: string, value: any) => any;\n\nexport abstract class Coder {\n\n    // The coder name:\n    //   - address, uint256, tuple, array, etc.\n    readonly name: string;\n\n    // The fully expanded type, including composite types:\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n    readonly type: string;\n\n    // The localName bound in the signature, in this example it is \"baz\":\n    //   - tuple(address foo, uint bar) baz\n    readonly localName: string;\n\n    // Whether this type is dynamic:\n    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n    readonly dynamic: boolean;\n\n    constructor(name: string, type: string, localName: string, dynamic: boolean) {\n        // @TODO: defineReadOnly these\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n\n    _throwError(message: string, value: any): void {\n        logger.throwArgumentError(message, this.localName, value);\n    }\n\n    abstract encode(writer: Writer, value: any): number;\n    abstract decode(reader: Reader): any;\n\n    abstract defaultValue(): any;\n}\n\nexport class Writer {\n    readonly wordSize: number;\n\n    _data: Array<Uint8Array>;\n    _dataLength: number;\n    _padding: Uint8Array;\n\n    constructor(wordSize?: number) {\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        this._data = [ ];\n        this._dataLength = 0;\n        this._padding = new Uint8Array(wordSize);\n    }\n\n    get data(): string {\n        return hexConcat(this._data);\n    }\n    get length(): number { return this._dataLength; }\n\n    _writeData(data: Uint8Array): number {\n        this._data.push(data);\n        this._dataLength += data.length;\n        return data.length;\n    }\n\n    appendWriter(writer: Writer): number {\n        return this._writeData(concat(writer._data));\n    }\n\n    // Arrayish items; padded on the right to wordSize\n    writeBytes(value: BytesLike): number {\n        let bytes = arrayify(value);\n        const paddingOffset = bytes.length % this.wordSize;\n        if (paddingOffset) {\n            bytes = concat([ bytes, this._padding.slice(paddingOffset) ])\n        }\n        return this._writeData(bytes);\n    }\n\n    _getValue(value: BigNumberish): Uint8Array {\n        let bytes = arrayify(BigNumber.from(value));\n        if (bytes.length > this.wordSize) {\n            logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                length: this.wordSize,\n                offset: bytes.length\n            });\n        }\n        if (bytes.length % this.wordSize) {\n            bytes = concat([ this._padding.slice(bytes.length % this.wordSize), bytes ]);\n        }\n        return bytes;\n    }\n\n    // BigNumberish items; padded on the left to wordSize\n    writeValue(value: BigNumberish): number {\n        return this._writeData(this._getValue(value));\n    }\n\n    writeUpdatableValue(): (value: BigNumberish) => void {\n        const offset = this._data.length;\n        this._data.push(this._padding);\n        this._dataLength += this.wordSize;\n        return (value: BigNumberish) => {\n            this._data[offset] = this._getValue(value);\n        };\n    }\n}\n\nexport class Reader {\n    readonly wordSize: number;\n    readonly allowLoose: boolean;\n\n    readonly _data: Uint8Array;\n    readonly _coerceFunc: CoerceFunc;\n\n    _offset: number;\n\n    constructor(data: BytesLike, wordSize?: number, coerceFunc?: CoerceFunc, allowLoose?: boolean) {\n        defineReadOnly(this, \"_data\", arrayify(data));\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n        defineReadOnly(this, \"allowLoose\", allowLoose);\n\n        this._offset = 0;\n    }\n\n    get data(): string { return hexlify(this._data); }\n    get consumed(): number { return this._offset; }\n\n    // The default Coerce function\n    static coerce(name: string, value: any): any {\n        let match = name.match(\"^u?int([0-9]+)$\");\n        if (match && parseInt(match[1]) <= 48) { value =  value.toNumber(); }\n        return value;\n    }\n\n    coerce(name: string, value: any): any {\n        if (this._coerceFunc) { return this._coerceFunc(name, value); }\n        return Reader.coerce(name, value);\n    }\n\n    _peekBytes(offset: number, length: number, loose?: boolean): Uint8Array {\n        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n        if (this._offset + alignedLength > this._data.length) {\n            if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n                alignedLength = length;\n            } else {\n                logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                    length: this._data.length,\n                    offset: this._offset + alignedLength\n                });\n            }\n        }\n        return this._data.slice(this._offset, this._offset + alignedLength)\n    }\n\n    subReader(offset: number): Reader {\n        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n    }\n\n    readBytes(length: number, loose?: boolean): Uint8Array {\n        let bytes = this._peekBytes(0, length, !!loose);\n        this._offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n\n    readValue(): BigNumber {\n        return BigNumber.from(this.readBytes(this.wordSize));\n    }\n}\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { hexZeroPad } from \"@ethersproject/bytes\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class AddressCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"address\", \"address\", localName, false);\n    }\n\n    defaultValue(): string {\n        return \"0x0000000000000000000000000000000000000000\";\n    }\n\n    encode(writer: Writer, value: string): number {\n        try {\n            value = getAddress(value)\n        } catch (error) {\n            this._throwError(error.message, value);\n        }\n        return writer.writeValue(value);\n    }\n\n    decode(reader: Reader): any {\n        return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));\n    }\n}\n\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\n// Clones the functionality of an existing Coder, but without a localName\nexport class AnonymousCoder extends Coder {\n    private coder: Coder;\n\n    constructor(coder: Coder) {\n        super(coder.name, coder.type, undefined, coder.dynamic);\n        this.coder = coder;\n    }\n\n    defaultValue(): any {\n        return this.coder.defaultValue();\n    }\n\n    encode(writer: Writer, value: any): number {\n        return this.coder.encode(writer, value);\n    }\n\n    decode(reader: Reader): any {\n        return this.coder.decode(reader);\n    }\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\n\nimport { Coder, Reader, Result, Writer } from \"./abstract-coder\";\nimport { AnonymousCoder } from \"./anonymous\";\n\nexport function pack(writer: Writer, coders: ReadonlyArray<Coder>, values: Array<any> | { [ name: string ]: any }): number {\n    let arrayValues: Array<any> = null;\n\n    if (Array.isArray(values)) {\n       arrayValues = values;\n\n    } else if (values && typeof(values) === \"object\") {\n        let unique: { [ name: string ]: boolean } = { };\n\n        arrayValues = coders.map((coder) => {\n            const name = coder.localName;\n            if (!name) {\n                logger.throwError(\"cannot encode object for signature with missing names\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n\n            if (unique[name]) {\n                logger.throwError(\"cannot encode object for signature with duplicate names\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n\n            unique[name] = true;\n\n            return values[name];\n        });\n\n    } else {\n        logger.throwArgumentError(\"invalid tuple value\", \"tuple\", values);\n    }\n\n    if (coders.length !== arrayValues.length) {\n        logger.throwArgumentError(\"types/value length mismatch\", \"tuple\", values);\n    }\n\n    let staticWriter = new Writer(writer.wordSize);\n    let dynamicWriter = new Writer(writer.wordSize);\n\n    let updateFuncs: Array<(baseOffset: number) => void> = [];\n    coders.forEach((coder, index) => {\n        let value = arrayValues[index];\n\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            let dynamicOffset = dynamicWriter.length;\n\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n\n            // Prepare to populate the correct offset once we are done\n            let updateFunc = staticWriter.writeUpdatableValue();\n            updateFuncs.push((baseOffset: number) => {\n                updateFunc(baseOffset + dynamicOffset);\n            });\n\n        } else {\n            coder.encode(staticWriter, value);\n        }\n    });\n\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach((func) => { func(staticWriter.length); });\n\n    let length = writer.appendWriter(staticWriter);\n    length += writer.appendWriter(dynamicWriter);\n    return length;\n}\n\nexport function unpack(reader: Reader, coders: Array<Coder>): Result {\n    let values: any = [];\n\n    // A reader anchored to this base\n    let baseReader = reader.subReader(0);\n\n    coders.forEach((coder) => {\n        let value: any = null;\n\n        if (coder.dynamic) {\n            let offset = reader.readValue();\n            let offsetReader = baseReader.subReader(offset.toNumber());\n            try {\n                value = coder.decode(offsetReader);\n            } catch (error) {\n                // Cannot recover from this\n                if (error.code === Logger.errors.BUFFER_OVERRUN) { throw error; }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n\n        } else {\n            try {\n                value = coder.decode(reader);\n            } catch (error) {\n                // Cannot recover from this\n                if (error.code === Logger.errors.BUFFER_OVERRUN) { throw error; }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n\n        if (value != undefined) {\n            values.push(value);\n        }\n    });\n\n    // We only output named properties for uniquely named coders\n    const uniqueNames = coders.reduce((accum, coder) => {\n        const name = coder.localName;\n        if (name) {\n            if (!accum[name]) { accum[name] = 0; }\n            accum[name]++;\n        }\n        return accum;\n    }, <{ [ name: string ]: number }>{ });\n\n    // Add any named parameters (i.e. tuples)\n    coders.forEach((coder: Coder, index: number) => {\n        let name = coder.localName;\n        if (!name || uniqueNames[name] !== 1) { return; }\n\n        if (name === \"length\") { name = \"_length\"; }\n\n        if (values[name] != null) { return; }\n\n        const value = values[index];\n\n        if (value instanceof Error) {\n            Object.defineProperty(values, name, {\n                enumerable: true,\n                get: () => { throw value; }\n            });\n        } else {\n            values[name] = value;\n        }\n    });\n\n    for (let i = 0; i < values.length; i++) {\n        const value = values[i];\n        if (value instanceof Error) {\n            Object.defineProperty(values, i, {\n                enumerable: true,\n                get: () => { throw value; }\n            });\n        }\n    }\n\n    return Object.freeze(values);\n}\n\n\nexport class ArrayCoder extends Coder {\n    readonly coder: Coder;\n    readonly length: number;\n\n    constructor(coder: Coder, length: number, localName: string) {\n        const type = (coder.type + \"[\" + (length >= 0 ? length: \"\") + \"]\");\n        const dynamic = (length === -1 || coder.dynamic);\n        super(\"array\", type, localName, dynamic);\n\n        this.coder = coder;\n        this.length = length;\n    }\n\n    defaultValue(): Array<any> {\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n        const defaultChild = this.coder.defaultValue();\n\n        const result: Array<any> = [];\n        for (let i = 0; i < this.length; i++) {\n            result.push(defaultChild);\n        }\n        return result;\n    }\n\n    encode(writer: Writer, value: Array<any>): number {\n        if (!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n\n        let count = this.length;\n\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n\n        logger.checkArgumentCount(value.length, count, \"coder array\" + (this.localName? (\" \"+ this.localName): \"\"));\n\n        let coders = [];\n        for (let i = 0; i < value.length; i++) { coders.push(this.coder); }\n\n        return pack(writer, coders, value);\n    }\n\n    decode(reader: Reader): any {\n        let count = this.length;\n        if (count === -1) {\n            count = reader.readValue().toNumber();\n\n            // Check that there is *roughly* enough data to ensure\n            // stray random data is not being read as a length. Each\n            // slot requires at least 32 bytes for their value (or 32\n            // bytes as a link to the data). This could use a much\n            // tighter bound, but we are erroring on the side of safety.\n            if (count * 32 > reader._data.length) {\n                logger.throwError(\"insufficient data length\", Logger.errors.BUFFER_OVERRUN, {\n                    length: reader._data.length,\n                    count: count\n                });\n            }\n        }\n        let coders = [];\n        for (let i = 0; i < count; i++) { coders.push(new AnonymousCoder(this.coder)); }\n\n        return reader.coerce(this.name, unpack(reader, coders));\n    }\n}\n\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class BooleanCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"bool\", \"bool\", localName, false);\n    }\n\n    defaultValue(): boolean {\n        return false;\n    }\n\n    encode(writer: Writer, value: boolean): number {\n        return writer.writeValue(value ? 1: 0);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.type, !reader.readValue().isZero());\n    }\n}\n\n","\"use strict\";\n\nimport { arrayify, hexlify } from \"@ethersproject/bytes\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class DynamicBytesCoder extends Coder {\n    constructor(type: string, localName: string) {\n       super(type, type, localName, true);\n    }\n\n    defaultValue(): string {\n        return \"0x\";\n    }\n\n    encode(writer: Writer, value: any): number {\n        value = arrayify(value);\n        let length = writer.writeValue(value.length);\n        length += writer.writeBytes(value);\n        return length;\n    }\n\n    decode(reader: Reader): any {\n        return reader.readBytes(reader.readValue().toNumber(), true);\n    }\n}\n\nexport class BytesCoder extends DynamicBytesCoder {\n    constructor(localName: string) {\n        super(\"bytes\", localName);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, hexlify(super.decode(reader)));\n    }\n}\n\n\n","\"use strict\";\n\nimport { arrayify, BytesLike, hexlify } from \"@ethersproject/bytes\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\n// @TODO: Merge this with bytes\nexport class FixedBytesCoder extends Coder {\n    readonly size: number;\n\n    constructor(size: number, localName: string) {\n        let name = \"bytes\" + String(size);\n        super(name, name, localName, false);\n        this.size = size;\n    }\n\n    defaultValue(): string {\n        return (\"0x0000000000000000000000000000000000000000000000000000000000000000\").substring(0, 2 + this.size * 2);\n    }\n\n    encode(writer: Writer, value: BytesLike): number {\n        let data = arrayify(value);\n        if (data.length !== this.size) { this._throwError(\"incorrect data length\", value); }\n        return writer.writeBytes(data);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));\n    }\n}\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class NullCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"null\", \"\", localName, false);\n    }\n\n    defaultValue(): null {\n        return null;\n    }\n\n    encode(writer: Writer, value: any): number {\n        if (value != null) { this._throwError(\"not null\", value); }\n        return writer.writeBytes([ ]);\n    }\n\n    decode(reader: Reader): any {\n        reader.readBytes(0);\n        return reader.coerce(this.name, null);\n    }\n}\n","import { BigNumber } from \"@ethersproject/bignumber\";\n\nconst NegativeOne: BigNumber = (/*#__PURE__*/BigNumber.from(-1));\nconst Zero: BigNumber = (/*#__PURE__*/BigNumber.from(0));\nconst One: BigNumber = (/*#__PURE__*/BigNumber.from(1));\nconst Two: BigNumber = (/*#__PURE__*/BigNumber.from(2));\nconst WeiPerEther: BigNumber = (/*#__PURE__*/BigNumber.from(\"1000000000000000000\"));\nconst MaxUint256: BigNumber = (/*#__PURE__*/BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n\nconst MinInt256: BigNumber = (/*#__PURE__*/BigNumber.from(\"-0x8000000000000000000000000000000000000000000000000000000000000000\"));\nconst MaxInt256: BigNumber = (/*#__PURE__*/BigNumber.from(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n\nexport {\n    NegativeOne,\n    Zero,\n    One,\n    Two,\n    WeiPerEther,\n    MaxUint256,\n    MinInt256,\n    MaxInt256,\n};\n","\"use strict\";\n\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { MaxUint256, NegativeOne, One, Zero } from \"@ethersproject/constants\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class NumberCoder extends Coder {\n    readonly size: number;\n    readonly signed: boolean;\n\n    constructor(size: number, signed: boolean, localName: string) {\n        const name = ((signed ? \"int\": \"uint\") + (size * 8));\n        super(name, name, localName, false);\n\n        this.size = size;\n        this.signed = signed;\n    }\n\n    defaultValue(): number {\n        return 0;\n    }\n\n    encode(writer: Writer, value: BigNumberish): number {\n        let v = BigNumber.from(value);\n\n        // Check bounds are safe for encoding\n        let maxUintValue = MaxUint256.mask(writer.wordSize * 8);\n        if (this.signed) {\n            let bounds = maxUintValue.mask(this.size * 8 - 1);\n            if (v.gt(bounds) || v.lt(bounds.add(One).mul(NegativeOne))) {\n                this._throwError(\"value out-of-bounds\", value);\n            }\n        } else if (v.lt(Zero) || v.gt(maxUintValue.mask(this.size * 8))) {\n            this._throwError(\"value out-of-bounds\", value);\n        }\n\n        v = v.toTwos(this.size * 8).mask(this.size * 8);\n\n        if (this.signed) {\n            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);\n        }\n\n        return writer.writeValue(v);\n    }\n\n    decode(reader: Reader): any {\n        let value = reader.readValue().mask(this.size * 8);\n\n        if (this.signed) {\n            value = value.fromTwos(this.size * 8);\n        }\n\n        return reader.coerce(this.name, value);\n    }\n}\n\n","\"use strict\";\n\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\n\nimport { Reader, Writer } from \"./abstract-coder\";\nimport { DynamicBytesCoder } from \"./bytes\";\n\nexport class StringCoder extends DynamicBytesCoder {\n\n    constructor(localName: string) {\n        super(\"string\", localName);\n    }\n\n    defaultValue(): string {\n        return \"\";\n    }\n\n    encode(writer: Writer, value: any): number {\n        return super.encode(writer, toUtf8Bytes(value));\n    }\n\n    decode(reader: Reader): any {\n        return toUtf8String(super.decode(reader));\n    }\n}\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\nimport { pack, unpack } from \"./array\";\n\nexport class TupleCoder extends Coder {\n    readonly coders: Array<Coder>;\n\n    constructor(coders: Array<Coder>, localName: string) {\n        let dynamic = false;\n        const types: Array<string> = [];\n        coders.forEach((coder) => {\n            if (coder.dynamic) { dynamic = true; }\n            types.push(coder.type);\n        });\n        const type = (\"tuple(\" + types.join(\",\") + \")\");\n\n        super(\"tuple\", type, localName, dynamic);\n        this.coders = coders;\n    }\n\n    defaultValue(): any {\n        const values: any = [ ];\n        this.coders.forEach((coder) => {\n            values.push(coder.defaultValue());\n        });\n\n        // We only output named properties for uniquely named coders\n        const uniqueNames = this.coders.reduce((accum, coder) => {\n            const name = coder.localName;\n            if (name) {\n                if (!accum[name]) { accum[name] = 0; }\n                accum[name]++;\n            }\n            return accum;\n        }, <{ [ name: string ]: number }>{ });\n\n        // Add named values\n        this.coders.forEach((coder: Coder, index: number) => {\n            let name = coder.localName;\n            if (!name || uniqueNames[name] !== 1) { return; }\n\n            if (name === \"length\") { name = \"_length\"; }\n\n            if (values[name] != null) { return; }\n\n            values[name] = values[index];\n        });\n\n        return Object.freeze(values);\n    }\n\n    encode(writer: Writer, value: Array<any> | { [ name: string ]: any }): number {\n        return pack(writer, this.coders, value);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, unpack(reader, this.coders));\n    }\n}\n\n","\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport interface JsonFragmentType {\n    readonly name?: string;\n    readonly indexed?: boolean;\n    readonly type?: string;\n    readonly internalType?: any; // @TODO: in v6 reduce type\n    readonly components?: ReadonlyArray<JsonFragmentType>;\n}\n\nexport interface JsonFragment {\n    readonly name?: string;\n    readonly type?: string;\n\n    readonly anonymous?: boolean;\n\n    readonly payable?: boolean;\n    readonly constant?: boolean;\n    readonly stateMutability?: string;\n\n    readonly inputs?: ReadonlyArray<JsonFragmentType>;\n    readonly outputs?: ReadonlyArray<JsonFragmentType>;\n\n    readonly gas?: string;\n};\n\nconst _constructorGuard = { };\n\n// AST Node parser state\ntype ParseState = {\n    allowArray?: boolean,\n    allowName?: boolean,\n    allowParams?: boolean,\n    allowType?: boolean,\n    readArray?: boolean,\n};\n\n// AST Node\ntype ParseNode = {\n    parent?: any,\n    type?: string,\n    name?: string,\n    state?: ParseState,\n    indexed?: boolean,\n    components?: Array<ParseNode>\n};\n\nlet ModifiersBytes: { [ name: string ]: boolean } = { calldata: true, memory: true, storage: true };\nlet ModifiersNest: { [ name: string ]: boolean } = { calldata: true, memory: true };\nfunction checkModifier(type: string, name: string): boolean {\n    if (type === \"bytes\" || type === \"string\") {\n        if (ModifiersBytes[name]) { return true; }\n    } else if (type === \"address\") {\n        if (name === \"payable\") { return true; }\n    } else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\n        if (ModifiersNest[name]) { return true; }\n    }\n    if (ModifiersBytes[name] || name === \"payable\") {\n        logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n    }\n    return false;\n}\n\n// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\nfunction parseParamType(param: string, allowIndexed: boolean): ParseNode {\n\n    let originalParam = param;\n    function throwError(i: number) {\n        logger.throwArgumentError(`unexpected character at position ${ i }`, \"param\", param);\n    }\n    param = param.replace(/\\s/g, \" \");\n\n    function newNode(parent: ParseNode): ParseNode {\n        let node: ParseNode = { type: \"\", name: \"\", parent: parent, state: { allowType: true } };\n        if (allowIndexed) { node.indexed = false; }\n        return node\n    }\n\n    let parent: ParseNode = { type: \"\", name: \"\", state: { allowType: true } };\n    let node = parent;\n\n    for (let i = 0; i < param.length; i++) {\n        let c = param[i];\n        switch (c) {\n            case \"(\":\n                if (node.state.allowType && node.type === \"\") {\n                    node.type = \"tuple\";\n                } else if (!node.state.allowParams) {\n                    throwError(i);\n                }\n                node.state.allowType = false;\n                node.type = verifyType(node.type);\n                node.components = [ newNode(node) ];\n                node = node.components[0];\n                break;\n\n            case \")\":\n                delete node.state;\n\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) { throwError(i); }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n\n                if (checkModifier(node.type, node.name)) { node.name = \"\"; }\n\n                node.type = verifyType(node.type);\n\n                let child = node;\n                node = node.parent;\n                if (!node) { throwError(i); }\n                delete child.parent;\n                node.state.allowParams = false;\n                node.state.allowName = true;\n                node.state.allowArray = true;\n                break;\n\n            case \",\":\n                delete node.state;\n\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) { throwError(i); }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n\n                if (checkModifier(node.type, node.name)) { node.name = \"\"; }\n\n                node.type = verifyType(node.type);\n\n                let sibling: ParseNode = newNode(node.parent);\n                 //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n                node.parent.components.push(sibling);\n                delete node.parent;\n                node = sibling;\n                break;\n\n            // Hit a space...\n            case \" \":\n\n                // If reading type, the type is done and may read a param or name\n                if (node.state.allowType) {\n                    if (node.type !== \"\") {\n                        node.type = verifyType(node.type);\n                        delete node.state.allowType;\n                        node.state.allowName = true;\n                        node.state.allowParams = true;\n                    }\n                }\n\n                // If reading name, the name is done\n                if (node.state.allowName) {\n                    if (node.name !== \"\") {\n                        if (node.name === \"indexed\") {\n                            if (!allowIndexed) { throwError(i); }\n                            if (node.indexed) { throwError(i); }\n                            node.indexed = true;\n                            node.name = \"\";\n                        } else if (checkModifier(node.type, node.name)) {\n                            node.name = \"\";\n                        } else {\n                            node.state.allowName = false;\n                        }\n                    }\n                }\n\n                break;\n\n            case \"[\":\n                if (!node.state.allowArray) { throwError(i); }\n\n                node.type += c;\n\n                node.state.allowArray = false;\n                node.state.allowName = false;\n                node.state.readArray = true;\n                break;\n\n            case \"]\":\n                if (!node.state.readArray) { throwError(i); }\n\n                node.type += c;\n\n                node.state.readArray = false;\n                node.state.allowArray = true;\n                node.state.allowName = true;\n                break;\n\n            default:\n                if (node.state.allowType) {\n                    node.type += c;\n                    node.state.allowParams = true;\n                    node.state.allowArray = true;\n                } else if (node.state.allowName) {\n                    node.name += c;\n                    delete node.state.allowArray;\n                } else if (node.state.readArray) {\n                    node.type += c;\n                } else {\n                    throwError(i);\n               }\n        }\n    }\n\n    if (node.parent) { logger.throwArgumentError(\"unexpected eof\", \"param\", param); }\n\n    delete parent.state;\n\n    if (node.name === \"indexed\") {\n        if (!allowIndexed) { throwError(originalParam.length - 7); }\n        if (node.indexed) { throwError(originalParam.length - 7); }\n        node.indexed = true;\n        node.name = \"\";\n    } else if (checkModifier(node.type, node.name)) {\n        node.name = \"\";\n    }\n\n    parent.type = verifyType(parent.type);\n\n    return parent;\n}\n\nfunction populate(object: any, params: any) {\n    for (let key in params) { defineReadOnly(object, key, params[key]); }\n}\n\nexport const FormatTypes: { [ name: string ]: string } = Object.freeze({\n    // Bare formatting, as is needed for computing a sighash of an event or function\n    sighash: \"sighash\",\n\n    // Human-Readable with Minimal spacing and without names (compact human-readable)\n    minimal: \"minimal\",\n\n    // Human-Readable with nice spacing, including all names\n    full: \"full\",\n\n    // JSON-format a la Solidity\n    json: \"json\"\n});\n\nconst paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n\nexport class ParamType {\n\n    // The local name of the parameter (of null if unbound)\n    readonly name: string;\n\n    // The fully qualified type (e.g. \"address\", \"tuple(address)\", \"uint256[3][]\"\n    readonly type: string;\n\n    // The base type (e.g. \"address\", \"tuple\", \"array\")\n    readonly baseType: string;\n\n    // Indexable Paramters ONLY (otherwise null)\n    readonly indexed: boolean;\n\n    // Tuples ONLY: (otherwise null)\n    //  - sub-components\n    readonly components: Array<ParamType>;\n\n    // Arrays ONLY: (otherwise null)\n    //  - length of the array (-1 for dynamic length)\n    //  - child type\n    readonly arrayLength: number;\n    readonly arrayChildren: ParamType;\n\n    readonly _isParamType: boolean;\n\n    constructor(constructorGuard: any, params: any) {\n        if (constructorGuard !== _constructorGuard) { logger.throwError(\"use fromString\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new ParamType()\"\n        }); }\n        populate(this, params);\n\n        let match = this.type.match(paramTypeArray);\n        if (match) {\n            populate(this, {\n                arrayLength: parseInt(match[2] || \"-1\"),\n                arrayChildren: ParamType.fromObject({\n                    type: match[1],\n                    components: this.components\n                }),\n                baseType: \"array\"\n            });\n        } else {\n            populate(this, {\n                arrayLength: null,\n                arrayChildren: null,\n                baseType: ((this.components != null) ? \"tuple\": this.type)\n            });\n        }\n\n        this._isParamType = true;\n\n        Object.freeze(this);\n    }\n\n    // Format the parameter fragment\n    //   - sighash: \"(uint256,address)\"\n    //   - minimal: \"tuple(uint256,address) indexed\"\n    //   - full:    \"tuple(uint256 foo, address bar) indexed baz\"\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            let result: any = {\n                type: ((this.baseType === \"tuple\") ? \"tuple\": this.type),\n                name: (this.name || undefined)\n            };\n            if (typeof(this.indexed) === \"boolean\") { result.indexed = this.indexed; }\n            if (this.components) {\n                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n\n        let result = \"\";\n\n        // Array\n        if (this.baseType === \"array\") {\n            result += this.arrayChildren.format(format);\n            result += \"[\" + (this.arrayLength < 0 ? \"\": String(this.arrayLength)) + \"]\";\n        } else {\n            if (this.baseType === \"tuple\") {\n                if (format !== FormatTypes.sighash) {\n                    result += this.type;\n                }\n                result += \"(\" + this.components.map(\n                    (comp) => comp.format(format)\n                ).join((format === FormatTypes.full) ? \", \": \",\") + \")\";\n            } else {\n                result += this.type;\n            }\n        }\n\n        if (format !== FormatTypes.sighash) {\n            if (this.indexed === true) { result += \" indexed\"; }\n            if (format === FormatTypes.full && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n\n        return result;\n    }\n\n    static from(value: string | JsonFragmentType | ParamType, allowIndexed?: boolean): ParamType {\n        if (typeof(value) === \"string\") {\n            return ParamType.fromString(value, allowIndexed);\n        }\n        return ParamType.fromObject(value);\n    }\n\n    static fromObject(value: JsonFragmentType | ParamType): ParamType {\n        if (ParamType.isParamType(value)) { return value; }\n\n        return new ParamType(_constructorGuard, {\n            name: (value.name || null),\n            type: verifyType(value.type),\n            indexed: ((value.indexed == null) ? null: !!value.indexed),\n            components: (value.components ? value.components.map(ParamType.fromObject): null)\n        });\n    }\n\n    static fromString(value: string, allowIndexed?: boolean): ParamType {\n        function ParamTypify(node: ParseNode): ParamType {\n            return ParamType.fromObject({\n                name: node.name,\n                type: node.type,\n                indexed: node.indexed,\n                components: node.components\n            });\n        }\n\n        return ParamTypify(parseParamType(value, !!allowIndexed));\n    }\n\n    static isParamType(value: any): value is ParamType {\n        return !!(value != null && value._isParamType);\n    }\n};\n\nfunction parseParams(value: string, allowIndex: boolean): Array<ParamType> {\n    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));\n}\n\ntype TypeCheck<T> = { -readonly [ K in keyof T ]: T[K] };\n\ninterface _Fragment {\n    readonly type: string;\n    readonly name: string;\n    readonly inputs: ReadonlyArray<ParamType>;\n}\n\nexport abstract class Fragment {\n\n    readonly type: string;\n    readonly name: string;\n    readonly inputs: Array<ParamType>;\n\n    readonly _isFragment: boolean;\n\n    constructor(constructorGuard: any, params: any) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"use a static from method\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new Fragment()\"\n            });\n        }\n        populate(this, params);\n\n        this._isFragment = true;\n\n        Object.freeze(this);\n    }\n\n    abstract format(format?: string): string;\n\n    static from(value: Fragment | JsonFragment | string): Fragment {\n        if (Fragment.isFragment(value)) { return value; }\n\n        if (typeof(value) === \"string\") {\n            return Fragment.fromString(value);\n        }\n\n        return Fragment.fromObject(value);\n    }\n\n    static fromObject(value: Fragment | JsonFragment): Fragment {\n        if (Fragment.isFragment(value)) { return value; }\n\n        switch (value.type) {\n            case \"function\":\n                return FunctionFragment.fromObject(value);\n            case \"event\":\n                return EventFragment.fromObject(value);\n            case \"constructor\":\n                return ConstructorFragment.fromObject(value);\n            case \"error\":\n                return ErrorFragment.fromObject(value);\n            case \"fallback\":\n            case \"receive\":\n                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n                return null;\n        }\n\n        return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n    }\n\n    static fromString(value: string): Fragment {\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n        value = value.replace(/\\s/g, \" \");\n        value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n        value = value.trim();\n\n        if (value.split(\" \")[0] === \"event\") {\n           return EventFragment.fromString(value.substring(5).trim());\n        } else if (value.split(\" \")[0] === \"function\") {\n            return FunctionFragment.fromString(value.substring(8).trim());\n        } else if (value.split(\"(\")[0].trim() === \"constructor\") {\n            return ConstructorFragment.fromString(value.trim());\n        } else if (value.split(\" \")[0] === \"error\") {\n           return ErrorFragment.fromString(value.substring(5).trim());\n        }\n\n        return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\n    }\n\n    static isFragment(value: any): value is Fragment {\n        return !!(value && value._isFragment);\n    }\n}\n\ninterface _EventFragment extends _Fragment {\n    readonly anonymous: boolean;\n}\n\nexport class EventFragment extends Fragment {\n    readonly anonymous: boolean;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"event \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (format !== FormatTypes.sighash) {\n            if (this.anonymous) {\n                result += \"anonymous \";\n            }\n        }\n\n        return result.trim();\n    }\n\n    static from(value: EventFragment | JsonFragment | string): EventFragment {\n        if (typeof(value) === \"string\") {\n            return EventFragment.fromString(value);\n        }\n        return EventFragment.fromObject(value);\n    }\n\n    static fromObject(value: JsonFragment | EventFragment): EventFragment {\n        if (EventFragment.isEventFragment(value)) { return value; }\n\n        if (value.type !== \"event\") {\n            logger.throwArgumentError(\"invalid event object\", \"value\", value);\n        }\n\n        const params: TypeCheck<_EventFragment> = {\n            name: verifyIdentifier(value.name),\n            anonymous: value.anonymous,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            type: \"event\"\n        };\n\n        return new EventFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): EventFragment {\n\n        let match = value.match(regexParen);\n        if (!match) {\n            logger.throwArgumentError(\"invalid event string\", \"value\", value);\n        }\n\n        let anonymous = false;\n        match[3].split(\" \").forEach((modifier) => {\n            switch(modifier.trim()) {\n                case \"anonymous\":\n                    anonymous = true;\n                    break;\n                case \"\":\n                    break;\n                default:\n                    logger.warn(\"unknown modifier: \" + modifier);\n            }\n        });\n\n        return EventFragment.fromObject({\n            name: match[1].trim(),\n            anonymous: anonymous,\n            inputs: parseParams(match[2], true),\n            type: \"event\"\n        });\n    }\n\n    static isEventFragment(value: any): value is EventFragment {\n        return (value && value._isFragment && value.type === \"event\");\n    }\n}\n\nfunction parseGas(value: string, params: any): string {\n    params.gas = null;\n\n    let comps = value.split(\"@\");\n    if (comps.length !== 1) {\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\n        }\n        if (!comps[1].match(/^[0-9]+$/)) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\n        }\n        params.gas = BigNumber.from(comps[1]);\n        return comps[0];\n    }\n\n    return value;\n}\n\nfunction parseModifiers(value: string, params: any): void {\n    params.constant = false;\n    params.payable = false;\n    params.stateMutability = \"nonpayable\";\n\n    value.split(\" \").forEach((modifier) => {\n        switch (modifier.trim()) {\n            case \"constant\":\n                params.constant = true;\n                break;\n            case \"payable\":\n                params.payable = true;\n                params.stateMutability = \"payable\";\n                break;\n            case \"nonpayable\":\n                params.payable = false;\n                params.stateMutability = \"nonpayable\";\n                break;\n            case \"pure\":\n                params.constant = true;\n                params.stateMutability = \"pure\";\n                break;\n            case \"view\":\n                params.constant = true;\n                params.stateMutability = \"view\";\n                break;\n            case \"external\":\n            case \"public\":\n            case \"\":\n                break;\n            default:\n                console.log(\"unknown modifier: \" + modifier);\n        }\n    });\n}\n\ntype StateInputValue = {\n    constant?: boolean;\n    payable?: boolean;\n    stateMutability?: string;\n    type?: string;\n};\n\ntype StateOutputValue = {\n    constant: boolean;\n    payable: boolean;\n    stateMutability: string;\n};\n\nfunction verifyState(value: StateInputValue): StateOutputValue {\n    let result: any = {\n        constant: false,\n        payable: true,\n        stateMutability: \"payable\"\n    };\n\n    if (value.stateMutability != null) {\n        result.stateMutability = value.stateMutability;\n\n        // Set (and check things are consistent) the constant property\n        result.constant = (result.stateMutability === \"view\" || result.stateMutability === \"pure\");\n        if (value.constant != null) {\n            if ((!!value.constant) !== result.constant) {\n                logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n\n        // Set (and check things are consistent) the payable property\n        result.payable = (result.stateMutability === \"payable\");\n        if (value.payable != null) {\n            if ((!!value.payable) !== result.payable) {\n                logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n\n    } else if (value.payable != null) {\n        result.payable = !!value.payable;\n\n        // If payable we can assume non-constant; otherwise we can't assume\n        if (value.constant == null && !result.payable && value.type !== \"constructor\") {\n            logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n        }\n\n        result.constant = !!value.constant;\n\n        if (result.constant) {\n            result.stateMutability = \"view\";\n        } else {\n            result.stateMutability = (result.payable ? \"payable\": \"nonpayable\");\n        }\n\n        if (result.payable && result.constant) {\n            logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\n        }\n\n    } else if (value.constant != null) {\n        result.constant = !!value.constant;\n        result.payable = !result.constant;\n        result.stateMutability = (result.constant ? \"view\": \"payable\");\n\n    } else if (value.type !== \"constructor\") {\n        logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n    }\n\n    return result;\n}\n\ninterface _ConstructorFragment extends _Fragment {\n    stateMutability: string;\n    payable: boolean;\n    gas?: BigNumber;\n}\n\nexport class ConstructorFragment extends Fragment {\n    stateMutability: string;\n    payable: boolean;\n    gas?: BigNumber;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability: undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber(): undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n\n        if (format === FormatTypes.sighash) {\n            logger.throwError(\"cannot format a constructor for sighash\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"format(sighash)\"\n            });\n        }\n\n        let result = \"constructor(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n            result += this.stateMutability + \" \";\n        }\n\n        return result.trim();\n    }\n\n    static from(value: ConstructorFragment | JsonFragment | string): ConstructorFragment {\n        if (typeof(value) === \"string\") {\n            return ConstructorFragment.fromString(value);\n        }\n        return ConstructorFragment.fromObject(value);\n    }\n\n    static fromObject(value: ConstructorFragment | JsonFragment): ConstructorFragment {\n        if (ConstructorFragment.isConstructorFragment(value)) { return value; }\n\n        if (value.type !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\n        }\n\n        let state = verifyState(value);\n        if (state.constant) {\n            logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\n        }\n\n        const params: TypeCheck<_ConstructorFragment> = {\n            name: null,\n            type: value.type,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): []),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas): null)\n        };\n\n        return new ConstructorFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): ConstructorFragment {\n        let params: any = { type: \"constructor\" };\n\n        value = parseGas(value, params);\n\n        let parens = value.match(regexParen);\n        if (!parens || parens[1].trim() !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\n        }\n\n        params.inputs = parseParams(parens[2].trim(), false);\n\n        parseModifiers(parens[3].trim(), params);\n\n        return ConstructorFragment.fromObject(params);\n    }\n\n    static isConstructorFragment(value: any): value is ConstructorFragment {\n        return (value && value._isFragment && value.type === \"constructor\");\n    }\n}\n\ninterface _FunctionFragment extends _ConstructorFragment {\n    constant: boolean;\n    outputs?: Array<ParamType>;\n}\n\nexport class FunctionFragment extends ConstructorFragment {\n    constant: boolean;\n    outputs?: Array<ParamType>;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability: undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber(): undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n                outputs: this.outputs.map((output) => JSON.parse(output.format(format))),\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"function \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (format !== FormatTypes.sighash) {\n            if (this.stateMutability) {\n                if (this.stateMutability !== \"nonpayable\") {\n                    result += (this.stateMutability + \" \");\n                }\n            } else if (this.constant) {\n                result += \"view \";\n            }\n\n            if (this.outputs && this.outputs.length) {\n                result += \"returns (\" + this.outputs.map(\n                    (output) => output.format(format)\n                ).join(\", \") + \") \";\n            }\n\n            if (this.gas != null) {\n                result += \"@\" + this.gas.toString() + \" \";\n            }\n        }\n\n        return result.trim();\n    }\n\n    static from(value: FunctionFragment | JsonFragment | string): FunctionFragment {\n        if (typeof(value) === \"string\") {\n            return FunctionFragment.fromString(value);\n        }\n        return FunctionFragment.fromObject(value);\n    }\n\n    static fromObject(value: FunctionFragment | JsonFragment): FunctionFragment {\n        if (FunctionFragment.isFunctionFragment(value)) { return value; }\n\n        if (value.type !== \"function\") {\n            logger.throwArgumentError(\"invalid function object\", \"value\", value);\n        }\n\n        let state = verifyState(value);\n\n        const params: TypeCheck<_FunctionFragment> = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            constant: state.constant,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): []),\n            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject): [ ]),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas): null)\n        };\n\n        return new FunctionFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): FunctionFragment {\n        let params: any = { type: \"function\" };\n        value = parseGas(value, params);\n\n        let comps = value.split(\" returns \");\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid function string\", \"value\", value);\n        }\n\n        let parens = comps[0].match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid function signature\", \"value\", value);\n        }\n\n        params.name = parens[1].trim();\n        if (params.name) { verifyIdentifier(params.name); }\n\n        params.inputs = parseParams(parens[2], false);\n\n        parseModifiers(parens[3].trim(), params);\n\n        // We have outputs\n        if (comps.length > 1) {\n           let returns = comps[1].match(regexParen);\n            if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n                logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\n            }\n            params.outputs = parseParams(returns[2], false);\n        } else {\n            params.outputs = [ ];\n        }\n\n        return FunctionFragment.fromObject(params);\n    }\n\n    static isFunctionFragment(value: any): value is FunctionFragment {\n        return (value && value._isFragment && value.type === \"function\");\n    }\n}\n\n//export class StructFragment extends Fragment {\n//}\n\nfunction checkForbidden(fragment: ErrorFragment): ErrorFragment {\n    const sig = fragment.format();\n    if (sig === \"Error(string)\" || sig === \"Panic(uint256)\") {\n        logger.throwArgumentError(`cannot specify user defined ${ sig } error`, \"fragment\", fragment);\n    }\n    return fragment;\n}\n\nexport class ErrorFragment extends Fragment {\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"error \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        return result.trim();\n    }\n\n    static from(value: ErrorFragment | JsonFragment | string): ErrorFragment {\n        if (typeof(value) === \"string\") {\n            return ErrorFragment.fromString(value);\n        }\n        return ErrorFragment.fromObject(value);\n    }\n\n    static fromObject(value: ErrorFragment | JsonFragment): ErrorFragment {\n        if (ErrorFragment.isErrorFragment(value)) { return value; }\n\n        if (value.type !== \"error\") {\n            logger.throwArgumentError(\"invalid error object\", \"value\", value);\n        }\n\n        const params: TypeCheck<_Fragment> = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): [])\n        };\n\n        return checkForbidden(new ErrorFragment(_constructorGuard, params));\n    }\n\n    static fromString(value: string): ErrorFragment {\n        let params: any = { type: \"error\" };\n\n        let parens = value.match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid error signature\", \"value\", value);\n        }\n\n        params.name = parens[1].trim();\n        if (params.name) { verifyIdentifier(params.name); }\n\n        params.inputs = parseParams(parens[2], false);\n\n        return checkForbidden(ErrorFragment.fromObject(params));\n    }\n\n    static isErrorFragment(value: any): value is ErrorFragment {\n        return (value && value._isFragment && value.type === \"error\");\n    }\n}\n\nfunction verifyType(type: string): string {\n\n    // These need to be transformed to their full description\n    if (type.match(/^uint($|[^1-9])/)) {\n        type = \"uint256\" + type.substring(4);\n    } else if (type.match(/^int($|[^1-9])/)) {\n        type = \"int256\" + type.substring(3);\n    }\n\n    // @TODO: more verification\n\n    return type;\n}\n\n// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234\nconst regexIdentifier = new RegExp(\"^[a-zA-Z$_][a-zA-Z0-9$_]*$\");\nfunction verifyIdentifier(value: string): string {\n    if (!value || !value.match(regexIdentifier)) {\n        logger.throwArgumentError(`invalid identifier \"${ value }\"`, \"value\", value);\n    }\n    return value;\n}\n\nconst regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\n\nfunction splitNesting(value: string): Array<any> {\n    value = value.trim();\n\n    let result = [];\n    let accum = \"\";\n    let depth = 0;\n    for (let offset = 0; offset < value.length; offset++) {\n        let c = value[offset];\n        if (c === \",\" && depth === 0) {\n            result.push(accum);\n            accum = \"\";\n        } else {\n            accum += c;\n            if (c === \"(\") {\n                depth++;\n            } else if (c === \")\") {\n                depth--;\n                if (depth === -1) {\n                    logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\n                }\n            }\n        }\n    }\n    if (accum) { result.push(accum); }\n\n    return result;\n}\n\n","\"use strict\";\n\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { Coder, Reader, Result, Writer } from \"./coders/abstract-coder\";\nimport { AddressCoder } from \"./coders/address\";\nimport { ArrayCoder } from \"./coders/array\";\nimport { BooleanCoder } from \"./coders/boolean\";\nimport { BytesCoder } from \"./coders/bytes\";\nimport { FixedBytesCoder } from \"./coders/fixed-bytes\";\nimport { NullCoder } from \"./coders/null\";\nimport { NumberCoder } from \"./coders/number\";\nimport { StringCoder } from \"./coders/string\";\nimport { TupleCoder } from \"./coders/tuple\";\n\nimport { ParamType } from \"./fragments\";\n\n\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n\n\nexport type CoerceFunc = (type: string, value: any) => any;\n\nexport class AbiCoder {\n    readonly coerceFunc: CoerceFunc;\n\n    constructor(coerceFunc?: CoerceFunc) {\n        logger.checkNew(new.target, AbiCoder);\n        defineReadOnly(this, \"coerceFunc\", coerceFunc || null);\n    }\n\n    _getCoder(param: ParamType): Coder {\n\n        switch (param.baseType) {\n            case \"address\":\n                return new AddressCoder(param.name);\n            case \"bool\":\n                return new BooleanCoder(param.name);\n            case \"string\":\n                return new StringCoder(param.name);\n            case \"bytes\":\n                return new BytesCoder(param.name);\n            case \"array\":\n                return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);\n            case \"tuple\":\n                return new TupleCoder((param.components || []).map((component) => {\n                    return this._getCoder(component);\n                }), param.name);\n            case \"\":\n                return new NullCoder(param.name);\n        }\n\n        // u?int[0-9]*\n        let match = param.type.match(paramTypeNumber);\n        if (match) {\n            let size = parseInt(match[2] || \"256\");\n            if (size === 0 || size > 256 || (size % 8) !== 0) {\n                logger.throwArgumentError(\"invalid \" + match[1] + \" bit length\", \"param\", param);\n            }\n            return new NumberCoder(size / 8, (match[1] === \"int\"), param.name);\n        }\n\n        // bytes[0-9]+\n        match = param.type.match(paramTypeBytes);\n        if (match) {\n            let size = parseInt(match[1]);\n            if (size === 0 || size > 32) {\n                logger.throwArgumentError(\"invalid bytes length\", \"param\", param);\n            }\n            return new FixedBytesCoder(size, param.name);\n        }\n\n        return logger.throwArgumentError(\"invalid type\", \"type\", param.type);\n    }\n\n    _getWordSize(): number { return 32; }\n\n    _getReader(data: Uint8Array, allowLoose?: boolean): Reader {\n        return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);\n    }\n\n    _getWriter(): Writer {\n        return new Writer(this._getWordSize());\n    }\n\n    getDefaultValue(types: ReadonlyArray<string | ParamType>): Result {\n        const coders: Array<Coder> = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.defaultValue();\n    }\n\n    encode(types: ReadonlyArray<string | ParamType>, values: ReadonlyArray<any>): string {\n        if (types.length !== values.length) {\n            logger.throwError(\"types/values length mismatch\", Logger.errors.INVALID_ARGUMENT, {\n                count: { types: types.length, values: values.length },\n                value: { types: types, values: values }\n            });\n        }\n\n        const coders = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = (new TupleCoder(coders, \"_\"));\n\n        const writer = this._getWriter();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n\n    decode(types: ReadonlyArray<string | ParamType>, data: BytesLike, loose?: boolean): Result {\n        const coders: Array<Coder> = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.decode(this._getReader(arrayify(data), loose));\n    }\n}\n\nexport const defaultAbiCoder: AbiCoder = new AbiCoder();\n\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, concat, hexDataSlice, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { id } from \"@ethersproject/hash\";\nimport { keccak256 } from \"@ethersproject/keccak256\"\nimport { defineReadOnly, Description, getStatic } from \"@ethersproject/properties\";\n\nimport { AbiCoder, defaultAbiCoder } from \"./abi-coder\";\nimport { checkResultErrors, Result } from \"./coders/abstract-coder\";\nimport { ConstructorFragment, ErrorFragment, EventFragment, FormatTypes, Fragment, FunctionFragment, JsonFragment, ParamType } from \"./fragments\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport { checkResultErrors, Result };\n\nexport class LogDescription extends Description<LogDescription> {\n    readonly eventFragment: EventFragment;\n    readonly name: string;\n    readonly signature: string;\n    readonly topic: string;\n    readonly args: Result\n}\n\nexport class TransactionDescription extends Description<TransactionDescription> {\n    readonly functionFragment: FunctionFragment;\n    readonly name: string;\n    readonly args: Result;\n    readonly signature: string;\n    readonly sighash: string;\n    readonly value: BigNumber;\n}\n\nexport class ErrorDescription extends Description<ErrorDescription> {\n    readonly errorFragment: ErrorFragment;\n    readonly name: string;\n    readonly args: Result;\n    readonly signature: string;\n    readonly sighash: string;\n}\n\nexport class Indexed extends Description<Indexed> {\n    readonly hash: string;\n    readonly _isIndexed: boolean;\n\n    static isIndexed(value: any): value is Indexed {\n        return !!(value && value._isIndexed);\n    }\n}\n\nconst BuiltinErrors: Record<string, { signature: string, inputs: Array<string>, name: string, reason?: boolean }> = {\n    \"0x08c379a0\": { signature: \"Error(string)\", name: \"Error\", inputs: [ \"string\" ], reason: true },\n    \"0x4e487b71\": { signature: \"Panic(uint256)\", name: \"Panic\", inputs: [ \"uint256\" ] }\n}\n\nfunction wrapAccessError(property: string, error: Error): Error {\n    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${ property }`);\n    (<any>wrap).error = error;\n    return wrap;\n}\n\n/*\nfunction checkNames(fragment: Fragment, type: \"input\" | \"output\", params: Array<ParamType>): void {\n    params.reduce((accum, param) => {\n        if (param.name) {\n            if (accum[param.name]) {\n                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format(\"full\") }`, \"fragment\", fragment);\n            }\n            accum[param.name] = true;\n        }\n        return accum;\n    }, <{ [ name: string ]: boolean }>{ });\n}\n*/\nexport class Interface {\n    readonly fragments: ReadonlyArray<Fragment>;\n\n    readonly errors: { [ name: string ]: ErrorFragment };\n    readonly events: { [ name: string ]: EventFragment };\n    readonly functions: { [ name: string ]: FunctionFragment };\n    readonly structs: { [ name: string ]: any };\n\n    readonly deploy: ConstructorFragment;\n\n    readonly _abiCoder: AbiCoder;\n\n    readonly _isInterface: boolean;\n\n    constructor(fragments: string | ReadonlyArray<Fragment | JsonFragment | string>) {\n        logger.checkNew(new.target, Interface);\n\n        let abi: ReadonlyArray<Fragment | JsonFragment | string> = [ ];\n        if (typeof(fragments) === \"string\") {\n            abi = JSON.parse(fragments);\n        } else {\n            abi = fragments;\n        }\n\n        defineReadOnly(this, \"fragments\", abi.map((fragment) => {\n            return Fragment.from(fragment);\n        }).filter((fragment) => (fragment != null)));\n\n        defineReadOnly(this, \"_abiCoder\", getStatic<() => AbiCoder>(new.target, \"getAbiCoder\")());\n\n        defineReadOnly(this, \"functions\", { });\n        defineReadOnly(this, \"errors\", { });\n        defineReadOnly(this, \"events\", { });\n        defineReadOnly(this, \"structs\", { });\n\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment) => {\n            let bucket: { [ name: string ]: Fragment } = null;\n            switch (fragment.type) {\n                case \"constructor\":\n                    if (this.deploy) {\n                        logger.warn(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    defineReadOnly(this, \"deploy\", <ConstructorFragment>fragment);\n                    return;\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = this.functions;\n                    break;\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.events;\n                    break;\n                case \"error\":\n                    bucket = this.errors;\n                    break;\n                default:\n                    return;\n            }\n\n            let signature = fragment.format();\n            if (bucket[signature]) {\n                logger.warn(\"duplicate definition - \" + signature);\n                return;\n            }\n\n            bucket[signature] = fragment;\n        });\n\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            defineReadOnly(this, \"deploy\", ConstructorFragment.from({\n                payable: false,\n                type: \"constructor\"\n            }));\n        }\n\n        defineReadOnly(this, \"_isInterface\", true);\n    }\n\n    format(format?: string): string | Array<string> {\n        if (!format) { format = FormatTypes.full; }\n        if (format === FormatTypes.sighash) {\n            logger.throwArgumentError(\"interface does not support formatting sighash\", \"format\", format);\n        }\n\n        const abi = this.fragments.map((fragment) => fragment.format(format));\n\n        // We need to re-bundle the JSON fragments a bit\n        if (format === FormatTypes.json) {\n             return JSON.stringify(abi.map((j) => JSON.parse(j)));\n        }\n\n        return abi;\n    }\n\n    // Sub-classes can override these to handle other blockchains\n    static getAbiCoder(): AbiCoder {\n        return defaultAbiCoder;\n    }\n\n    static getAddress(address: string): string {\n        return getAddress(address);\n    }\n\n    static getSighash(fragment: ErrorFragment | FunctionFragment): string {\n        return hexDataSlice(id(fragment.format()), 0, 4);\n    }\n\n    static getEventTopic(eventFragment: EventFragment): string {\n        return id(eventFragment.format());\n    }\n\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getFunction(nameOrSignatureOrSighash: string): FunctionFragment {\n        if (isHexString(nameOrSignatureOrSighash)) {\n            for (const name in this.functions) {\n                if (nameOrSignatureOrSighash === this.getSighash(name)) {\n                    return this.functions[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching function\", \"sighash\", nameOrSignatureOrSighash);\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.functions).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching function\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching functions\", \"name\", name);\n            }\n\n            return this.functions[matching[0]];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching function\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    getEvent(nameOrSignatureOrTopic: string): EventFragment {\n        if (isHexString(nameOrSignatureOrTopic)) {\n            const topichash = nameOrSignatureOrTopic.toLowerCase();\n            for (const name in this.events) {\n                if (topichash === this.getEventTopic(name)) {\n                    return this.events[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching event\", \"topichash\", topichash);\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrTopic.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrTopic.trim();\n            const matching = Object.keys(this.events).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching event\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching events\", \"name\", name);\n            }\n\n            return this.events[matching[0]];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching event\", \"signature\", nameOrSignatureOrTopic);\n        }\n        return result;\n    }\n\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getError(nameOrSignatureOrSighash: string): ErrorFragment {\n        if (isHexString(nameOrSignatureOrSighash)) {\n            const getSighash = getStatic<(f: ErrorFragment | FunctionFragment) => string>(this.constructor, \"getSighash\");\n            for (const name in this.errors) {\n                const error = this.errors[name];\n                if (nameOrSignatureOrSighash === getSighash(error)) {\n                    return this.errors[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching error\", \"sighash\", nameOrSignatureOrSighash);\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.errors).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching error\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching errors\", \"name\", name);\n            }\n\n            return this.errors[matching[0]];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching error\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n\n    // Get the sighash (the bytes4 selector) used by Solidity to identify a function\n    getSighash(fragment: ErrorFragment | FunctionFragment | string): string {\n        if (typeof(fragment) === \"string\") {\n            try {\n                fragment = this.getFunction(fragment);\n            } catch (error) {\n                try {\n                    fragment = this.getError(<string>fragment);\n                } catch (_) {\n                    throw error;\n                }\n            }\n        }\n\n        return getStatic<(f: ErrorFragment | FunctionFragment) => string>(this.constructor, \"getSighash\")(fragment);\n    }\n\n    // Get the topic (the bytes32 hash) used by Solidity to identify an event\n    getEventTopic(eventFragment: EventFragment | string): string {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        return getStatic<(e: EventFragment) => string>(this.constructor, \"getEventTopic\")(eventFragment);\n    }\n\n\n    _decodeParams(params: ReadonlyArray<ParamType>, data: BytesLike): Result {\n        return this._abiCoder.decode(params, data)\n    }\n\n    _encodeParams(params: ReadonlyArray<ParamType>, values: ReadonlyArray<any>): string {\n        return this._abiCoder.encode(params, values)\n    }\n\n    encodeDeploy(values?: ReadonlyArray<any>): string {\n        return this._encodeParams(this.deploy.inputs, values || [ ]);\n    }\n\n    decodeErrorResult(fragment: ErrorFragment | string, data: BytesLike): Result {\n        if (typeof(fragment) === \"string\") {\n            fragment = this.getError(fragment);\n        }\n\n        const bytes = arrayify(data);\n\n        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(fragment)) {\n            logger.throwArgumentError(`data signature does not match error ${ fragment.name }.`, \"data\", hexlify(bytes));\n        }\n\n        return this._decodeParams(fragment.inputs, bytes.slice(4));\n    }\n\n    encodeErrorResult(fragment: ErrorFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(fragment) === \"string\") {\n            fragment = this.getError(fragment);\n        }\n\n        return hexlify(concat([\n            this.getSighash(fragment),\n            this._encodeParams(fragment.inputs, values || [ ])\n        ]));\n    }\n\n    // Decode the data for a function call (e.g. tx.data)\n    decodeFunctionData(functionFragment: FunctionFragment | string, data: BytesLike): Result {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        const bytes = arrayify(data);\n\n        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {\n            logger.throwArgumentError(`data signature does not match function ${ functionFragment.name }.`, \"data\", hexlify(bytes));\n        }\n\n        return this._decodeParams(functionFragment.inputs, bytes.slice(4));\n    }\n\n    // Encode the data for a function call (e.g. tx.data)\n    encodeFunctionData(functionFragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        return hexlify(concat([\n            this.getSighash(functionFragment),\n            this._encodeParams(functionFragment.inputs, values || [ ])\n        ]));\n    }\n\n    // Decode the result from a function call (e.g. from eth_call)\n    decodeFunctionResult(functionFragment: FunctionFragment | string, data: BytesLike): Result {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        let bytes = arrayify(data);\n\n        let reason: string = null;\n        let errorArgs: Result = null;\n        let errorName: string = null;\n        let errorSignature: string = null;\n        switch (bytes.length % this._abiCoder._getWordSize()) {\n            case 0:\n                try {\n                    return this._abiCoder.decode(functionFragment.outputs, bytes);\n                } catch (error) { }\n                break;\n\n            case 4: {\n                const selector = hexlify(bytes.slice(0, 4));\n                const builtin = BuiltinErrors[selector];\n                if (builtin) {\n                    errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));\n                    errorName = builtin.name;\n                    errorSignature = builtin.signature;\n                    if (builtin.reason) { reason = errorArgs[0]; }\n                } else {\n                    try {\n                        const error = this.getError(selector);\n                        errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));\n                        errorName = error.name;\n                        errorSignature = error.format();\n                    } catch (error) {\n                        console.log(error);\n                    }\n                }\n                break;\n            }\n        }\n\n        return logger.throwError(\"call revert exception\", Logger.errors.CALL_EXCEPTION, {\n            method: functionFragment.format(),\n            errorArgs, errorName, errorSignature, reason\n        });\n    }\n\n    // Encode the result for a function call (e.g. for eth_call)\n    encodeFunctionResult(functionFragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        return hexlify(this._abiCoder.encode(functionFragment.outputs, values || [ ]));\n    }\n\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(eventFragment: EventFragment, values: ReadonlyArray<any>): Array<string | Array<string>> {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        if (values.length > eventFragment.inputs.length) {\n            logger.throwError(\"too many arguments for \" + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {\n                argument: \"values\",\n                value: values\n            })\n        }\n\n        let topics: Array<string | Array<string>> = [];\n        if (!eventFragment.anonymous) { topics.push(this.getEventTopic(eventFragment)); }\n\n        const encodeTopic = (param: ParamType, value: any): string => {\n            if (param.type === \"string\") {\n                 return id(value);\n            } else if (param.type === \"bytes\") {\n                 return keccak256(hexlify(value));\n            }\n\n            // Check addresses are valid\n            if (param.type === \"address\") { this._abiCoder.encode( [ \"address\" ], [ value ]); }\n            return hexZeroPad(hexlify(value), 32);\n        };\n\n        values.forEach((value, index) => {\n\n            let param = eventFragment.inputs[index];\n\n            if (!param.indexed) {\n                if (value != null) {\n                    logger.throwArgumentError(\"cannot filter non-indexed parameters; must be null\", (\"contract.\" + param.name), value);\n                }\n                return;\n            }\n\n            if (value == null) {\n                topics.push(null);\n            } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n            } else if (Array.isArray(value)) {\n                topics.push(value.map((value) => encodeTopic(param, value)));\n            } else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n\n        // Trim off trailing nulls\n        while (topics.length && topics[topics.length - 1] === null) {\n            topics.pop();\n        }\n\n        return topics;\n    }\n\n    encodeEventLog(eventFragment: EventFragment, values: ReadonlyArray<any>): { data: string, topics: Array<string> } {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        const topics: Array<string> = [ ];\n\n        const dataTypes: Array<ParamType> = [ ];\n        const dataValues: Array<string> = [ ];\n\n        if (!eventFragment.anonymous) {\n            topics.push(this.getEventTopic(eventFragment));\n        }\n\n        if (values.length !== eventFragment.inputs.length) {\n            logger.throwArgumentError(\"event arguments/values mismatch\", \"values\", values);\n        }\n\n        eventFragment.inputs.forEach((param, index) => {\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push(id(value))\n                } else if (param.type === \"bytes\") {\n                    topics.push(keccak256(value))\n                } else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                } else {\n                    topics.push(this._abiCoder.encode([ param.type] , [ value ]));\n                }\n            } else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n\n        return {\n            data: this._abiCoder.encode(dataTypes , dataValues),\n            topics: topics\n        };\n    }\n\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(eventFragment: EventFragment | string, data: BytesLike, topics?: ReadonlyArray<string>): Result {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        if (topics != null && !eventFragment.anonymous) {\n            let topicHash = this.getEventTopic(eventFragment);\n            if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {\n                logger.throwError(\"fragment/topic mismatch\", Logger.errors.INVALID_ARGUMENT, { argument: \"topics[0]\", expected: topicHash, value: topics[0] });\n            }\n            topics = topics.slice(1);\n        }\n\n        let indexed: Array<ParamType> = [];\n        let nonIndexed: Array<ParamType> = [];\n        let dynamic: Array<boolean> = [];\n\n        eventFragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(ParamType.fromObject({ type: \"bytes32\", name: param.name }));\n                    dynamic.push(true);\n                } else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            } else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n\n        let resultIndexed = (topics != null) ? this._abiCoder.decode(indexed, concat(topics)): null;\n        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);\n\n        let result: (Array<any> & { [ key: string ]: any }) = [ ];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        eventFragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: null });\n\n                } else if (dynamic[index]) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });\n\n                } else {\n                    try {\n                        result[index] = resultIndexed[indexedIndex++];\n                    } catch (error) {\n                        result[index] = error;\n                    }\n                }\n            } else {\n                try {\n                    result[index] = resultNonIndexed[nonIndexedIndex++];\n                } catch (error) {\n                    result[index] = error;\n                }\n            }\n\n            // Add the keyword argument if named and safe\n            if (param.name && result[param.name] == null) {\n                const value = result[index];\n\n                // Make error named values throw on access\n                if (value instanceof Error) {\n                    Object.defineProperty(result, param.name, {\n                        enumerable: true,\n                        get: () => { throw wrapAccessError(`property ${ JSON.stringify(param.name) }`, value); }\n                    });\n                } else {\n                    result[param.name] = value;\n                }\n            }\n        });\n\n        // Make all error indexed values throw on access\n        for (let i = 0; i < result.length; i++) {\n            const value = result[i];\n            if (value instanceof Error) {\n                Object.defineProperty(result, i, {\n                    enumerable: true,\n                    get: () => { throw wrapAccessError(`index ${ i }`, value); }\n                });\n            }\n        }\n\n        return Object.freeze(result);\n    }\n\n    // Given a transaction, find the matching function fragment (if any) and\n    // determine all its properties and call parameters\n    parseTransaction(tx: { data: string, value?: BigNumberish }): TransactionDescription {\n        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase())\n\n        if (!fragment) { return null; }\n\n        return new TransactionDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + tx.data.substring(10)),\n            functionFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n            value: BigNumber.from(tx.value || \"0\"),\n        });\n    }\n\n    // @TODO\n    //parseCallResult(data: BytesLike): ??\n\n    // Given an event log, find the matching event fragment (if any) and\n    // determine all its properties and values\n    parseLog(log: { topics: Array<string>, data: string}): LogDescription {\n        let fragment = this.getEvent(log.topics[0]);\n\n        if (!fragment || fragment.anonymous) { return null; }\n\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n\n\n       return new LogDescription({\n            eventFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            topic: this.getEventTopic(fragment),\n            args: this.decodeEventLog(fragment, log.data, log.topics)\n        });\n    }\n\n    parseError(data: BytesLike): ErrorDescription {\n        const hexData = hexlify(data);\n        let fragment = this.getError(hexData.substring(0, 10).toLowerCase())\n\n        if (!fragment) { return null; }\n\n        return new ErrorDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + hexData.substring(10)),\n            errorFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n        });\n    }\n\n\n    /*\n    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {\n        if (Interface.isInterface(value)) {\n            return value;\n        }\n        if (typeof(value) === \"string\") {\n            return new Interface(JSON.parse(value));\n        }\n        return new Interface(value);\n    }\n    */\n\n    static isInterface(value: any): value is Interface {\n        return !!(value && value._isInterface);\n    }\n}\n\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.6.0\";\n","export const version = \"bytes/5.6.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0x0\" + hex.substring(2);\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bignumber/5.5.0\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        logger.checkNew(new.target, BigNumber);\n\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division by zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"cannot modulo negative values\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"cannot raise to negative values\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"cannot 'and' negative values\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"cannot 'or' negative values\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"cannot 'xor' negative values\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"cannot mask negative values\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"cannot shift negative values\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"cannot shift negative values\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.6.0\";\n","export const version = \"networks/5.6.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { Network, Networkish } from \"./types\";\n\nexport {\n    Network,\n    Networkish\n};\n\ntype DefaultProviderFunc = (providers: any, options?: any) => any;\n\ninterface Renetworkable extends DefaultProviderFunc {\n    renetwork: (network: Network) => DefaultProviderFunc;\n};\n\nfunction isRenetworkable(value: any): value is Renetworkable {\n    return (value && typeof(value.renetwork) === \"function\");\n}\n\nfunction ethDefaultProvider(network: string | Network): Renetworkable {\n    const func = function(providers: any, options?: any): any {\n        if (options == null) { options = { }; }\n        const providerList: Array<any> = [];\n\n        if (providers.InfuraProvider && options.infura !== \"-\") {\n            try {\n                providerList.push(new providers.InfuraProvider(network, options.infura));\n            } catch(error) { }\n        }\n\n        if (providers.EtherscanProvider && options.etherscan !== \"-\") {\n            try {\n                providerList.push(new providers.EtherscanProvider(network, options.etherscan));\n            } catch(error) { }\n        }\n\n        if (providers.AlchemyProvider && options.alchemy !== \"-\") {\n            try {\n                providerList.push(new providers.AlchemyProvider(network, options.alchemy));\n            } catch(error) { }\n        }\n\n        if (providers.PocketProvider && options.pocket !== \"-\") {\n            // These networks are currently faulty on Pocket as their\n            // network does not handle the Berlin hardfork, which is\n            // live on these ones.\n            // @TODO: This goes away once Pocket has upgraded their nodes\n            const skip = [ \"goerli\", \"ropsten\", \"rinkeby\" ];\n            try {\n                const provider = new providers.PocketProvider(network);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            } catch(error) { }\n        }\n\n        if (providers.CloudflareProvider && options.cloudflare !== \"-\") {\n            try {\n                providerList.push(new providers.CloudflareProvider(network));\n            } catch(error) { }\n        }\n\n        if (providerList.length === 0) { return null; }\n\n        if (providers.FallbackProvider) {\n            let quorum = 1;\n            if (options.quorum != null) {\n                quorum = options.quorum;\n            } else if (network === \"homestead\") {\n                quorum = 2;\n            }\n            return new providers.FallbackProvider(providerList, quorum);\n        }\n\n        return providerList[0];\n    };\n\n    func.renetwork = function(network: Network) {\n        return ethDefaultProvider(network);\n    };\n\n    return func;\n}\n\nfunction etcDefaultProvider(url: string, network: string | Network): Renetworkable {\n    const func = function(providers: any, options?: any): any {\n        if (providers.JsonRpcProvider) {\n            return new providers.JsonRpcProvider(url, network);\n        }\n\n        return null;\n    };\n\n    func.renetwork = function(network: Network) {\n        return etcDefaultProvider(url, network);\n    };\n\n    return func;\n}\n\nconst homestead: Network = {\n    chainId: 1,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"homestead\",\n    _defaultProvider: ethDefaultProvider(\"homestead\")\n};\n\nconst ropsten: Network = {\n    chainId: 3,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"ropsten\",\n    _defaultProvider: ethDefaultProvider(\"ropsten\")\n};\n\nconst classicMordor: Network = {\n    chainId: 63,\n    name: \"classicMordor\",\n    _defaultProvider: etcDefaultProvider(\"https://www.ethercluster.com/mordor\", \"classicMordor\")\n};\n\n// See: https://chainlist.org\nconst networks: { [name: string]: Network } = {\n    unspecified: { chainId: 0, name: \"unspecified\" },\n\n    homestead: homestead,\n    mainnet: homestead,\n\n    morden: { chainId: 2, name: \"morden\" },\n\n    ropsten: ropsten,\n    testnet: ropsten,\n\n    rinkeby: {\n        chainId: 4,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"rinkeby\",\n        _defaultProvider: ethDefaultProvider(\"rinkeby\")\n    },\n\n    kovan: {\n        chainId: 42,\n        name: \"kovan\",\n        _defaultProvider: ethDefaultProvider(\"kovan\")\n    },\n\n    goerli: {\n        chainId: 5,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"goerli\",\n        _defaultProvider: ethDefaultProvider(\"goerli\")\n    },\n\n    kintsugi: { chainId: 1337702, name: \"kintsugi\" },\n\n\n    // ETC (See: #351)\n    classic: {\n        chainId: 61,\n        name: \"classic\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/etc\", \"classic\")\n    },\n\n    classicMorden: { chainId: 62, name: \"classicMorden\" },\n\n    classicMordor: classicMordor,\n    classicTestnet: classicMordor,\n\n    classicKotti: {\n        chainId: 6,\n        name: \"classicKotti\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/kotti\", \"classicKotti\")\n    },\n\n    xdai: { chainId: 100, name: \"xdai\" },\n\n    matic: { chainId: 137, name: \"matic\" },\n    maticmum: { chainId: 80001, name: \"maticmum\" },\n\n    optimism: { chainId: 10, name: \"optimism\" },\n    \"optimism-kovan\": { chainId: 69, name: \"optimism-kovan\" },\n    \"optimism-goerli\": { chainId: 420, name: \"optimism-goerli\" },\n\n    arbitrum: { chainId: 42161, name: \"arbitrum\" },\n    \"arbitrum-rinkeby\": { chainId: 421611, name: \"arbitrum-rinkeby\" },\n\n    bnb: { chainId: 56, name: \"bnb\" },\n    bnbt: { chainId: 97, name: \"bnbt\" },\n}\n\n/**\n *  getNetwork\n *\n *  Converts a named common networks or chain ID (network ID) to a Network\n *  and verifies a network is a valid Network..\n */\nexport function getNetwork(network: Networkish): Network {\n    // No network (null)\n    if (network == null) { return null; }\n\n    if (typeof(network) === \"number\") {\n        for (const name in networks) {\n            const standard = networks[name];\n            if (standard.chainId === network) {\n                return {\n                    name: standard.name,\n                    chainId: standard.chainId,\n                    ensAddress: (standard.ensAddress || null),\n                    _defaultProvider: (standard._defaultProvider || null)\n                };\n            }\n        }\n\n        return {\n            chainId: network,\n            name: \"unknown\"\n        };\n    }\n\n    if (typeof(network) === \"string\") {\n        const standard = networks[network];\n        if (standard == null) { return null; }\n        return {\n            name: standard.name,\n            chainId: standard.chainId,\n            ensAddress: standard.ensAddress,\n            _defaultProvider: (standard._defaultProvider || null)\n        };\n    }\n\n    const standard  = networks[network.name];\n\n    // Not a standard network; check that it is a valid network in general\n    if (!standard) {\n        if (typeof(network.chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid network chainId\", \"network\", network);\n        }\n        return network;\n    }\n\n    // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)\n    if (network.chainId !== 0 && network.chainId !== standard.chainId) {\n        logger.throwArgumentError(\"network chainId mismatch\", \"network\", network);\n    }\n\n    // @TODO: In the next major version add an attach function to a defaultProvider\n    // class and move the _defaultProvider internal to this file (extend Network)\n    let defaultProvider: DefaultProviderFunc = network._defaultProvider || null;\n    if (defaultProvider == null && standard._defaultProvider) {\n        if (isRenetworkable(standard._defaultProvider)) {\n            defaultProvider = standard._defaultProvider.renetwork(network);\n        } else {\n            defaultProvider = standard._defaultProvider;\n        }\n    }\n\n    // Standard Network (allow overriding the ENS address)\n    return {\n        name: network.name,\n        chainId: standard.chainId,\n        ensAddress: (network.ensAddress || standard.ensAddress || null),\n        _defaultProvider: defaultProvider\n    };\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n","export const version = \"properties/5.6.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0x0\" + hex.substring(2);\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.6.0\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        logger.checkNew(new.target, BigNumber);\n\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","export const version = \"bignumber/5.6.0\";\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","export const version = \"rlp/5.6.0\";\n","\"use strict\";\n\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\nimport { arrayify, BytesLike, hexlify, isBytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction arrayifyInteger(value: number): Array<number> {\n    const result = [];\n    while (value) {\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\n\nfunction unarrayifyInteger(data: Uint8Array, offset: number, length: number): number {\n    let result = 0;\n    for (let i = 0; i < length; i++) {\n        result = (result * 256) + data[offset + i];\n    }\n    return result;\n}\n\nfunction _encode(object: Array<any> | string): Array<number> {\n    if (Array.isArray(object)) {\n        let payload: Array<number> = [];\n        object.forEach(function(child) {\n            payload = payload.concat(_encode(child));\n        });\n\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length)\n            return payload;\n        }\n\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n\n        return length.concat(payload);\n\n    }\n\n    if (!isBytesLike(object)) {\n        logger.throwArgumentError(\"RLP object must be BytesLike\", \"object\", object);\n    }\n\n    const data: Array<number> = Array.prototype.slice.call(arrayify(object));\n\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n\n    } else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n\n    return length.concat(data);\n}\n\nexport function encode(object: any): string {\n    return hexlify(_encode(object));\n}\n\ntype Decoded = {\n    result: any;\n    consumed: number;\n};\n\nfunction _decodeChildren(data: Uint8Array, offset: number, childOffset: number, length: number): Decoded {\n    const result = [];\n\n    while (childOffset < offset + 1 + length) {\n        const decoded = _decode(data, childOffset);\n\n        result.push(decoded.result);\n\n        childOffset += decoded.consumed;\n        if (childOffset > offset + 1 + length) {\n            logger.throwError(\"child data too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n    }\n\n    return {consumed: (1 + length), result: result};\n}\n\n// returns { consumed: number, result: Object }\nfunction _decode(data: Uint8Array, offset: number): { consumed: number, result: any } {\n    if (data.length === 0) {\n        logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, { });\n    }\n\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data short segment too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data long segment too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n\n    } else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        return _decodeChildren(data, offset, offset + 1, length);\n\n    } else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return { consumed: (1 + lengthLength + length), result: result }\n\n    } else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const result = hexlify(data.slice(offset + 1, offset + 1 + length));\n        return { consumed: (1 + length), result: result }\n    }\n    return { consumed: 1, result: hexlify(data[offset]) };\n}\n\nexport function decode(data: BytesLike): any {\n    const bytes = arrayify(data);\n    const decoded = _decode(bytes, 0);\n    if (decoded.consumed !== bytes.length) {\n        logger.throwArgumentError(\"invalid rlp data\", \"data\", data);\n    }\n    return decoded.result;\n}\n\n","export const version = \"address/5.6.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexDataLength, hexDataSlice, isHexString, stripZeros } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish, _base16To36, _base36To16 } from \"@ethersproject/bignumber\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { encode } from \"@ethersproject/rlp\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction getChecksumAddress(address: string): string {\n    if (!isHexString(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    address = address.toLowerCase();\n\n    const chars = address.substring(2).split(\"\");\n\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n\n    const hashed = arrayify(keccak256(expanded));\n\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n\n    return \"0x\" + chars.join(\"\");\n}\n\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER: number = 0x1fffffffffffff;\n\nfunction log10(x: number): number {\n    if (Math.log10) { return Math.log10(x); }\n    return Math.log(x) / Math.LN10;\n}\n\n\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\n// Create lookup table\nconst ibanLookup: { [character: string]: string } = { };\nfor (let i = 0; i < 10; i++) { ibanLookup[String(i)] = String(i); }\nfor (let i = 0; i < 26; i++) { ibanLookup[String.fromCharCode(65 + i)] = String(10 + i); }\n\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\nfunction ibanChecksum(address: string): string {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) { checksum = \"0\" + checksum; }\n\n    return checksum;\n};\n\nexport function getAddress(address: string): string {\n    let result = null;\n\n    if (typeof(address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") { address = \"0x\" + address; }\n\n        result = getChecksumAddress(address);\n\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n\n    // Maybe ICAP? (we only support direct mode)\n    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n\n        result = _base36To16(address.substring(4));\n        while (result.length < 40) { result = \"0\" + result; }\n        result = getChecksumAddress(\"0x\" + result);\n\n    } else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    return result;\n}\n\nexport function isAddress(address: string): boolean {\n    try {\n        getAddress(address);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getIcapAddress(address: string): string {\n    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nexport function getContractAddress(transaction: { from: string, nonce: BigNumberish }) {\n    let from: string = null;\n    try {\n        from = getAddress(transaction.from);\n    } catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n\n    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));\n\n    return getAddress(hexDataSlice(keccak256(encode([ from, nonce ])), 12));\n}\n\nexport function getCreate2Address(from: string, salt: BytesLike, initCodeHash: BytesLike): string {\n    if (hexDataLength(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if (hexDataLength(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress(hexDataSlice(keccak256(concat([ \"0xff\", getAddress(from), salt, initCodeHash ])), 12))\n}\n","export const AddressZero = \"0x0000000000000000000000000000000000000000\";\n\n","import { BigNumber } from \"@ethersproject/bignumber\";\n\nconst NegativeOne: BigNumber = (/*#__PURE__*/BigNumber.from(-1));\nconst Zero: BigNumber = (/*#__PURE__*/BigNumber.from(0));\nconst One: BigNumber = (/*#__PURE__*/BigNumber.from(1));\nconst Two: BigNumber = (/*#__PURE__*/BigNumber.from(2));\nconst WeiPerEther: BigNumber = (/*#__PURE__*/BigNumber.from(\"1000000000000000000\"));\nconst MaxUint256: BigNumber = (/*#__PURE__*/BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n\nconst MinInt256: BigNumber = (/*#__PURE__*/BigNumber.from(\"-0x8000000000000000000000000000000000000000000000000000000000000000\"));\nconst MaxInt256: BigNumber = (/*#__PURE__*/BigNumber.from(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n\nexport {\n    NegativeOne,\n    Zero,\n    One,\n    Two,\n    WeiPerEther,\n    MaxUint256,\n    MinInt256,\n    MaxInt256,\n};\n","module.exports = assert;\n\nfunction assert(val, msg) {\n  if (!val)\n    throw new Error(msg || 'Assertion failed');\n}\n\nassert.equal = function assertEqual(l, r, msg) {\n  if (l != r)\n    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\n};\n","'use strict';\n\nvar utils = exports;\n\nfunction toArray(msg, enc) {\n  if (Array.isArray(msg))\n    return msg.slice();\n  if (!msg)\n    return [];\n  var res = [];\n  if (typeof msg !== 'string') {\n    for (var i = 0; i < msg.length; i++)\n      res[i] = msg[i] | 0;\n    return res;\n  }\n  if (enc === 'hex') {\n    msg = msg.replace(/[^a-z0-9]+/ig, '');\n    if (msg.length % 2 !== 0)\n      msg = '0' + msg;\n    for (var i = 0; i < msg.length; i += 2)\n      res.push(parseInt(msg[i] + msg[i + 1], 16));\n  } else {\n    for (var i = 0; i < msg.length; i++) {\n      var c = msg.charCodeAt(i);\n      var hi = c >> 8;\n      var lo = c & 0xff;\n      if (hi)\n        res.push(hi, lo);\n      else\n        res.push(lo);\n    }\n  }\n  return res;\n}\nutils.toArray = toArray;\n\nfunction zero2(word) {\n  if (word.length === 1)\n    return '0' + word;\n  else\n    return word;\n}\nutils.zero2 = zero2;\n\nfunction toHex(msg) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++)\n    res += zero2(msg[i].toString(16));\n  return res;\n}\nutils.toHex = toHex;\n\nutils.encode = function encode(arr, enc) {\n  if (enc === 'hex')\n    return toHex(arr);\n  else\n    return arr;\n};\n","'use strict';\n\nvar utils = exports;\nvar BN = require('bn.js');\nvar minAssert = require('minimalistic-assert');\nvar minUtils = require('minimalistic-crypto-utils');\n\nutils.assert = minAssert;\nutils.toArray = minUtils.toArray;\nutils.zero2 = minUtils.zero2;\nutils.toHex = minUtils.toHex;\nutils.encode = minUtils.encode;\n\n// Represent num in a w-NAF form\nfunction getNAF(num, w, bits) {\n  var naf = new Array(Math.max(num.bitLength(), bits) + 1);\n  naf.fill(0);\n\n  var ws = 1 << (w + 1);\n  var k = num.clone();\n\n  for (var i = 0; i < naf.length; i++) {\n    var z;\n    var mod = k.andln(ws - 1);\n    if (k.isOdd()) {\n      if (mod > (ws >> 1) - 1)\n        z = (ws >> 1) - mod;\n      else\n        z = mod;\n      k.isubn(z);\n    } else {\n      z = 0;\n    }\n\n    naf[i] = z;\n    k.iushrn(1);\n  }\n\n  return naf;\n}\nutils.getNAF = getNAF;\n\n// Represent k1, k2 in a Joint Sparse Form\nfunction getJSF(k1, k2) {\n  var jsf = [\n    [],\n    [],\n  ];\n\n  k1 = k1.clone();\n  k2 = k2.clone();\n  var d1 = 0;\n  var d2 = 0;\n  var m8;\n  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n    // First phase\n    var m14 = (k1.andln(3) + d1) & 3;\n    var m24 = (k2.andln(3) + d2) & 3;\n    if (m14 === 3)\n      m14 = -1;\n    if (m24 === 3)\n      m24 = -1;\n    var u1;\n    if ((m14 & 1) === 0) {\n      u1 = 0;\n    } else {\n      m8 = (k1.andln(7) + d1) & 7;\n      if ((m8 === 3 || m8 === 5) && m24 === 2)\n        u1 = -m14;\n      else\n        u1 = m14;\n    }\n    jsf[0].push(u1);\n\n    var u2;\n    if ((m24 & 1) === 0) {\n      u2 = 0;\n    } else {\n      m8 = (k2.andln(7) + d2) & 7;\n      if ((m8 === 3 || m8 === 5) && m14 === 2)\n        u2 = -m24;\n      else\n        u2 = m24;\n    }\n    jsf[1].push(u2);\n\n    // Second phase\n    if (2 * d1 === u1 + 1)\n      d1 = 1 - d1;\n    if (2 * d2 === u2 + 1)\n      d2 = 1 - d2;\n    k1.iushrn(1);\n    k2.iushrn(1);\n  }\n\n  return jsf;\n}\nutils.getJSF = getJSF;\n\nfunction cachedProperty(obj, name, computer) {\n  var key = '_' + name;\n  obj.prototype[name] = function cachedProperty() {\n    return this[key] !== undefined ? this[key] :\n      this[key] = computer.call(this);\n  };\n}\nutils.cachedProperty = cachedProperty;\n\nfunction parseBytes(bytes) {\n  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :\n    bytes;\n}\nutils.parseBytes = parseBytes;\n\nfunction intFromLE(bytes) {\n  return new BN(bytes, 'hex', 'le');\n}\nutils.intFromLE = intFromLE;\n\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar getNAF = utils.getNAF;\nvar getJSF = utils.getJSF;\nvar assert = utils.assert;\n\nfunction BaseCurve(type, conf) {\n  this.type = type;\n  this.p = new BN(conf.p, 16);\n\n  // Use Montgomery, when there is no fast reduction for the prime\n  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);\n\n  // Useful for many curves\n  this.zero = new BN(0).toRed(this.red);\n  this.one = new BN(1).toRed(this.red);\n  this.two = new BN(2).toRed(this.red);\n\n  // Curve configuration, optional\n  this.n = conf.n && new BN(conf.n, 16);\n  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\n\n  // Temporary arrays\n  this._wnafT1 = new Array(4);\n  this._wnafT2 = new Array(4);\n  this._wnafT3 = new Array(4);\n  this._wnafT4 = new Array(4);\n\n  this._bitLength = this.n ? this.n.bitLength() : 0;\n\n  // Generalized Greg Maxwell's trick\n  var adjustCount = this.n && this.p.div(this.n);\n  if (!adjustCount || adjustCount.cmpn(100) > 0) {\n    this.redN = null;\n  } else {\n    this._maxwellTrick = true;\n    this.redN = this.n.toRed(this.red);\n  }\n}\nmodule.exports = BaseCurve;\n\nBaseCurve.prototype.point = function point() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype.validate = function validate() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\n  assert(p.precomputed);\n  var doubles = p._getDoubles();\n\n  var naf = getNAF(k, 1, this._bitLength);\n  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\n  I /= 3;\n\n  // Translate into more windowed form\n  var repr = [];\n  var j;\n  var nafW;\n  for (j = 0; j < naf.length; j += doubles.step) {\n    nafW = 0;\n    for (var l = j + doubles.step - 1; l >= j; l--)\n      nafW = (nafW << 1) + naf[l];\n    repr.push(nafW);\n  }\n\n  var a = this.jpoint(null, null, null);\n  var b = this.jpoint(null, null, null);\n  for (var i = I; i > 0; i--) {\n    for (j = 0; j < repr.length; j++) {\n      nafW = repr[j];\n      if (nafW === i)\n        b = b.mixedAdd(doubles.points[j]);\n      else if (nafW === -i)\n        b = b.mixedAdd(doubles.points[j].neg());\n    }\n    a = a.add(b);\n  }\n  return a.toP();\n};\n\nBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\n  var w = 4;\n\n  // Precompute window\n  var nafPoints = p._getNAFPoints(w);\n  w = nafPoints.wnd;\n  var wnd = nafPoints.points;\n\n  // Get NAF form\n  var naf = getNAF(k, w, this._bitLength);\n\n  // Add `this`*(N+1) for every w-NAF index\n  var acc = this.jpoint(null, null, null);\n  for (var i = naf.length - 1; i >= 0; i--) {\n    // Count zeroes\n    for (var l = 0; i >= 0 && naf[i] === 0; i--)\n      l++;\n    if (i >= 0)\n      l++;\n    acc = acc.dblp(l);\n\n    if (i < 0)\n      break;\n    var z = naf[i];\n    assert(z !== 0);\n    if (p.type === 'affine') {\n      // J +- P\n      if (z > 0)\n        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());\n    } else {\n      // J +- J\n      if (z > 0)\n        acc = acc.add(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.add(wnd[(-z - 1) >> 1].neg());\n    }\n  }\n  return p.type === 'affine' ? acc.toP() : acc;\n};\n\nBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,\n  points,\n  coeffs,\n  len,\n  jacobianResult) {\n  var wndWidth = this._wnafT1;\n  var wnd = this._wnafT2;\n  var naf = this._wnafT3;\n\n  // Fill all arrays\n  var max = 0;\n  var i;\n  var j;\n  var p;\n  for (i = 0; i < len; i++) {\n    p = points[i];\n    var nafPoints = p._getNAFPoints(defW);\n    wndWidth[i] = nafPoints.wnd;\n    wnd[i] = nafPoints.points;\n  }\n\n  // Comb small window NAFs\n  for (i = len - 1; i >= 1; i -= 2) {\n    var a = i - 1;\n    var b = i;\n    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);\n      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);\n      max = Math.max(naf[a].length, max);\n      max = Math.max(naf[b].length, max);\n      continue;\n    }\n\n    var comb = [\n      points[a], /* 1 */\n      null, /* 3 */\n      null, /* 5 */\n      points[b], /* 7 */\n    ];\n\n    // Try to avoid Projective points, if possible\n    if (points[a].y.cmp(points[b].y) === 0) {\n      comb[1] = points[a].add(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].add(points[b].neg());\n    } else {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    }\n\n    var index = [\n      -3, /* -1 -1 */\n      -1, /* -1 0 */\n      -5, /* -1 1 */\n      -7, /* 0 -1 */\n      0, /* 0 0 */\n      7, /* 0 1 */\n      5, /* 1 -1 */\n      1, /* 1 0 */\n      3,  /* 1 1 */\n    ];\n\n    var jsf = getJSF(coeffs[a], coeffs[b]);\n    max = Math.max(jsf[0].length, max);\n    naf[a] = new Array(max);\n    naf[b] = new Array(max);\n    for (j = 0; j < max; j++) {\n      var ja = jsf[0][j] | 0;\n      var jb = jsf[1][j] | 0;\n\n      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n      naf[b][j] = 0;\n      wnd[a] = comb;\n    }\n  }\n\n  var acc = this.jpoint(null, null, null);\n  var tmp = this._wnafT4;\n  for (i = max; i >= 0; i--) {\n    var k = 0;\n\n    while (i >= 0) {\n      var zero = true;\n      for (j = 0; j < len; j++) {\n        tmp[j] = naf[j][i] | 0;\n        if (tmp[j] !== 0)\n          zero = false;\n      }\n      if (!zero)\n        break;\n      k++;\n      i--;\n    }\n    if (i >= 0)\n      k++;\n    acc = acc.dblp(k);\n    if (i < 0)\n      break;\n\n    for (j = 0; j < len; j++) {\n      var z = tmp[j];\n      p;\n      if (z === 0)\n        continue;\n      else if (z > 0)\n        p = wnd[j][(z - 1) >> 1];\n      else if (z < 0)\n        p = wnd[j][(-z - 1) >> 1].neg();\n\n      if (p.type === 'affine')\n        acc = acc.mixedAdd(p);\n      else\n        acc = acc.add(p);\n    }\n  }\n  // Zeroify references\n  for (i = 0; i < len; i++)\n    wnd[i] = null;\n\n  if (jacobianResult)\n    return acc;\n  else\n    return acc.toP();\n};\n\nfunction BasePoint(curve, type) {\n  this.curve = curve;\n  this.type = type;\n  this.precomputed = null;\n}\nBaseCurve.BasePoint = BasePoint;\n\nBasePoint.prototype.eq = function eq(/*other*/) {\n  throw new Error('Not implemented');\n};\n\nBasePoint.prototype.validate = function validate() {\n  return this.curve.validate(this);\n};\n\nBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n  bytes = utils.toArray(bytes, enc);\n\n  var len = this.p.byteLength();\n\n  // uncompressed, hybrid-odd, hybrid-even\n  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\n      bytes.length - 1 === 2 * len) {\n    if (bytes[0] === 0x06)\n      assert(bytes[bytes.length - 1] % 2 === 0);\n    else if (bytes[0] === 0x07)\n      assert(bytes[bytes.length - 1] % 2 === 1);\n\n    var res =  this.point(bytes.slice(1, 1 + len),\n      bytes.slice(1 + len, 1 + 2 * len));\n\n    return res;\n  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\n              bytes.length - 1 === len) {\n    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n  }\n  throw new Error('Unknown point format');\n};\n\nBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\n  return this.encode(enc, true);\n};\n\nBasePoint.prototype._encode = function _encode(compact) {\n  var len = this.curve.p.byteLength();\n  var x = this.getX().toArray('be', len);\n\n  if (compact)\n    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);\n\n  return [ 0x04 ].concat(x, this.getY().toArray('be', len));\n};\n\nBasePoint.prototype.encode = function encode(enc, compact) {\n  return utils.encode(this._encode(compact), enc);\n};\n\nBasePoint.prototype.precompute = function precompute(power) {\n  if (this.precomputed)\n    return this;\n\n  var precomputed = {\n    doubles: null,\n    naf: null,\n    beta: null,\n  };\n  precomputed.naf = this._getNAFPoints(8);\n  precomputed.doubles = this._getDoubles(4, power);\n  precomputed.beta = this._getBeta();\n  this.precomputed = precomputed;\n\n  return this;\n};\n\nBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\n  if (!this.precomputed)\n    return false;\n\n  var doubles = this.precomputed.doubles;\n  if (!doubles)\n    return false;\n\n  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\n};\n\nBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\n  if (this.precomputed && this.precomputed.doubles)\n    return this.precomputed.doubles;\n\n  var doubles = [ this ];\n  var acc = this;\n  for (var i = 0; i < power; i += step) {\n    for (var j = 0; j < step; j++)\n      acc = acc.dbl();\n    doubles.push(acc);\n  }\n  return {\n    step: step,\n    points: doubles,\n  };\n};\n\nBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\n  if (this.precomputed && this.precomputed.naf)\n    return this.precomputed.naf;\n\n  var res = [ this ];\n  var max = (1 << wnd) - 1;\n  var dbl = max === 1 ? null : this.dbl();\n  for (var i = 1; i < max; i++)\n    res[i] = res[i - 1].add(dbl);\n  return {\n    wnd: wnd,\n    points: res,\n  };\n};\n\nBasePoint.prototype._getBeta = function _getBeta() {\n  return null;\n};\n\nBasePoint.prototype.dblp = function dblp(k) {\n  var r = this;\n  for (var i = 0; i < k; i++)\n    r = r.dbl();\n  return r;\n};\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict';\n\nvar utils = require('../utils');\nvar BN = require('bn.js');\nvar inherits = require('inherits');\nvar Base = require('./base');\n\nvar assert = utils.assert;\n\nfunction ShortCurve(conf) {\n  Base.call(this, 'short', conf);\n\n  this.a = new BN(conf.a, 16).toRed(this.red);\n  this.b = new BN(conf.b, 16).toRed(this.red);\n  this.tinv = this.two.redInvm();\n\n  this.zeroA = this.a.fromRed().cmpn(0) === 0;\n  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n\n  // If the curve is endomorphic, precalculate beta and lambda\n  this.endo = this._getEndomorphism(conf);\n  this._endoWnafT1 = new Array(4);\n  this._endoWnafT2 = new Array(4);\n}\ninherits(ShortCurve, Base);\nmodule.exports = ShortCurve;\n\nShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {\n  // No efficient endomorphism\n  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)\n    return;\n\n  // Compute beta and lambda, that lambda * P = (beta * Px; Py)\n  var beta;\n  var lambda;\n  if (conf.beta) {\n    beta = new BN(conf.beta, 16).toRed(this.red);\n  } else {\n    var betas = this._getEndoRoots(this.p);\n    // Choose the smallest beta\n    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n    beta = beta.toRed(this.red);\n  }\n  if (conf.lambda) {\n    lambda = new BN(conf.lambda, 16);\n  } else {\n    // Choose the lambda that is matching selected beta\n    var lambdas = this._getEndoRoots(this.n);\n    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {\n      lambda = lambdas[0];\n    } else {\n      lambda = lambdas[1];\n      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);\n    }\n  }\n\n  // Get basis vectors, used for balanced length-two representation\n  var basis;\n  if (conf.basis) {\n    basis = conf.basis.map(function(vec) {\n      return {\n        a: new BN(vec.a, 16),\n        b: new BN(vec.b, 16),\n      };\n    });\n  } else {\n    basis = this._getEndoBasis(lambda);\n  }\n\n  return {\n    beta: beta,\n    lambda: lambda,\n    basis: basis,\n  };\n};\n\nShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {\n  // Find roots of for x^2 + x + 1 in F\n  // Root = (-1 +- Sqrt(-3)) / 2\n  //\n  var red = num === this.p ? this.red : BN.mont(num);\n  var tinv = new BN(2).toRed(red).redInvm();\n  var ntinv = tinv.redNeg();\n\n  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);\n\n  var l1 = ntinv.redAdd(s).fromRed();\n  var l2 = ntinv.redSub(s).fromRed();\n  return [ l1, l2 ];\n};\n\nShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {\n  // aprxSqrt >= sqrt(this.n)\n  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n\n  // 3.74\n  // Run EGCD, until r(L + 1) < aprxSqrt\n  var u = lambda;\n  var v = this.n.clone();\n  var x1 = new BN(1);\n  var y1 = new BN(0);\n  var x2 = new BN(0);\n  var y2 = new BN(1);\n\n  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\n  var a0;\n  var b0;\n  // First vector\n  var a1;\n  var b1;\n  // Second vector\n  var a2;\n  var b2;\n\n  var prevR;\n  var i = 0;\n  var r;\n  var x;\n  while (u.cmpn(0) !== 0) {\n    var q = v.div(u);\n    r = v.sub(q.mul(u));\n    x = x2.sub(q.mul(x1));\n    var y = y2.sub(q.mul(y1));\n\n    if (!a1 && r.cmp(aprxSqrt) < 0) {\n      a0 = prevR.neg();\n      b0 = x1;\n      a1 = r.neg();\n      b1 = x;\n    } else if (a1 && ++i === 2) {\n      break;\n    }\n    prevR = r;\n\n    v = u;\n    u = r;\n    x2 = x1;\n    x1 = x;\n    y2 = y1;\n    y1 = y;\n  }\n  a2 = r.neg();\n  b2 = x;\n\n  var len1 = a1.sqr().add(b1.sqr());\n  var len2 = a2.sqr().add(b2.sqr());\n  if (len2.cmp(len1) >= 0) {\n    a2 = a0;\n    b2 = b0;\n  }\n\n  // Normalize signs\n  if (a1.negative) {\n    a1 = a1.neg();\n    b1 = b1.neg();\n  }\n  if (a2.negative) {\n    a2 = a2.neg();\n    b2 = b2.neg();\n  }\n\n  return [\n    { a: a1, b: b1 },\n    { a: a2, b: b2 },\n  ];\n};\n\nShortCurve.prototype._endoSplit = function _endoSplit(k) {\n  var basis = this.endo.basis;\n  var v1 = basis[0];\n  var v2 = basis[1];\n\n  var c1 = v2.b.mul(k).divRound(this.n);\n  var c2 = v1.b.neg().mul(k).divRound(this.n);\n\n  var p1 = c1.mul(v1.a);\n  var p2 = c2.mul(v2.a);\n  var q1 = c1.mul(v1.b);\n  var q2 = c2.mul(v2.b);\n\n  // Calculate answer\n  var k1 = k.sub(p1).sub(p2);\n  var k2 = q1.add(q2).neg();\n  return { k1: k1, k2: k2 };\n};\n\nShortCurve.prototype.pointFromX = function pointFromX(x, odd) {\n  x = new BN(x, 16);\n  if (!x.red)\n    x = x.toRed(this.red);\n\n  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);\n  var y = y2.redSqrt();\n  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n    throw new Error('invalid point');\n\n  // XXX Is there any way to tell if the number is odd without converting it\n  // to non-red form?\n  var isOdd = y.fromRed().isOdd();\n  if (odd && !isOdd || !odd && isOdd)\n    y = y.redNeg();\n\n  return this.point(x, y);\n};\n\nShortCurve.prototype.validate = function validate(point) {\n  if (point.inf)\n    return true;\n\n  var x = point.x;\n  var y = point.y;\n\n  var ax = this.a.redMul(x);\n  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n  return y.redSqr().redISub(rhs).cmpn(0) === 0;\n};\n\nShortCurve.prototype._endoWnafMulAdd =\n    function _endoWnafMulAdd(points, coeffs, jacobianResult) {\n      var npoints = this._endoWnafT1;\n      var ncoeffs = this._endoWnafT2;\n      for (var i = 0; i < points.length; i++) {\n        var split = this._endoSplit(coeffs[i]);\n        var p = points[i];\n        var beta = p._getBeta();\n\n        if (split.k1.negative) {\n          split.k1.ineg();\n          p = p.neg(true);\n        }\n        if (split.k2.negative) {\n          split.k2.ineg();\n          beta = beta.neg(true);\n        }\n\n        npoints[i * 2] = p;\n        npoints[i * 2 + 1] = beta;\n        ncoeffs[i * 2] = split.k1;\n        ncoeffs[i * 2 + 1] = split.k2;\n      }\n      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\n\n      // Clean-up references to points and coefficients\n      for (var j = 0; j < i * 2; j++) {\n        npoints[j] = null;\n        ncoeffs[j] = null;\n      }\n      return res;\n    };\n\nfunction Point(curve, x, y, isRed) {\n  Base.BasePoint.call(this, curve, 'affine');\n  if (x === null && y === null) {\n    this.x = null;\n    this.y = null;\n    this.inf = true;\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    // Force redgomery representation when loading from JSON\n    if (isRed) {\n      this.x.forceRed(this.curve.red);\n      this.y.forceRed(this.curve.red);\n    }\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n    this.inf = false;\n  }\n}\ninherits(Point, Base.BasePoint);\n\nShortCurve.prototype.point = function point(x, y, isRed) {\n  return new Point(this, x, y, isRed);\n};\n\nShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {\n  return Point.fromJSON(this, obj, red);\n};\n\nPoint.prototype._getBeta = function _getBeta() {\n  if (!this.curve.endo)\n    return;\n\n  var pre = this.precomputed;\n  if (pre && pre.beta)\n    return pre.beta;\n\n  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n  if (pre) {\n    var curve = this.curve;\n    var endoMul = function(p) {\n      return curve.point(p.x.redMul(curve.endo.beta), p.y);\n    };\n    pre.beta = beta;\n    beta.precomputed = {\n      beta: null,\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(endoMul),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(endoMul),\n      },\n    };\n  }\n  return beta;\n};\n\nPoint.prototype.toJSON = function toJSON() {\n  if (!this.precomputed)\n    return [ this.x, this.y ];\n\n  return [ this.x, this.y, this.precomputed && {\n    doubles: this.precomputed.doubles && {\n      step: this.precomputed.doubles.step,\n      points: this.precomputed.doubles.points.slice(1),\n    },\n    naf: this.precomputed.naf && {\n      wnd: this.precomputed.naf.wnd,\n      points: this.precomputed.naf.points.slice(1),\n    },\n  } ];\n};\n\nPoint.fromJSON = function fromJSON(curve, obj, red) {\n  if (typeof obj === 'string')\n    obj = JSON.parse(obj);\n  var res = curve.point(obj[0], obj[1], red);\n  if (!obj[2])\n    return res;\n\n  function obj2point(obj) {\n    return curve.point(obj[0], obj[1], red);\n  }\n\n  var pre = obj[2];\n  res.precomputed = {\n    beta: null,\n    doubles: pre.doubles && {\n      step: pre.doubles.step,\n      points: [ res ].concat(pre.doubles.points.map(obj2point)),\n    },\n    naf: pre.naf && {\n      wnd: pre.naf.wnd,\n      points: [ res ].concat(pre.naf.points.map(obj2point)),\n    },\n  };\n  return res;\n};\n\nPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC Point Infinity>';\n  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n      ' y: ' + this.y.fromRed().toString(16, 2) + '>';\n};\n\nPoint.prototype.isInfinity = function isInfinity() {\n  return this.inf;\n};\n\nPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.inf)\n    return p;\n\n  // P + O = P\n  if (p.inf)\n    return this;\n\n  // P + P = 2P\n  if (this.eq(p))\n    return this.dbl();\n\n  // P + (-P) = O\n  if (this.neg().eq(p))\n    return this.curve.point(null, null);\n\n  // P + Q = O\n  if (this.x.cmp(p.x) === 0)\n    return this.curve.point(null, null);\n\n  var c = this.y.redSub(p.y);\n  if (c.cmpn(0) !== 0)\n    c = c.redMul(this.x.redSub(p.x).redInvm());\n  var nx = c.redSqr().redISub(this.x).redISub(p.x);\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.dbl = function dbl() {\n  if (this.inf)\n    return this;\n\n  // 2P = O\n  var ys1 = this.y.redAdd(this.y);\n  if (ys1.cmpn(0) === 0)\n    return this.curve.point(null, null);\n\n  var a = this.curve.a;\n\n  var x2 = this.x.redSqr();\n  var dyinv = ys1.redInvm();\n  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);\n\n  var nx = c.redSqr().redISub(this.x.redAdd(this.x));\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.getX = function getX() {\n  return this.x.fromRed();\n};\n\nPoint.prototype.getY = function getY() {\n  return this.y.fromRed();\n};\n\nPoint.prototype.mul = function mul(k) {\n  k = new BN(k, 16);\n  if (this.isInfinity())\n    return this;\n  else if (this._hasDoubles(k))\n    return this.curve._fixedNafMul(this, k);\n  else if (this.curve.endo)\n    return this.curve._endoWnafMulAdd([ this ], [ k ]);\n  else\n    return this.curve._wnafMul(this, k);\n};\n\nPoint.prototype.mulAdd = function mulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2);\n};\n\nPoint.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs, true);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);\n};\n\nPoint.prototype.eq = function eq(p) {\n  return this === p ||\n         this.inf === p.inf &&\n             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n};\n\nPoint.prototype.neg = function neg(_precompute) {\n  if (this.inf)\n    return this;\n\n  var res = this.curve.point(this.x, this.y.redNeg());\n  if (_precompute && this.precomputed) {\n    var pre = this.precomputed;\n    var negate = function(p) {\n      return p.neg();\n    };\n    res.precomputed = {\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(negate),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(negate),\n      },\n    };\n  }\n  return res;\n};\n\nPoint.prototype.toJ = function toJ() {\n  if (this.inf)\n    return this.curve.jpoint(null, null, null);\n\n  var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n  return res;\n};\n\nfunction JPoint(curve, x, y, z) {\n  Base.BasePoint.call(this, curve, 'jacobian');\n  if (x === null && y === null && z === null) {\n    this.x = this.curve.one;\n    this.y = this.curve.one;\n    this.z = new BN(0);\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    this.z = new BN(z, 16);\n  }\n  if (!this.x.red)\n    this.x = this.x.toRed(this.curve.red);\n  if (!this.y.red)\n    this.y = this.y.toRed(this.curve.red);\n  if (!this.z.red)\n    this.z = this.z.toRed(this.curve.red);\n\n  this.zOne = this.z === this.curve.one;\n}\ninherits(JPoint, Base.BasePoint);\n\nShortCurve.prototype.jpoint = function jpoint(x, y, z) {\n  return new JPoint(this, x, y, z);\n};\n\nJPoint.prototype.toP = function toP() {\n  if (this.isInfinity())\n    return this.curve.point(null, null);\n\n  var zinv = this.z.redInvm();\n  var zinv2 = zinv.redSqr();\n  var ax = this.x.redMul(zinv2);\n  var ay = this.y.redMul(zinv2).redMul(zinv);\n\n  return this.curve.point(ax, ay);\n};\n\nJPoint.prototype.neg = function neg() {\n  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n};\n\nJPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p;\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 12M + 4S + 7A\n  var pz2 = p.z.redSqr();\n  var z2 = this.z.redSqr();\n  var u1 = this.x.redMul(pz2);\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y.redMul(pz2.redMul(p.z));\n  var s2 = p.y.redMul(z2.redMul(this.z));\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(p.z).redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mixedAdd = function mixedAdd(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p.toJ();\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 8M + 3S + 7A\n  var z2 = this.z.redSqr();\n  var u1 = this.x;\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y;\n  var s2 = p.y.redMul(z2).redMul(this.z);\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.dblp = function dblp(pow) {\n  if (pow === 0)\n    return this;\n  if (this.isInfinity())\n    return this;\n  if (!pow)\n    return this.dbl();\n\n  var i;\n  if (this.curve.zeroA || this.curve.threeA) {\n    var r = this;\n    for (i = 0; i < pow; i++)\n      r = r.dbl();\n    return r;\n  }\n\n  // 1M + 2S + 1A + N * (4S + 5M + 8A)\n  // N = 1 => 6M + 6S + 9A\n  var a = this.curve.a;\n  var tinv = this.curve.tinv;\n\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  // Reuse results\n  var jyd = jy.redAdd(jy);\n  for (i = 0; i < pow; i++) {\n    var jx2 = jx.redSqr();\n    var jyd2 = jyd.redSqr();\n    var jyd4 = jyd2.redSqr();\n    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n    var t1 = jx.redMul(jyd2);\n    var nx = c.redSqr().redISub(t1.redAdd(t1));\n    var t2 = t1.redISub(nx);\n    var dny = c.redMul(t2);\n    dny = dny.redIAdd(dny).redISub(jyd4);\n    var nz = jyd.redMul(jz);\n    if (i + 1 < pow)\n      jz4 = jz4.redMul(jyd4);\n\n    jx = nx;\n    jz = nz;\n    jyd = dny;\n  }\n\n  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n};\n\nJPoint.prototype.dbl = function dbl() {\n  if (this.isInfinity())\n    return this;\n\n  if (this.curve.zeroA)\n    return this._zeroDbl();\n  else if (this.curve.threeA)\n    return this._threeDbl();\n  else\n    return this._dbl();\n};\n\nJPoint.prototype._zeroDbl = function _zeroDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 14A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a; a = 0\n    var m = xx.redAdd(xx).redIAdd(xx);\n    // T = M ^ 2 - 2*S\n    var t = m.redSqr().redISub(s).redISub(s);\n\n    // 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2*Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-dbl-2009-l\n    // 2M + 5S + 13A\n\n    // A = X1^2\n    var a = this.x.redSqr();\n    // B = Y1^2\n    var b = this.y.redSqr();\n    // C = B^2\n    var c = b.redSqr();\n    // D = 2 * ((X1 + B)^2 - A - C)\n    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n    d = d.redIAdd(d);\n    // E = 3 * A\n    var e = a.redAdd(a).redIAdd(a);\n    // F = E^2\n    var f = e.redSqr();\n\n    // 8 * C\n    var c8 = c.redIAdd(c);\n    c8 = c8.redIAdd(c8);\n    c8 = c8.redIAdd(c8);\n\n    // X3 = F - 2 * D\n    nx = f.redISub(d).redISub(d);\n    // Y3 = E * (D - X3) - 8 * C\n    ny = e.redMul(d.redISub(nx)).redISub(c8);\n    // Z3 = 2 * Y1 * Z1\n    nz = this.y.redMul(this.z);\n    nz = nz.redIAdd(nz);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._threeDbl = function _threeDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 15A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a\n    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);\n    // T = M^2 - 2 * S\n    var t = m.redSqr().redISub(s).redISub(s);\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2 * Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n    // 3M + 5S\n\n    // delta = Z1^2\n    var delta = this.z.redSqr();\n    // gamma = Y1^2\n    var gamma = this.y.redSqr();\n    // beta = X1 * gamma\n    var beta = this.x.redMul(gamma);\n    // alpha = 3 * (X1 - delta) * (X1 + delta)\n    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n    alpha = alpha.redAdd(alpha).redIAdd(alpha);\n    // X3 = alpha^2 - 8 * beta\n    var beta4 = beta.redIAdd(beta);\n    beta4 = beta4.redIAdd(beta4);\n    var beta8 = beta4.redAdd(beta4);\n    nx = alpha.redSqr().redISub(beta8);\n    // Z3 = (Y1 + Z1)^2 - gamma - delta\n    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n    var ggamma8 = gamma.redSqr();\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._dbl = function _dbl() {\n  var a = this.curve.a;\n\n  // 4M + 6S + 10A\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  var jx2 = jx.redSqr();\n  var jy2 = jy.redSqr();\n\n  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n  var jxd4 = jx.redAdd(jx);\n  jxd4 = jxd4.redIAdd(jxd4);\n  var t1 = jxd4.redMul(jy2);\n  var nx = c.redSqr().redISub(t1.redAdd(t1));\n  var t2 = t1.redISub(nx);\n\n  var jyd8 = jy2.redSqr();\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  var ny = c.redMul(t2).redISub(jyd8);\n  var nz = jy.redAdd(jy).redMul(jz);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.trpl = function trpl() {\n  if (!this.curve.zeroA)\n    return this.dbl().add(this);\n\n  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl\n  // 5M + 10S + ...\n\n  // XX = X1^2\n  var xx = this.x.redSqr();\n  // YY = Y1^2\n  var yy = this.y.redSqr();\n  // ZZ = Z1^2\n  var zz = this.z.redSqr();\n  // YYYY = YY^2\n  var yyyy = yy.redSqr();\n  // M = 3 * XX + a * ZZ2; a = 0\n  var m = xx.redAdd(xx).redIAdd(xx);\n  // MM = M^2\n  var mm = m.redSqr();\n  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM\n  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n  e = e.redIAdd(e);\n  e = e.redAdd(e).redIAdd(e);\n  e = e.redISub(mm);\n  // EE = E^2\n  var ee = e.redSqr();\n  // T = 16*YYYY\n  var t = yyyy.redIAdd(yyyy);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  // U = (M + E)^2 - MM - EE - T\n  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);\n  // X3 = 4 * (X1 * EE - 4 * YY * U)\n  var yyu4 = yy.redMul(u);\n  yyu4 = yyu4.redIAdd(yyu4);\n  yyu4 = yyu4.redIAdd(yyu4);\n  var nx = this.x.redMul(ee).redISub(yyu4);\n  nx = nx.redIAdd(nx);\n  nx = nx.redIAdd(nx);\n  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)\n  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  // Z3 = (Z1 + E)^2 - ZZ - EE\n  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mul = function mul(k, kbase) {\n  k = new BN(k, kbase);\n\n  return this.curve._wnafMul(this, k);\n};\n\nJPoint.prototype.eq = function eq(p) {\n  if (p.type === 'affine')\n    return this.eq(p.toJ());\n\n  if (this === p)\n    return true;\n\n  // x1 * z2^2 == x2 * z1^2\n  var z2 = this.z.redSqr();\n  var pz2 = p.z.redSqr();\n  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\n    return false;\n\n  // y1 * z2^3 == y2 * z1^3\n  var z3 = z2.redMul(this.z);\n  var pz3 = pz2.redMul(p.z);\n  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n};\n\nJPoint.prototype.eqXToP = function eqXToP(x) {\n  var zs = this.z.redSqr();\n  var rx = x.toRed(this.curve.red).redMul(zs);\n  if (this.x.cmp(rx) === 0)\n    return true;\n\n  var xc = x.clone();\n  var t = this.curve.redN.redMul(zs);\n  for (;;) {\n    xc.iadd(this.curve.n);\n    if (xc.cmp(this.curve.p) >= 0)\n      return false;\n\n    rx.redIAdd(t);\n    if (this.x.cmp(rx) === 0)\n      return true;\n  }\n};\n\nJPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC JPoint Infinity>';\n  return '<EC JPoint x: ' + this.x.toString(16, 2) +\n      ' y: ' + this.y.toString(16, 2) +\n      ' z: ' + this.z.toString(16, 2) + '>';\n};\n\nJPoint.prototype.isInfinity = function isInfinity() {\n  // XXX This code assumes that zero is always zero in red\n  return this.z.cmpn(0) === 0;\n};\n","'use strict';\n\nvar curve = exports;\n\ncurve.base = require('./base');\ncurve.short = require('./short');\ncurve.mont = require('./mont');\ncurve.edwards = require('./edwards');\n","'use strict';\n\nvar curves = exports;\n\nvar hash = require('hash.js');\nvar curve = require('./curve');\nvar utils = require('./utils');\n\nvar assert = utils.assert;\n\nfunction PresetCurve(options) {\n  if (options.type === 'short')\n    this.curve = new curve.short(options);\n  else if (options.type === 'edwards')\n    this.curve = new curve.edwards(options);\n  else\n    this.curve = new curve.mont(options);\n  this.g = this.curve.g;\n  this.n = this.curve.n;\n  this.hash = options.hash;\n\n  assert(this.g.validate(), 'Invalid curve');\n  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');\n}\ncurves.PresetCurve = PresetCurve;\n\nfunction defineCurve(name, options) {\n  Object.defineProperty(curves, name, {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n      var curve = new PresetCurve(options);\n      Object.defineProperty(curves, name, {\n        configurable: true,\n        enumerable: true,\n        value: curve,\n      });\n      return curve;\n    },\n  });\n}\n\ndefineCurve('p192', {\n  type: 'short',\n  prime: 'p192',\n  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',\n  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',\n  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',\n    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',\n  ],\n});\n\ndefineCurve('p224', {\n  type: 'short',\n  prime: 'p224',\n  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',\n  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',\n  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',\n    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',\n  ],\n});\n\ndefineCurve('p256', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',\n  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',\n  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',\n  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',\n    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',\n  ],\n});\n\ndefineCurve('p384', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 ffffffff',\n  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 fffffffc',\n  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +\n     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',\n  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +\n     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',\n  hash: hash.sha384,\n  gRed: false,\n  g: [\n    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +\n    '5502f25d bf55296c 3a545e38 72760ab7',\n    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +\n    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',\n  ],\n});\n\ndefineCurve('p521', {\n  type: 'short',\n  prime: null,\n  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff',\n  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff fffffffc',\n  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +\n     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +\n     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',\n  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +\n     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',\n  hash: hash.sha512,\n  gRed: false,\n  g: [\n    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +\n    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +\n    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',\n    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +\n    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +\n    '3fad0761 353c7086 a272c240 88be9476 9fd16650',\n  ],\n});\n\ndefineCurve('curve25519', {\n  type: 'mont',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '76d06',\n  b: '1',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '9',\n  ],\n});\n\ndefineCurve('ed25519', {\n  type: 'edwards',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '-1',\n  c: '1',\n  // -121665 * (121666^(-1)) (mod P)\n  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',\n\n    // 4/5\n    '6666666666666666666666666666666666666666666666666666666666666658',\n  ],\n});\n\nvar pre;\ntry {\n  pre = require('./precomputed/secp256k1');\n} catch (e) {\n  pre = undefined;\n}\n\ndefineCurve('secp256k1', {\n  type: 'short',\n  prime: 'k256',\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',\n  a: '0',\n  b: '7',\n  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',\n  h: '1',\n  hash: hash.sha256,\n\n  // Precomputed endomorphism\n  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',\n  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',\n  basis: [\n    {\n      a: '3086d221a7d46bcde86c90e49284eb15',\n      b: '-e4437ed6010e88286f547fa90abfe4c3',\n    },\n    {\n      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n      b: '3086d221a7d46bcde86c90e49284eb15',\n    },\n  ],\n\n  gRed: false,\n  g: [\n    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n    pre,\n  ],\n});\n","'use strict';\n\nvar hash = require('hash.js');\nvar utils = require('minimalistic-crypto-utils');\nvar assert = require('minimalistic-assert');\n\nfunction HmacDRBG(options) {\n  if (!(this instanceof HmacDRBG))\n    return new HmacDRBG(options);\n  this.hash = options.hash;\n  this.predResist = !!options.predResist;\n\n  this.outLen = this.hash.outSize;\n  this.minEntropy = options.minEntropy || this.hash.hmacStrength;\n\n  this._reseed = null;\n  this.reseedInterval = null;\n  this.K = null;\n  this.V = null;\n\n  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');\n  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');\n  var pers = utils.toArray(options.pers, options.persEnc || 'hex');\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n  this._init(entropy, nonce, pers);\n}\nmodule.exports = HmacDRBG;\n\nHmacDRBG.prototype._init = function init(entropy, nonce, pers) {\n  var seed = entropy.concat(nonce).concat(pers);\n\n  this.K = new Array(this.outLen / 8);\n  this.V = new Array(this.outLen / 8);\n  for (var i = 0; i < this.V.length; i++) {\n    this.K[i] = 0x00;\n    this.V[i] = 0x01;\n  }\n\n  this._update(seed);\n  this._reseed = 1;\n  this.reseedInterval = 0x1000000000000;  // 2^48\n};\n\nHmacDRBG.prototype._hmac = function hmac() {\n  return new hash.hmac(this.hash, this.K);\n};\n\nHmacDRBG.prototype._update = function update(seed) {\n  var kmac = this._hmac()\n                 .update(this.V)\n                 .update([ 0x00 ]);\n  if (seed)\n    kmac = kmac.update(seed);\n  this.K = kmac.digest();\n  this.V = this._hmac().update(this.V).digest();\n  if (!seed)\n    return;\n\n  this.K = this._hmac()\n               .update(this.V)\n               .update([ 0x01 ])\n               .update(seed)\n               .digest();\n  this.V = this._hmac().update(this.V).digest();\n};\n\nHmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\n  // Optional entropy enc\n  if (typeof entropyEnc !== 'string') {\n    addEnc = add;\n    add = entropyEnc;\n    entropyEnc = null;\n  }\n\n  entropy = utils.toArray(entropy, entropyEnc);\n  add = utils.toArray(add, addEnc);\n\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n\n  this._update(entropy.concat(add || []));\n  this._reseed = 1;\n};\n\nHmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\n  if (this._reseed > this.reseedInterval)\n    throw new Error('Reseed is required');\n\n  // Optional encoding\n  if (typeof enc !== 'string') {\n    addEnc = add;\n    add = enc;\n    enc = null;\n  }\n\n  // Optional additional data\n  if (add) {\n    add = utils.toArray(add, addEnc || 'hex');\n    this._update(add);\n  }\n\n  var temp = [];\n  while (temp.length < len) {\n    this.V = this._hmac().update(this.V).digest();\n    temp = temp.concat(this.V);\n  }\n\n  var res = temp.slice(0, len);\n  this._update(add);\n  this._reseed++;\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction KeyPair(ec, options) {\n  this.ec = ec;\n  this.priv = null;\n  this.pub = null;\n\n  // KeyPair(ec, { priv: ..., pub: ... })\n  if (options.priv)\n    this._importPrivate(options.priv, options.privEnc);\n  if (options.pub)\n    this._importPublic(options.pub, options.pubEnc);\n}\nmodule.exports = KeyPair;\n\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n  if (pub instanceof KeyPair)\n    return pub;\n\n  return new KeyPair(ec, {\n    pub: pub,\n    pubEnc: enc,\n  });\n};\n\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n  if (priv instanceof KeyPair)\n    return priv;\n\n  return new KeyPair(ec, {\n    priv: priv,\n    privEnc: enc,\n  });\n};\n\nKeyPair.prototype.validate = function validate() {\n  var pub = this.getPublic();\n\n  if (pub.isInfinity())\n    return { result: false, reason: 'Invalid public key' };\n  if (!pub.validate())\n    return { result: false, reason: 'Public key is not a point' };\n  if (!pub.mul(this.ec.curve.n).isInfinity())\n    return { result: false, reason: 'Public key * N != O' };\n\n  return { result: true, reason: null };\n};\n\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n  // compact is optional argument\n  if (typeof compact === 'string') {\n    enc = compact;\n    compact = null;\n  }\n\n  if (!this.pub)\n    this.pub = this.ec.g.mul(this.priv);\n\n  if (!enc)\n    return this.pub;\n\n  return this.pub.encode(enc, compact);\n};\n\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\n  if (enc === 'hex')\n    return this.priv.toString(16, 2);\n  else\n    return this.priv;\n};\n\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n  this.priv = new BN(key, enc || 16);\n\n  // Ensure that the priv won't be bigger than n, otherwise we may fail\n  // in fixed multiplication method\n  this.priv = this.priv.umod(this.ec.curve.n);\n};\n\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n  if (key.x || key.y) {\n    // Montgomery points only have an `x` coordinate.\n    // Weierstrass/Edwards points on the other hand have both `x` and\n    // `y` coordinates.\n    if (this.ec.curve.type === 'mont') {\n      assert(key.x, 'Need x coordinate');\n    } else if (this.ec.curve.type === 'short' ||\n               this.ec.curve.type === 'edwards') {\n      assert(key.x && key.y, 'Need both x and y coordinate');\n    }\n    this.pub = this.ec.curve.point(key.x, key.y);\n    return;\n  }\n  this.pub = this.ec.curve.decodePoint(key, enc);\n};\n\n// ECDH\nKeyPair.prototype.derive = function derive(pub) {\n  if(!pub.validate()) {\n    assert(pub.validate(), 'public point not validated');\n  }\n  return pub.mul(this.priv).getX();\n};\n\n// ECDSA\nKeyPair.prototype.sign = function sign(msg, enc, options) {\n  return this.ec.sign(msg, this, enc, options);\n};\n\nKeyPair.prototype.verify = function verify(msg, signature) {\n  return this.ec.verify(msg, signature, this);\n};\n\nKeyPair.prototype.inspect = function inspect() {\n  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +\n         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n};\n","'use strict';\n\nvar BN = require('bn.js');\n\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction Signature(options, enc) {\n  if (options instanceof Signature)\n    return options;\n\n  if (this._importDER(options, enc))\n    return;\n\n  assert(options.r && options.s, 'Signature without r or s');\n  this.r = new BN(options.r, 16);\n  this.s = new BN(options.s, 16);\n  if (options.recoveryParam === undefined)\n    this.recoveryParam = null;\n  else\n    this.recoveryParam = options.recoveryParam;\n}\nmodule.exports = Signature;\n\nfunction Position() {\n  this.place = 0;\n}\n\nfunction getLength(buf, p) {\n  var initial = buf[p.place++];\n  if (!(initial & 0x80)) {\n    return initial;\n  }\n  var octetLen = initial & 0xf;\n\n  // Indefinite length or overflow\n  if (octetLen === 0 || octetLen > 4) {\n    return false;\n  }\n\n  var val = 0;\n  for (var i = 0, off = p.place; i < octetLen; i++, off++) {\n    val <<= 8;\n    val |= buf[off];\n    val >>>= 0;\n  }\n\n  // Leading zeroes\n  if (val <= 0x7f) {\n    return false;\n  }\n\n  p.place = off;\n  return val;\n}\n\nfunction rmPadding(buf) {\n  var i = 0;\n  var len = buf.length - 1;\n  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {\n    i++;\n  }\n  if (i === 0) {\n    return buf;\n  }\n  return buf.slice(i);\n}\n\nSignature.prototype._importDER = function _importDER(data, enc) {\n  data = utils.toArray(data, enc);\n  var p = new Position();\n  if (data[p.place++] !== 0x30) {\n    return false;\n  }\n  var len = getLength(data, p);\n  if (len === false) {\n    return false;\n  }\n  if ((len + p.place) !== data.length) {\n    return false;\n  }\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var rlen = getLength(data, p);\n  if (rlen === false) {\n    return false;\n  }\n  var r = data.slice(p.place, rlen + p.place);\n  p.place += rlen;\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var slen = getLength(data, p);\n  if (slen === false) {\n    return false;\n  }\n  if (data.length !== slen + p.place) {\n    return false;\n  }\n  var s = data.slice(p.place, slen + p.place);\n  if (r[0] === 0) {\n    if (r[1] & 0x80) {\n      r = r.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n  if (s[0] === 0) {\n    if (s[1] & 0x80) {\n      s = s.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n\n  this.r = new BN(r);\n  this.s = new BN(s);\n  this.recoveryParam = null;\n\n  return true;\n};\n\nfunction constructLength(arr, len) {\n  if (len < 0x80) {\n    arr.push(len);\n    return;\n  }\n  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n  arr.push(octets | 0x80);\n  while (--octets) {\n    arr.push((len >>> (octets << 3)) & 0xff);\n  }\n  arr.push(len);\n}\n\nSignature.prototype.toDER = function toDER(enc) {\n  var r = this.r.toArray();\n  var s = this.s.toArray();\n\n  // Pad values\n  if (r[0] & 0x80)\n    r = [ 0 ].concat(r);\n  // Pad values\n  if (s[0] & 0x80)\n    s = [ 0 ].concat(s);\n\n  r = rmPadding(r);\n  s = rmPadding(s);\n\n  while (!s[0] && !(s[1] & 0x80)) {\n    s = s.slice(1);\n  }\n  var arr = [ 0x02 ];\n  constructLength(arr, r.length);\n  arr = arr.concat(r);\n  arr.push(0x02);\n  constructLength(arr, s.length);\n  var backHalf = arr.concat(s);\n  var res = [ 0x30 ];\n  constructLength(res, backHalf.length);\n  res = res.concat(backHalf);\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar HmacDRBG = require('hmac-drbg');\nvar utils = require('../utils');\nvar curves = require('../curves');\nvar rand = require('brorand');\nvar assert = utils.assert;\n\nvar KeyPair = require('./key');\nvar Signature = require('./signature');\n\nfunction EC(options) {\n  if (!(this instanceof EC))\n    return new EC(options);\n\n  // Shortcut `elliptic.ec(curve-name)`\n  if (typeof options === 'string') {\n    assert(Object.prototype.hasOwnProperty.call(curves, options),\n      'Unknown curve ' + options);\n\n    options = curves[options];\n  }\n\n  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\n  if (options instanceof curves.PresetCurve)\n    options = { curve: options };\n\n  this.curve = options.curve.curve;\n  this.n = this.curve.n;\n  this.nh = this.n.ushrn(1);\n  this.g = this.curve.g;\n\n  // Point on curve\n  this.g = options.curve.g;\n  this.g.precompute(options.curve.n.bitLength() + 1);\n\n  // Hash for function for DRBG\n  this.hash = options.hash || options.curve.hash;\n}\nmodule.exports = EC;\n\nEC.prototype.keyPair = function keyPair(options) {\n  return new KeyPair(this, options);\n};\n\nEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n  return KeyPair.fromPrivate(this, priv, enc);\n};\n\nEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n  return KeyPair.fromPublic(this, pub, enc);\n};\n\nEC.prototype.genKeyPair = function genKeyPair(options) {\n  if (!options)\n    options = {};\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n    entropy: options.entropy || rand(this.hash.hmacStrength),\n    entropyEnc: options.entropy && options.entropyEnc || 'utf8',\n    nonce: this.n.toArray(),\n  });\n\n  var bytes = this.n.byteLength();\n  var ns2 = this.n.sub(new BN(2));\n  for (;;) {\n    var priv = new BN(drbg.generate(bytes));\n    if (priv.cmp(ns2) > 0)\n      continue;\n\n    priv.iaddn(1);\n    return this.keyFromPrivate(priv);\n  }\n};\n\nEC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {\n  var delta = msg.byteLength() * 8 - this.n.bitLength();\n  if (delta > 0)\n    msg = msg.ushrn(delta);\n  if (!truncOnly && msg.cmp(this.n) >= 0)\n    return msg.sub(this.n);\n  else\n    return msg;\n};\n\nEC.prototype.sign = function sign(msg, key, enc, options) {\n  if (typeof enc === 'object') {\n    options = enc;\n    enc = null;\n  }\n  if (!options)\n    options = {};\n\n  key = this.keyFromPrivate(key, enc);\n  msg = this._truncateToN(new BN(msg, 16));\n\n  // Zero-extend key to provide enough entropy\n  var bytes = this.n.byteLength();\n  var bkey = key.getPrivate().toArray('be', bytes);\n\n  // Zero-extend nonce to have the same byte size as N\n  var nonce = msg.toArray('be', bytes);\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    entropy: bkey,\n    nonce: nonce,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n  });\n\n  // Number of bytes to generate\n  var ns1 = this.n.sub(new BN(1));\n\n  for (var iter = 0; ; iter++) {\n    var k = options.k ?\n      options.k(iter) :\n      new BN(drbg.generate(this.n.byteLength()));\n    k = this._truncateToN(k, true);\n    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)\n      continue;\n\n    var kp = this.g.mul(k);\n    if (kp.isInfinity())\n      continue;\n\n    var kpX = kp.getX();\n    var r = kpX.umod(this.n);\n    if (r.cmpn(0) === 0)\n      continue;\n\n    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n    s = s.umod(this.n);\n    if (s.cmpn(0) === 0)\n      continue;\n\n    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |\n                        (kpX.cmp(r) !== 0 ? 2 : 0);\n\n    // Use complement of `s`, if it is > `n / 2`\n    if (options.canonical && s.cmp(this.nh) > 0) {\n      s = this.n.sub(s);\n      recoveryParam ^= 1;\n    }\n\n    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });\n  }\n};\n\nEC.prototype.verify = function verify(msg, signature, key, enc) {\n  msg = this._truncateToN(new BN(msg, 16));\n  key = this.keyFromPublic(key, enc);\n  signature = new Signature(signature, 'hex');\n\n  // Perform primitive values validation\n  var r = signature.r;\n  var s = signature.s;\n  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)\n    return false;\n  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n    return false;\n\n  // Validate signature\n  var sinv = s.invm(this.n);\n  var u1 = sinv.mul(msg).umod(this.n);\n  var u2 = sinv.mul(r).umod(this.n);\n  var p;\n\n  if (!this.curve._maxwellTrick) {\n    p = this.g.mulAdd(u1, key.getPublic(), u2);\n    if (p.isInfinity())\n      return false;\n\n    return p.getX().umod(this.n).cmp(r) === 0;\n  }\n\n  // NOTE: Greg Maxwell's trick, inspired by:\n  // https://git.io/vad3K\n\n  p = this.g.jmulAdd(u1, key.getPublic(), u2);\n  if (p.isInfinity())\n    return false;\n\n  // Compare `p.x` of Jacobian point with `r`,\n  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\n  // inverse of `p.z^2`\n  return p.eqXToP(r);\n};\n\nEC.prototype.recoverPubKey = function(msg, signature, j, enc) {\n  assert((3 & j) === j, 'The recovery param is more than two bits');\n  signature = new Signature(signature, enc);\n\n  var n = this.n;\n  var e = new BN(msg);\n  var r = signature.r;\n  var s = signature.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = j & 1;\n  var isSecondKey = j >> 1;\n  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n    throw new Error('Unable to find sencond key candinate');\n\n  // 1.1. Let x = r + jn.\n  if (isSecondKey)\n    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\n  else\n    r = this.curve.pointFromX(r, isYOdd);\n\n  var rInv = signature.r.invm(n);\n  var s1 = n.sub(e).mul(rInv).umod(n);\n  var s2 = s.mul(rInv).umod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n  return this.g.mulAdd(s1, r, s2);\n};\n\nEC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {\n  signature = new Signature(signature, enc);\n  if (signature.recoveryParam !== null)\n    return signature.recoveryParam;\n\n  for (var i = 0; i < 4; i++) {\n    var Qprime;\n    try {\n      Qprime = this.recoverPubKey(e, signature, i);\n    } catch (e) {\n      continue;\n    }\n\n    if (Qprime.eq(Q))\n      return i;\n  }\n  throw new Error('Unable to find valid recovery factor');\n};\n","import _ec from \"elliptic\";\nvar EC = _ec.ec;\nexport { EC };\n//# sourceMappingURL=elliptic.js.map","'use strict';\n\nvar elliptic = exports;\n\nelliptic.version = require('../package.json').version;\nelliptic.utils = require('./elliptic/utils');\nelliptic.rand = require('brorand');\nelliptic.curve = require('./elliptic/curve');\nelliptic.curves = require('./elliptic/curves');\n\n// Protocols\nelliptic.ec = require('./elliptic/ec');\nelliptic.eddsa = require('./elliptic/eddsa');\n","\"use strict\";\n\nimport { EC } from \"./elliptic\";\n\nimport { arrayify, BytesLike, hexlify, hexZeroPad, Signature, SignatureLike, splitSignature } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nlet _curve: EC = null\nfunction getCurve() {\n    if (!_curve) {\n        _curve = new EC(\"secp256k1\");\n    }\n    return _curve;\n}\n\nexport class SigningKey {\n\n    readonly curve: string;\n\n    readonly privateKey: string;\n    readonly publicKey: string;\n    readonly compressedPublicKey: string;\n\n    //readonly address: string;\n\n    readonly _isSigningKey: boolean;\n\n    constructor(privateKey: BytesLike) {\n        defineReadOnly(this, \"curve\", \"secp256k1\");\n\n        defineReadOnly(this, \"privateKey\", hexlify(privateKey));\n\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n\n        defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n        defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n\n        defineReadOnly(this, \"_isSigningKey\", true);\n    }\n\n    _addPoint(other: BytesLike): string {\n        const p0 =  getCurve().keyFromPublic(arrayify(this.publicKey));\n        const p1 =  getCurve().keyFromPublic(arrayify(other));\n        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n\n    signDigest(digest: BytesLike): Signature {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const digestBytes = arrayify(digest);\n        if (digestBytes.length !== 32) {\n            logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n        }\n        const signature = keyPair.sign(digestBytes, { canonical: true });\n        return splitSignature({\n            recoveryParam: signature.recoveryParam,\n            r: hexZeroPad(\"0x\" + signature.r.toString(16), 32),\n            s: hexZeroPad(\"0x\" + signature.s.toString(16), 32),\n        })\n    }\n\n    computeSharedSecret(otherKey: BytesLike): string {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));\n        return hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n\n    static isSigningKey(value: any): value is SigningKey {\n        return !!(value && value._isSigningKey);\n    }\n}\n\nexport function recoverPublicKey(digest: BytesLike, signature: SignatureLike): string {\n    const sig = splitSignature(signature);\n    const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };\n    return \"0x\" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\n\nexport function computePublicKey(key: BytesLike, compressed?: boolean): string {\n    const bytes = arrayify(key);\n\n    if (bytes.length === 32) {\n        const signingKey = new SigningKey(bytes);\n        if (compressed) {\n            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n        }\n        return signingKey.publicKey;\n\n    } else if (bytes.length === 33) {\n        if (compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n\n    } else if (bytes.length === 65) {\n        if (!compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n    }\n\n    return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}\n\n","export const version = \"signing-key/5.6.0\";\n","export const version = \"transactions/5.6.0\";\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, DataOptions, hexConcat, hexDataLength, hexDataSlice, hexlify, hexZeroPad, isBytesLike, SignatureLike, splitSignature, stripZeros, } from \"@ethersproject/bytes\";\nimport { Zero } from \"@ethersproject/constants\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { checkProperties } from \"@ethersproject/properties\";\nimport * as RLP from \"@ethersproject/rlp\";\nimport { computePublicKey, recoverPublicKey } from \"@ethersproject/signing-key\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type AccessList = Array<{ address: string, storageKeys: Array<string> }>;\n\n// Input allows flexibility in describing an access list\nexport type AccessListish = AccessList |\n                            Array<[ string, Array<string> ]> |\n                            Record<string, Array<string>>;\n\nexport enum TransactionTypes {\n    legacy = 0,\n    eip2930 = 1,\n    eip1559 = 2,\n};\n\nexport type UnsignedTransaction = {\n    to?: string;\n    nonce?: number;\n\n    gasLimit?: BigNumberish;\n    gasPrice?: BigNumberish;\n\n    data?: BytesLike;\n    value?: BigNumberish;\n    chainId?: number;\n\n    // Typed-Transaction features\n    type?: number | null;\n\n    // EIP-2930; Type 1 & EIP-1559; Type 2\n    accessList?: AccessListish;\n\n    // EIP-1559; Type 2\n    maxPriorityFeePerGas?: BigNumberish;\n    maxFeePerGas?: BigNumberish;\n}\n\nexport interface Transaction {\n    hash?: string;\n\n    to?: string;\n    from?: string;\n    nonce: number;\n\n    gasLimit: BigNumber;\n    gasPrice?: BigNumber;\n\n    data: string;\n    value: BigNumber;\n    chainId: number;\n\n    r?: string;\n    s?: string;\n    v?: number;\n\n    // Typed-Transaction features\n    type?: number | null;\n\n    // EIP-2930; Type 1 & EIP-1559; Type 2\n    accessList?: AccessList;\n\n    // EIP-1559; Type 2\n    maxPriorityFeePerGas?: BigNumber;\n    maxFeePerGas?: BigNumber;\n}\n\n///////////////////////////////\n\nfunction handleAddress(value: string): string {\n    if (value === \"0x\") { return null; }\n    return getAddress(value);\n}\n\nfunction handleNumber(value: string): BigNumber {\n    if (value === \"0x\") { return Zero; }\n    return BigNumber.from(value);\n}\n\n// Legacy Transaction Fields\nconst transactionFields = [\n    { name: \"nonce\",    maxLength: 32, numeric: true },\n    { name: \"gasPrice\", maxLength: 32, numeric: true },\n    { name: \"gasLimit\", maxLength: 32, numeric: true },\n    { name: \"to\",          length: 20 },\n    { name: \"value\",    maxLength: 32, numeric: true },\n    { name: \"data\" },\n];\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, gasLimit: true, gasPrice:true, nonce: true, to: true, type: true, value: true\n}\n\nexport function computeAddress(key: BytesLike | string): string {\n    const publicKey = computePublicKey(key);\n    return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));\n}\n\nexport function recoverAddress(digest: BytesLike, signature: SignatureLike): string {\n    return computeAddress(recoverPublicKey(arrayify(digest), signature));\n}\n\nfunction formatNumber(value: BigNumberish, name: string): Uint8Array {\n    const result = stripZeros(BigNumber.from(value).toHexString());\n    if (result.length > 32) {\n        logger.throwArgumentError(\"invalid length for \" + name, (\"transaction:\" + name), value);\n    }\n    return result;\n}\n\nfunction accessSetify(addr: string, storageKeys: Array<string>): { address: string,storageKeys: Array<string> } {\n    return {\n        address: getAddress(addr),\n        storageKeys: (storageKeys || []).map((storageKey, index) => {\n            if (hexDataLength(storageKey) !== 32) {\n                logger.throwArgumentError(\"invalid access list storageKey\", `accessList[${ addr }:${ index }]`, storageKey)\n            }\n            return storageKey.toLowerCase();\n        })\n    };\n}\n\nexport function accessListify(value: AccessListish): AccessList {\n    if (Array.isArray(value)) {\n        return (<Array<[ string, Array<string>] | { address: string, storageKeys: Array<string>}>>value).map((set, index) => {\n            if (Array.isArray(set)) {\n                if (set.length > 2) {\n                    logger.throwArgumentError(\"access list expected to be [ address, storageKeys[] ]\", `value[${ index }]`, set);\n                }\n                return accessSetify(set[0], set[1])\n            }\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n\n    const result: Array<{ address: string, storageKeys: Array<string> }> = Object.keys(value).map((addr) => {\n        const storageKeys: Record<string, true> = value[addr].reduce((accum, storageKey) => {\n            accum[storageKey] = true;\n            return accum;\n        }, <Record<string, true>>{ });\n        return accessSetify(addr, Object.keys(storageKeys).sort())\n    });\n    result.sort((a, b) => (a.address.localeCompare(b.address)));\n    return result;\n}\n\nfunction formatAccessList(value: AccessListish): Array<[ string, Array<string> ]> {\n    return accessListify(value).map((set) => [ set.address, set.storageKeys ]);\n}\n\nfunction _serializeEip1559(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    // If there is an explicit gasPrice, make sure it matches the\n    // EIP-1559 fees; otherwise they may not understand what they\n    // think they are setting in terms of fee.\n    if (transaction.gasPrice != null) {\n        const gasPrice = BigNumber.from(transaction.gasPrice);\n        const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);\n        if (!gasPrice.eq(maxFeePerGas)) {\n            logger.throwArgumentError(\"mismatch EIP-1559 gasPrice != maxFeePerGas\", \"tx\", {\n                gasPrice, maxFeePerGas\n            });\n        }\n    }\n\n    const fields: any = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(transaction.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to): \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n\n    return hexConcat([ \"0x02\", RLP.encode(fields)]);\n}\n\nfunction _serializeEip2930(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    const fields: any = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.gasPrice || 0, \"gasPrice\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to): \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n\n    return hexConcat([ \"0x01\", RLP.encode(fields)]);\n}\n\n// Legacy Transactions and EIP-155\nfunction _serialize(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    checkProperties(transaction, allowedTransactionKeys);\n\n    const raw: Array<string | Uint8Array> = [];\n\n    transactionFields.forEach(function(fieldInfo) {\n        let value = (<any>transaction)[fieldInfo.name] || ([]);\n        const options: DataOptions = { };\n        if (fieldInfo.numeric) { options.hexPad = \"left\"; }\n        value = arrayify(hexlify(value, options));\n\n        // Fixed-width field\n        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n            logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n        }\n\n        // Variable-width (with a maximum)\n        if (fieldInfo.maxLength) {\n            value = stripZeros(value);\n            if (value.length > fieldInfo.maxLength) {\n                logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value );\n            }\n        }\n\n        raw.push(hexlify(value));\n    });\n\n    let chainId = 0;\n    if (transaction.chainId != null) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = transaction.chainId;\n\n        if (typeof(chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\n        }\n\n    } else if (signature && !isBytesLike(signature) && signature.v > 28) {\n        // No chainId provided, but the signature is signing with EIP-155; derive chainId\n        chainId = Math.floor((signature.v - 35) / 2);\n    }\n\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\n    if (chainId !== 0) {\n        raw.push(hexlify(chainId)); // @TODO: hexValue?\n        raw.push(\"0x\");\n        raw.push(\"0x\");\n    }\n\n    // Requesting an unsigned transaction\n    if (!signature) {\n        return RLP.encode(raw);\n    }\n\n    // The splitSignature will ensure the transaction has a recoveryParam in the\n    // case that the signTransaction function only adds a v.\n    const sig = splitSignature(signature);\n\n    // We pushed a chainId and null r, s on for hashing only; remove those\n    let v = 27 + sig.recoveryParam\n    if (chainId !== 0) {\n        raw.pop();\n        raw.pop();\n        raw.pop();\n        v += chainId * 2 + 8;\n\n        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\n        if (sig.v > 28 && sig.v !== v) {\n             logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n        }\n    } else if (sig.v !== v) {\n         logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n    }\n\n    raw.push(hexlify(v));\n    raw.push(stripZeros(arrayify(sig.r)));\n    raw.push(stripZeros(arrayify(sig.s)));\n\n    return RLP.encode(raw);\n}\n\nexport function serialize(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    // Legacy and EIP-155 Transactions\n    if (transaction.type == null || transaction.type === 0) {\n        if (transaction.accessList != null) {\n            logger.throwArgumentError(\"untyped transactions do not support accessList; include type: 1\", \"transaction\", transaction);\n        }\n        return _serialize(transaction, signature);\n    }\n\n    // Typed Transactions (EIP-2718)\n    switch (transaction.type) {\n        case 1:\n            return _serializeEip2930(transaction, signature);\n        case 2:\n            return _serializeEip1559(transaction, signature);\n        default:\n            break;\n    }\n\n    return logger.throwError(`unsupported transaction type: ${ transaction.type }`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"serializeTransaction\",\n        transactionType: transaction.type\n    });\n}\n\nfunction _parseEipSignature(tx: Transaction, fields: Array<string>, serialize: (tx: UnsignedTransaction) => string): void {\n    try {\n        const recid = handleNumber(fields[0]).toNumber();\n        if (recid !== 0 && recid !== 1) { throw new Error(\"bad recid\"); }\n        tx.v = recid;\n    } catch (error) {\n        logger.throwArgumentError(\"invalid v for transaction type: 1\", \"v\", fields[0]);\n    }\n\n    tx.r = hexZeroPad(fields[1], 32);\n    tx.s = hexZeroPad(fields[2], 32);\n\n    try {\n        const digest = keccak256(serialize(tx));\n        tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });\n    } catch (error) {\n        console.log(error);\n    }\n}\n\nfunction _parseEip1559(payload: Uint8Array): Transaction {\n    const transaction = RLP.decode(payload.slice(1));\n\n    if (transaction.length !== 9 && transaction.length !== 12) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 2\", \"payload\", hexlify(payload));\n    }\n\n    const maxPriorityFeePerGas = handleNumber(transaction[2]);\n    const maxFeePerGas = handleNumber(transaction[3]);\n    const tx: Transaction = {\n        type:                  2,\n        chainId:               handleNumber(transaction[0]).toNumber(),\n        nonce:                 handleNumber(transaction[1]).toNumber(),\n        maxPriorityFeePerGas:  maxPriorityFeePerGas,\n        maxFeePerGas:          maxFeePerGas,\n        gasPrice:              null,\n        gasLimit:              handleNumber(transaction[4]),\n        to:                    handleAddress(transaction[5]),\n        value:                 handleNumber(transaction[6]),\n        data:                  transaction[7],\n        accessList:            accessListify(transaction[8]),\n    };\n\n    // Unsigned EIP-1559 Transaction\n    if (transaction.length === 9) { return tx; }\n\n    tx.hash = keccak256(payload);\n\n    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);\n\n    return tx;\n}\n\nfunction _parseEip2930(payload: Uint8Array): Transaction {\n    const transaction = RLP.decode(payload.slice(1));\n\n    if (transaction.length !== 8 && transaction.length !== 11) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 1\", \"payload\", hexlify(payload));\n    }\n\n    const tx: Transaction = {\n        type:       1,\n        chainId:    handleNumber(transaction[0]).toNumber(),\n        nonce:      handleNumber(transaction[1]).toNumber(),\n        gasPrice:   handleNumber(transaction[2]),\n        gasLimit:   handleNumber(transaction[3]),\n        to:         handleAddress(transaction[4]),\n        value:      handleNumber(transaction[5]),\n        data:       transaction[6],\n        accessList: accessListify(transaction[7])\n    };\n\n    // Unsigned EIP-2930 Transaction\n    if (transaction.length === 8) { return tx; }\n\n    tx.hash = keccak256(payload);\n\n    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);\n\n    return tx;\n}\n\n// Legacy Transactions and EIP-155\nfunction _parse(rawTransaction: Uint8Array): Transaction {\n    const transaction = RLP.decode(rawTransaction);\n\n    if (transaction.length !== 9 && transaction.length !== 6) {\n        logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\n    }\n\n    const tx: Transaction = {\n        nonce:    handleNumber(transaction[0]).toNumber(),\n        gasPrice: handleNumber(transaction[1]),\n        gasLimit: handleNumber(transaction[2]),\n        to:       handleAddress(transaction[3]),\n        value:    handleNumber(transaction[4]),\n        data:     transaction[5],\n        chainId:  0\n    };\n\n    // Legacy unsigned transaction\n    if (transaction.length === 6) { return tx; }\n\n    try {\n        tx.v = BigNumber.from(transaction[6]).toNumber();\n\n    } catch (error) {\n        console.log(error);\n        return tx;\n    }\n\n    tx.r = hexZeroPad(transaction[7], 32);\n    tx.s = hexZeroPad(transaction[8], 32);\n\n    if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {\n        // EIP-155 unsigned transaction\n        tx.chainId = tx.v;\n        tx.v = 0;\n\n    } else {\n        // Signed Transaction\n\n        tx.chainId = Math.floor((tx.v - 35) / 2);\n        if (tx.chainId < 0) { tx.chainId = 0; }\n\n        let recoveryParam = tx.v - 27;\n\n        const raw = transaction.slice(0, 6);\n\n        if (tx.chainId !== 0) {\n            raw.push(hexlify(tx.chainId));\n            raw.push(\"0x\");\n            raw.push(\"0x\");\n            recoveryParam -= tx.chainId * 2 + 8;\n        }\n\n        const digest = keccak256(RLP.encode(raw));\n        try {\n            tx.from = recoverAddress(digest, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam: recoveryParam });\n        } catch (error) {\n            console.log(error);\n        }\n\n        tx.hash = keccak256(rawTransaction);\n    }\n\n    tx.type = null;\n\n    return tx;\n}\n\n\nexport function parse(rawTransaction: BytesLike): Transaction {\n    const payload = arrayify(rawTransaction);\n\n    // Legacy and EIP-155 Transactions\n    if (payload[0] > 0x7f) { return _parse(payload); }\n\n    // Typed Transaction (EIP-2718)\n    switch (payload[0]) {\n        case 1:\n            return _parseEip2930(payload);\n        case 2:\n            return _parseEip1559(payload);\n        default:\n            break;\n    }\n\n    return logger.throwError(`unsupported transaction type: ${ payload[0] }`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"parseTransaction\",\n        transactionType: payload[0]\n    });\n}\n\n","export const version = \"providers/5.5.0\";\n","\"use strict\";\n\nimport { Block, TransactionReceipt, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { hexDataLength, hexDataSlice, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { AccessList, accessListify, parse as parseTransaction } from \"@ethersproject/transactions\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport type FormatFunc = (value: any) => any;\n\nexport type FormatFuncs = { [ key: string ]: FormatFunc };\n\nexport type Formats = {\n    transaction: FormatFuncs,\n    transactionRequest: FormatFuncs,\n    receipt: FormatFuncs,\n    receiptLog: FormatFuncs,\n    block: FormatFuncs,\n    blockWithTransactions: FormatFuncs,\n    filter: FormatFuncs,\n    filterLog: FormatFuncs,\n};\n\nexport class Formatter {\n    readonly formats: Formats;\n\n    constructor() {\n        logger.checkNew(new.target, Formatter);\n        this.formats = this.getDefaultFormats();\n    }\n\n    getDefaultFormats(): Formats {\n        const formats: Formats = <Formats>({ });\n\n        const address = this.address.bind(this);\n        const bigNumber = this.bigNumber.bind(this);\n        const blockTag = this.blockTag.bind(this);\n        const data = this.data.bind(this);\n        const hash = this.hash.bind(this);\n        const hex = this.hex.bind(this);\n        const number = this.number.bind(this);\n        const type = this.type.bind(this);\n\n        const strictData = (v: any) => { return this.data(v, true); };\n\n        formats.transaction = {\n            hash: hash,\n\n            type: type,\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n\n            blockHash: Formatter.allowNull(hash, null),\n            blockNumber: Formatter.allowNull(number, null),\n            transactionIndex: Formatter.allowNull(number, null),\n\n            confirmations: Formatter.allowNull(number, null),\n\n            from: address,\n\n            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)\n            // must be set\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n\n            gasLimit: bigNumber,\n            to: Formatter.allowNull(address, null),\n            value: bigNumber,\n            nonce: number,\n            data: data,\n\n            r: Formatter.allowNull(this.uint256),\n            s: Formatter.allowNull(this.uint256),\n            v: Formatter.allowNull(number),\n\n            creates: Formatter.allowNull(address, null),\n\n            raw: Formatter.allowNull(data),\n        };\n\n        formats.transactionRequest = {\n            from: Formatter.allowNull(address),\n            nonce: Formatter.allowNull(number),\n            gasLimit: Formatter.allowNull(bigNumber),\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            to: Formatter.allowNull(address),\n            value: Formatter.allowNull(bigNumber),\n            data: Formatter.allowNull(strictData),\n            type: Formatter.allowNull(number),\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n        };\n\n        formats.receiptLog = {\n            transactionIndex: number,\n            blockNumber: number,\n            transactionHash: hash,\n            address: address,\n            topics: Formatter.arrayOf(hash),\n            data: data,\n            logIndex: number,\n            blockHash: hash,\n        };\n\n        formats.receipt = {\n            to: Formatter.allowNull(this.address, null),\n            from: Formatter.allowNull(this.address, null),\n            contractAddress: Formatter.allowNull(address, null),\n            transactionIndex: number,\n            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n            root: Formatter.allowNull(hex),\n            gasUsed: bigNumber,\n            logsBloom: Formatter.allowNull(data),// @TODO: should this be data?\n            blockHash: hash,\n            transactionHash: hash,\n            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n            blockNumber: number,\n            confirmations: Formatter.allowNull(number, null),\n            cumulativeGasUsed: bigNumber,\n            effectiveGasPrice: Formatter.allowNull(bigNumber),\n            status: Formatter.allowNull(number),\n            type: type\n        };\n\n        formats.block = {\n            hash: hash,\n            parentHash: hash,\n            number: number,\n\n            timestamp: number,\n            nonce: Formatter.allowNull(hex),\n            difficulty: this.difficulty.bind(this),\n\n            gasLimit: bigNumber,\n            gasUsed: bigNumber,\n\n            miner: address,\n            extraData: data,\n\n            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n\n            baseFeePerGas: Formatter.allowNull(bigNumber)\n        };\n\n        formats.blockWithTransactions = shallowCopy(formats.block);\n        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n\n        formats.filter = {\n            fromBlock: Formatter.allowNull(blockTag, undefined),\n            toBlock: Formatter.allowNull(blockTag, undefined),\n            blockHash: Formatter.allowNull(hash, undefined),\n            address: Formatter.allowNull(address, undefined),\n            topics: Formatter.allowNull(this.topics.bind(this), undefined),\n        };\n\n        formats.filterLog = {\n            blockNumber: Formatter.allowNull(number),\n            blockHash: Formatter.allowNull(hash),\n            transactionIndex: number,\n\n            removed: Formatter.allowNull(this.boolean.bind(this)),\n\n            address: address,\n            data: Formatter.allowFalsish(data, \"0x\"),\n\n            topics: Formatter.arrayOf(hash),\n\n            transactionHash: hash,\n            logIndex: number,\n        };\n\n        return formats;\n    }\n\n    accessList(accessList: Array<any>): AccessList {\n        return accessListify(accessList || []);\n    }\n\n    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n    // Strict! Used on input.\n    number(number: any): number {\n        if (number === \"0x\") { return 0; }\n        return BigNumber.from(number).toNumber();\n    }\n\n    type(number: any): number {\n        if (number === \"0x\" || number == null) { return 0; }\n        return BigNumber.from(number).toNumber();\n    }\n\n    // Strict! Used on input.\n    bigNumber(value: any): BigNumber {\n        return BigNumber.from(value);\n    }\n\n    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n    boolean(value: any): boolean {\n        if (typeof(value) === \"boolean\") { return value; }\n        if (typeof(value) === \"string\") {\n            value = value.toLowerCase();\n            if (value === \"true\") { return true; }\n            if (value === \"false\") { return false; }\n        }\n        throw new Error(\"invalid boolean - \" + value);\n    }\n\n    hex(value: any, strict?: boolean): string {\n        if (typeof(value) === \"string\") {\n            if (!strict && value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n            if (isHexString(value)) {\n               return value.toLowerCase();\n            }\n        }\n        return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n    }\n\n    data(value: any, strict?: boolean): string {\n        const result = this.hex(value, strict);\n        if ((result.length % 2) !== 0) {\n            throw new Error(\"invalid data; odd-length - \" + value);\n        }\n        return result;\n    }\n\n    // Requires an address\n    // Strict! Used on input.\n    address(value: any): string {\n        return getAddress(value);\n    }\n\n    callAddress(value: any): string {\n        if (!isHexString(value, 32)) { return null; }\n        const address = getAddress(hexDataSlice(value, 12));\n        return (address === AddressZero) ? null: address;\n    }\n\n    contractAddress(value: any): string {\n        return getContractAddress(value);\n    }\n\n    // Strict! Used on input.\n    blockTag(blockTag: any): string {\n        if (blockTag == null) { return \"latest\"; }\n\n        if (blockTag === \"earliest\") { return \"0x0\"; }\n\n        if (blockTag === \"latest\" || blockTag === \"pending\") {\n            return blockTag;\n        }\n\n        if (typeof(blockTag) === \"number\" || isHexString(blockTag)) {\n            return hexValue(<number | string>blockTag);\n        }\n\n        throw new Error(\"invalid blockTag\");\n    }\n\n    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n    hash(value: any, strict?: boolean): string {\n        const result = this.hex(value, strict);\n        if (hexDataLength(result) !== 32) {\n            return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n        }\n        return result;\n    }\n\n    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n    difficulty(value: any): number {\n        if (value == null) { return null; }\n\n        const v = BigNumber.from(value);\n\n        try {\n            return v.toNumber();\n        } catch (error) { }\n\n       return null;\n    }\n\n    uint256(value: any): string {\n        if (!isHexString(value)) {\n            throw new Error(\"invalid uint256\");\n        }\n        return hexZeroPad(value, 32);\n    }\n\n    _block(value: any, format: any): Block {\n        if (value.author != null && value.miner == null) {\n            value.miner = value.author;\n        }\n        // The difficulty may need to come from _difficulty in recursed blocks\n        const difficulty = (value._difficulty != null) ? value._difficulty: value.difficulty;\n        const result = Formatter.check(format, value);\n        result._difficulty = ((difficulty == null) ? null: BigNumber.from(difficulty));\n        return result;\n    }\n\n    block(value: any): Block {\n        return this._block(value, this.formats.block);\n    }\n\n    blockWithTransactions(value: any): Block {\n        return this._block(value, this.formats.blockWithTransactions);\n    }\n\n    // Strict! Used on input.\n    transactionRequest(value: any): any {\n        return Formatter.check(this.formats.transactionRequest, value);\n    }\n\n    transactionResponse(transaction: any): TransactionResponse {\n\n        // Rename gas to gasLimit\n        if (transaction.gas != null && transaction.gasLimit == null) {\n            transaction.gasLimit = transaction.gas;\n        }\n\n        // Some clients (TestRPC) do strange things like return 0x0 for the\n        // 0 address; correct this to be a real address\n        if (transaction.to && BigNumber.from(transaction.to).isZero()) {\n            transaction.to = \"0x0000000000000000000000000000000000000000\";\n        }\n\n        // Rename input to data\n        if (transaction.input != null && transaction.data == null) {\n            transaction.data = transaction.input;\n        }\n\n        // If to and creates are empty, populate the creates from the transaction\n        if (transaction.to == null && transaction.creates == null) {\n            transaction.creates = this.contractAddress(transaction);\n        }\n\n        if ((transaction.type === 1 || transaction.type === 2)&& transaction.accessList == null) {\n            transaction.accessList = [ ];\n        }\n\n        const result: TransactionResponse = Formatter.check(this.formats.transaction, transaction);\n\n        if (transaction.chainId != null) {\n            let chainId = transaction.chainId;\n\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n\n            result.chainId = chainId;\n\n        } else {\n            let chainId = transaction.networkId;\n\n            // geth-etc returns chainId\n            if (chainId == null && result.v == null) {\n                chainId = transaction.chainId;\n            }\n\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n\n            if (typeof(chainId) !== \"number\" && result.v != null) {\n                chainId = (result.v - 35) / 2;\n                if (chainId < 0) { chainId = 0; }\n                chainId = parseInt(chainId);\n            }\n\n            if (typeof(chainId) !== \"number\") { chainId = 0; }\n\n            result.chainId = chainId;\n        }\n\n        // 0x0000... should actually be null\n        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n            result.blockHash = null;\n        }\n\n        return result;\n    }\n\n    transaction(value: any): any {\n        return parseTransaction(value);\n    }\n\n    receiptLog(value: any): any {\n        return Formatter.check(this.formats.receiptLog, value);\n    }\n\n    receipt(value: any): TransactionReceipt {\n        const result: TransactionReceipt = Formatter.check(this.formats.receipt, value);\n\n        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\n        if (result.root != null) {\n            if (result.root.length <= 4) {\n                // Could be 0x00, 0x0, 0x01 or 0x1\n                const value = BigNumber.from(result.root).toNumber();\n                if (value === 0 || value === 1) {\n                    // Make sure if both are specified, they match\n                    if (result.status != null && (result.status !== value)) {\n                        logger.throwArgumentError(\"alt-root-status/status mismatch\", \"value\", { root: result.root, status: result.status });\n                    }\n                    result.status = value;\n                    delete result.root;\n                } else {\n                    logger.throwArgumentError(\"invalid alt-root-status\", \"value.root\", result.root);\n                }\n            } else if (result.root.length !== 66) {\n                // Must be a valid bytes32\n                logger.throwArgumentError(\"invalid root hash\", \"value.root\", result.root);\n            }\n        }\n\n        if (result.status != null) {\n            result.byzantium = true;\n        }\n\n        return result;\n    }\n\n    topics(value: any): any {\n        if (Array.isArray(value)) {\n            return value.map((v) => this.topics(v));\n\n        } else if (value != null) {\n            return this.hash(value, true);\n        }\n\n        return null;\n    }\n\n    filter(value: any): any {\n        return Formatter.check(this.formats.filter, value);\n    }\n\n    filterLog(value: any): any {\n        return Formatter.check(this.formats.filterLog, value);\n    }\n\n    static check(format: { [ name: string ]: FormatFunc }, object: any): any {\n        const result: any = {};\n        for (const key in format) {\n            try {\n                const value = format[key](object[key]);\n                if (value !== undefined) { result[key] = value; }\n            } catch (error) {\n                error.checkKey = key;\n                error.checkValue = object[key];\n                throw error;\n            }\n        }\n        return result;\n    }\n\n    // if value is null-ish, nullValue is returned\n    static allowNull(format: FormatFunc, nullValue?: any): FormatFunc {\n        return (function(value: any) {\n            if (value == null) { return nullValue; }\n            return format(value);\n        });\n    }\n\n    // If value is false-ish, replaceValue is returned\n    static allowFalsish(format: FormatFunc, replaceValue: any): FormatFunc {\n        return (function(value: any) {\n            if (!value) { return replaceValue; }\n            return format(value);\n        });\n    }\n\n    // Requires an Array satisfying check\n    static arrayOf(format: FormatFunc): FormatFunc {\n        return (function(array: any): Array<any> {\n            if (!Array.isArray(array)) { throw new Error(\"not an array\"); }\n\n            const result: any = [];\n\n            array.forEach(function(value) {\n                result.push(format(value));\n            });\n\n            return result;\n        });\n    }\n}\n\nexport interface CommunityResourcable {\n    isCommunityResource(): boolean;\n}\n\nexport function isCommunityResourcable(value: any): value is CommunityResourcable {\n    return (value && typeof(value.isCommunityResource) === \"function\");\n}\n\nexport function isCommunityResource(value: any): boolean {\n    return (isCommunityResourcable(value) && value.isCommunityResource());\n}\n\n// Show the throttle message only once\nlet throttleMessage = false;\nexport function showThrottleMessage() {\n    if (throttleMessage) { return; }\n    throttleMessage = true;\n\n    console.log(\"========= NOTICE =========\")\n    console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https:/\\/docs.ethers.io/api-keys/\");\n    console.log(\"==========================\");\n}\n\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n\nexport enum UnicodeNormalizationForm {\n    current  = \"\",\n    NFC      = \"NFC\",\n    NFD      = \"NFD\",\n    NFKC     = \"NFKC\",\n    NFKD     = \"NFKD\"\n};\n\nexport enum Utf8ErrorReason {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    UNEXPECTED_CONTINUE   = \"unexpected continuation byte\",\n\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    BAD_PREFIX            = \"bad codepoint prefix\",\n\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    OVERRUN               = \"string overrun\",\n\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    MISSING_CONTINUE      = \"missing continuation byte\",\n\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    OUT_OF_RANGE          = \"out of UTF-8 range\",\n\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    UTF16_SURROGATE       = \"UTF-16 surrogate\",\n\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    OVERLONG              = \"overlong representation\",\n};\n\n\nexport type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number) => number;\n\nfunction errorFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n    return logger.throwArgumentError(`invalid codepoint at offset ${ offset }; ${ reason }`, \"bytes\", bytes);\n}\n\nfunction ignoreFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) { break; }\n            i++;\n        }\n        return i;\n    }\n\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n\n    // Nothing to skip\n    return 0;\n}\n\nfunction replaceFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n\n    // Put the replacement character into the output\n    output.push(0xfffd);\n\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n\n// Common error handing strategies\nexport const Utf8ErrorFuncs: { [ name: string ]: Utf8ErrorFunc } = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes: BytesLike, onError?: Utf8ErrorFunc): Array<number> {\n    if (onError == null) { onError = Utf8ErrorFuncs.error; }\n\n    bytes = arrayify(bytes);\n\n    const result: Array<number> = [];\n    let i = 0;\n\n    // Invalid bytes are ignored\n    while(i < bytes.length) {\n\n        const c = bytes[i++];\n\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            } else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            };\n\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n\n        // See above loop for invalid continuation byte\n        if (res === null) { continue; }\n\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        result.push(res);\n    }\n\n    return result;\n}\n\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nexport function toUtf8Bytes(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Uint8Array {\n\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n\n        if (c < 0x80) {\n            result.push(c);\n\n        } else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n\n        } else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n\n    return arrayify(result);\n};\n\nfunction escapeChar(value: number) {\n    const hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\n\nexport function _toEscapedUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8:  return \"\\\\b\";\n                case 9:  return \"\\\\t\";\n                case 10: return \"\\\\n\"\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\n\nexport function _toUtf8String(codePoints: Array<number>): string {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode(\n            (((codePoint >> 10) & 0x3ff) + 0xd800),\n            ((codePoint & 0x3ff) + 0xdc00)\n        );\n    }).join(\"\");\n}\n\nexport function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n\nexport function toUtf8CodePoints(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n","\"use strict\";\n\nimport { BlockTag, FeeData, Provider, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { Bytes, BytesLike } from \"@ethersproject/bytes\";\nimport { Deferrable, defineReadOnly, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst allowedTransactionKeys: Array<string> = [\n    \"accessList\", \"ccipReadEnabled\", \"chainId\", \"customData\", \"data\", \"from\", \"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"to\", \"type\", \"value\"\n];\n\nconst forwardErrors = [\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n];\n\n// EIP-712 Typed Data\n// See: https://eips.ethereum.org/EIPS/eip-712\n\nexport interface TypedDataDomain {\n    name?: string;\n    version?: string;\n    chainId?: BigNumberish;\n    verifyingContract?: string;\n    salt?: BytesLike;\n};\n\nexport interface TypedDataField {\n    name: string;\n    type: string;\n};\n\n// Sub-classes of Signer may optionally extend this interface to indicate\n// they have a private key available synchronously\nexport interface ExternallyOwnedAccount {\n    readonly address: string;\n    readonly privateKey: string;\n}\n\n// Sub-Class Notes:\n//  - A Signer MUST always make sure, that if present, the \"from\" field\n//    matches the Signer, before sending or signing a transaction\n//  - A Signer SHOULD always wrap private information (such as a private\n//    key or mnemonic) in a function, so that console.log does not leak\n//    the data\n\n// @TODO: This is a temporary measure to preserve backwards compatibility\n//        In v6, the method on TypedDataSigner will be added to Signer\nexport interface TypedDataSigner {\n    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string>;\n}\n\nexport abstract class Signer {\n    readonly provider?: Provider;\n\n    ///////////////////\n    // Sub-classes MUST implement these\n\n    // Returns the checksum address\n    abstract getAddress(): Promise<string>\n\n    // Returns the signed prefixed-message. This MUST treat:\n    // - Bytes as a binary message\n    // - string as a UTF8-message\n    // i.e. \"0x1234\" is a SIX (6) byte string, NOT 2 bytes of data\n    abstract signMessage(message: Bytes | string): Promise<string>;\n\n    // Signs a transaction and returns the fully serialized, signed transaction.\n    // The EXACT transaction MUST be signed, and NO additional properties to be added.\n    // - This MAY throw if signing transactions is not supports, but if\n    //   it does, sentTransaction MUST be overridden.\n    abstract signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>;\n\n    // Returns a new instance of the Signer, connected to provider.\n    // This MAY throw if changing providers is not supported.\n    abstract connect(provider: Provider): Signer;\n\n    readonly _isSigner: boolean;\n\n\n    ///////////////////\n    // Sub-classes MUST call super\n    constructor() {\n        logger.checkAbstract(new.target, Signer);\n        defineReadOnly(this, \"_isSigner\", true);\n    }\n\n\n    ///////////////////\n    // Sub-classes MAY override these\n\n    async getBalance(blockTag?: BlockTag): Promise<BigNumber> {\n        this._checkProvider(\"getBalance\");\n        return await this.provider.getBalance(this.getAddress(), blockTag);\n    }\n\n    async getTransactionCount(blockTag?: BlockTag): Promise<number> {\n        this._checkProvider(\"getTransactionCount\");\n        return await this.provider.getTransactionCount(this.getAddress(), blockTag);\n    }\n\n    // Populates \"from\" if unspecified, and estimates the gas for the transaction\n    async estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber> {\n        this._checkProvider(\"estimateGas\");\n        const tx = await resolveProperties(this.checkTransaction(transaction));\n        return await this.provider.estimateGas(tx);\n    }\n\n    // Populates \"from\" if unspecified, and calls with the transaction\n    async call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag): Promise<string> {\n        this._checkProvider(\"call\");\n        const tx = await resolveProperties(this.checkTransaction(transaction));\n        return await this.provider.call(tx, blockTag);\n    }\n\n    // Populates all fields in a transaction, signs it and sends it to the network\n    async sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        this._checkProvider(\"sendTransaction\");\n        const tx = await this.populateTransaction(transaction);\n        const signedTx = await this.signTransaction(tx);\n        return await this.provider.sendTransaction(signedTx);\n    }\n\n    async getChainId(): Promise<number> {\n        this._checkProvider(\"getChainId\");\n        const network = await this.provider.getNetwork();\n        return network.chainId;\n    }\n\n    async getGasPrice(): Promise<BigNumber> {\n        this._checkProvider(\"getGasPrice\");\n        return await this.provider.getGasPrice();\n    }\n\n    async getFeeData(): Promise<FeeData> {\n        this._checkProvider(\"getFeeData\");\n        return await this.provider.getFeeData();\n    }\n\n\n    async resolveName(name: string): Promise<string> {\n        this._checkProvider(\"resolveName\");\n        return await this.provider.resolveName(name);\n    }\n\n\n\n    // Checks a transaction does not contain invalid keys and if\n    // no \"from\" is provided, populates it.\n    // - does NOT require a provider\n    // - adds \"from\" is not present\n    // - returns a COPY (safe to mutate the result)\n    // By default called from: (overriding these prevents it)\n    //   - call\n    //   - estimateGas\n    //   - populateTransaction (and therefor sendTransaction)\n    checkTransaction(transaction: Deferrable<TransactionRequest>): Deferrable<TransactionRequest> {\n        for (const key in transaction) {\n            if (allowedTransactionKeys.indexOf(key) === -1) {\n                logger.throwArgumentError(\"invalid transaction key: \" + key, \"transaction\", transaction);\n            }\n        }\n\n        const tx = shallowCopy(transaction);\n\n        if (tx.from == null) {\n            tx.from = this.getAddress();\n\n        } else {\n            // Make sure any provided address matches this signer\n            tx.from = Promise.all([\n                Promise.resolve(tx.from),\n                this.getAddress()\n            ]).then((result) => {\n                if (result[0].toLowerCase() !== result[1].toLowerCase()) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n                return result[0];\n            });\n        }\n\n        return tx;\n    }\n\n    // Populates ALL keys for a transaction and checks that \"from\" matches\n    // this Signer. Should be used by sendTransaction but NOT by signTransaction.\n    // By default called from: (overriding these prevents it)\n    //   - sendTransaction\n    //\n    // Notes:\n    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas\n    async populateTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionRequest> {\n\n        const tx: Deferrable<TransactionRequest> = await resolveProperties(this.checkTransaction(transaction))\n\n        if (tx.to != null) {\n            tx.to = Promise.resolve(tx.to).then(async (to) => {\n                if (to == null) { return null; }\n                const address = await this.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            });\n\n            // Prevent this error from causing an UnhandledPromiseException\n            tx.to.catch((error) => {  });\n        }\n\n        // Do not allow mixing pre-eip-1559 and eip-1559 properties\n        const hasEip1559 = (tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null);\n        if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {\n            logger.throwArgumentError(\"eip-1559 transaction do not support gasPrice\", \"transaction\", transaction);\n        } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {\n            logger.throwArgumentError(\"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"transaction\", transaction);\n        }\n\n        if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {\n            // Fully-formed EIP-1559 transaction (skip getFeeData)\n            tx.type = 2;\n\n        } else if (tx.type === 0 || tx.type === 1) {\n            // Explicit Legacy or EIP-2930 transaction\n\n            // Populate missing gasPrice\n            if (tx.gasPrice == null) { tx.gasPrice = this.getGasPrice(); }\n\n        } else {\n\n            // We need to get fee data to determine things\n            const feeData = await this.getFeeData();\n\n            if (tx.type == null) {\n                // We need to auto-detect the intended type of this transaction...\n\n                if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                    // The network supports EIP-1559!\n\n                    // Upgrade transaction from null to eip-1559\n                    tx.type = 2;\n\n                    if (tx.gasPrice != null) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        const gasPrice = tx.gasPrice;\n                        delete tx.gasPrice;\n                        tx.maxFeePerGas = gasPrice;\n                        tx.maxPriorityFeePerGas = gasPrice;\n\n                    } else {\n                        // Populate missing fee data\n                        if (tx.maxFeePerGas == null) { tx.maxFeePerGas = feeData.maxFeePerGas; }\n                        if (tx.maxPriorityFeePerGas == null) { tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas; }\n                    }\n\n                } else if (feeData.gasPrice != null) {\n                    // Network doesn't support EIP-1559...\n\n                    // ...but they are trying to use EIP-1559 properties\n                    if (hasEip1559) {\n                        logger.throwError(\"network does not support EIP-1559\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            operation: \"populateTransaction\"\n                        });\n                    }\n\n                    // Populate missing fee data\n                    if (tx.gasPrice == null) { tx.gasPrice = feeData.gasPrice; }\n\n                    // Explicitly set untyped transaction to legacy\n                    tx.type = 0;\n\n                } else {\n                    // getFeeData has failed us.\n                    logger.throwError(\"failed to get consistent fee data\", Logger.errors.UNSUPPORTED_OPERATION, {\n                        operation: \"signer.getFeeData\"\n                    });\n                }\n\n            } else if (tx.type === 2) {\n                // Explicitly using EIP-1559\n\n                // Populate missing fee data\n                if (tx.maxFeePerGas == null) { tx.maxFeePerGas = feeData.maxFeePerGas; }\n                if (tx.maxPriorityFeePerGas == null) { tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas; }\n            }\n        }\n\n        if (tx.nonce == null) { tx.nonce = this.getTransactionCount(\"pending\"); }\n\n        if (tx.gasLimit == null) {\n            tx.gasLimit = this.estimateGas(tx).catch((error) => {\n                if (forwardErrors.indexOf(error.code) >= 0) {\n                    throw error;\n                }\n\n                return logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                    error: error,\n                    tx: tx\n                });\n            });\n        }\n\n        if (tx.chainId == null) {\n            tx.chainId = this.getChainId();\n        } else {\n            tx.chainId = Promise.all([\n                Promise.resolve(tx.chainId),\n                this.getChainId()\n            ]).then((results) => {\n                if (results[1] !== 0 && results[0] !== results[1]) {\n                    logger.throwArgumentError(\"chainId address mismatch\", \"transaction\", transaction);\n                }\n                return results[0];\n            });\n        }\n\n        return await resolveProperties(tx);\n    }\n\n\n    ///////////////////\n    // Sub-classes SHOULD leave these alone\n\n    _checkProvider(operation?: string): void {\n        if (!this.provider) { logger.throwError(\"missing provider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: (operation || \"_checkProvider\") });\n        }\n    }\n\n    static isSigner(value: any): value is Signer {\n        return !!(value && value._isSigner);\n    }\n}\n\nexport class VoidSigner extends Signer implements TypedDataSigner {\n    readonly address: string;\n\n    constructor(address: string, provider?: Provider) {\n        logger.checkNew(new.target, VoidSigner);\n        super();\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"provider\", provider || null);\n    }\n\n    getAddress(): Promise<string> {\n        return Promise.resolve(this.address);\n    }\n\n    _fail(message: string, operation: string): Promise<any> {\n        return Promise.resolve().then(() => {\n            logger.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation: operation });\n        });\n    }\n\n    signMessage(message: Bytes | string): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign messages\", \"signMessage\");\n    }\n\n    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign transactions\", \"signTransaction\");\n    }\n\n    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign typed data\", \"signTypedData\");\n    }\n\n    connect(provider: Provider): VoidSigner {\n        return new VoidSigner(this.address, provider);\n    }\n}\n\n","export const version = \"abstract-signer/5.6.0\";\n","export const version = \"hash/5.6.0\";\n","export const version = \"strings/5.6.0\";\n","import { keccak256 } from \"@ethersproject/keccak256\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nexport function id(text: string): string {\n    return keccak256(toUtf8Bytes(text));\n}\n","import { TypedDataDomain, TypedDataField } from \"@ethersproject/abstract-signer\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, hexConcat, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { id } from \"./id\";\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\n\nconst NegativeOne: BigNumber = BigNumber.from(-1);\nconst Zero: BigNumber = BigNumber.from(0);\nconst One: BigNumber = BigNumber.from(1);\nconst MaxUint256: BigNumber = BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\nfunction hexPadRight(value: BytesLike) {\n    const bytes = arrayify(value);\n    const padOffset = bytes.length % 32\n    if (padOffset) {\n        return hexConcat([ bytes, padding.slice(padOffset) ]);\n    }\n    return hexlify(bytes);\n}\n\nconst hexTrue = hexZeroPad(One.toHexString(), 32);\nconst hexFalse = hexZeroPad(Zero.toHexString(), 32);\n\nconst domainFieldTypes: Record<string, string> = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\n\nconst domainFieldNames: Array<string> = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\n\nfunction checkString(key: string): (value: any) => string {\n    return function (value: any){\n        if (typeof(value) !== \"string\") {\n            logger.throwArgumentError(`invalid domain value for ${ JSON.stringify(key) }`, `domain.${ key }`, value);\n        }\n        return value;\n    }\n}\n\nconst domainChecks: Record<string, (value: any) => any> = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function(value: any) {\n        try {\n            return BigNumber.from(value).toString()\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value for \"chainId\"`, \"domain.chainId\", value);\n    },\n    verifyingContract: function(value: any) {\n        try {\n            return getAddress(value).toLowerCase();\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function(value: any) {\n        try {\n            const bytes = arrayify(value);\n            if (bytes.length !== 32) { throw new Error(\"bad length\"); }\n            return hexlify(bytes);\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"salt\"`, \"domain.salt\", value);\n    }\n}\n\nfunction getBaseEncoder(type: string): (value: any) => string {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = (match[1] === \"\");\n\n            const width = parseInt(match[2] || \"256\");\n            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {\n                logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n            }\n\n            const boundsUpper = MaxUint256.mask(signed ? (width - 1): width);\n            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne): Zero;\n\n            return function(value: BigNumberish) {\n                const v = BigNumber.from(value);\n\n                if (v.lt(boundsLower) || v.gt(boundsUpper)) {\n                    logger.throwArgumentError(`value out-of-bounds for ${ type }`, \"value\", value);\n                }\n\n                return hexZeroPad(v.toTwos(256).toHexString(), 32);\n            };\n        }\n    }\n\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            if (width === 0 || width > 32 || match[1] !== String(width)) {\n                logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n            }\n\n            return function(value: BytesLike) {\n                const bytes = arrayify(value);\n                if (bytes.length !== width) {\n                    logger.throwArgumentError(`invalid length for ${ type }`, \"value\", value);\n                }\n                return hexPadRight(value);\n            };\n        }\n    }\n\n    switch (type) {\n        case \"address\": return function(value: string) {\n            return hexZeroPad(getAddress(value), 32);\n        };\n        case \"bool\": return function(value: boolean) {\n            return ((!value) ? hexFalse: hexTrue);\n        };\n        case \"bytes\": return function(value: BytesLike) {\n            return keccak256(value);\n        };\n        case \"string\": return function(value: string) {\n            return id(value);\n        };\n    }\n\n    return null;\n}\n\nfunction encodeType(name: string, fields: Array<TypedDataField>): string {\n    return `${ name }(${ fields.map(({ name, type }) => (type + \" \" + name)).join(\",\") })`;\n}\n\nexport class TypedDataEncoder {\n    readonly primaryType: string;\n    readonly types: Record<string, Array<TypedDataField>>;\n\n    readonly _encoderCache: Record<string, (value: any) => string>;\n    readonly _types: Record<string, string>;\n\n    constructor(types: Record<string, Array<TypedDataField>>) {\n        defineReadOnly(this, \"types\", Object.freeze(deepCopy(types)));\n\n        defineReadOnly(this, \"_encoderCache\", { });\n        defineReadOnly(this, \"_types\", { });\n\n        // Link struct types to their direct child structs\n        const links: Record<string, Record<string, boolean>> = { };\n\n        // Link structs to structs which contain them as a child\n        const parents: Record<string, Array<string>> = { };\n\n        // Link all subtypes within a given struct\n        const subtypes: Record<string, Record<string, boolean>> = { };\n\n        Object.keys(types).forEach((type) => {\n            links[type] = { };\n            parents[type] = [ ];\n            subtypes[type] = { }\n        });\n\n        for (const name in types) {\n\n            const uniqueNames: Record<string, boolean> = { };\n\n            types[name].forEach((field) => {\n\n                // Check each field has a unique name\n                if (uniqueNames[field.name]) {\n                    logger.throwArgumentError(`duplicate variable name ${ JSON.stringify(field.name) } in ${ JSON.stringify(name) }`, \"types\", types);\n                }\n                uniqueNames[field.name] = true;\n\n                // Get the base type (drop any array specifiers)\n                const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n                if (baseType === name) {\n                    logger.throwArgumentError(`circular type reference to ${ JSON.stringify(baseType) }`, \"types\", types);\n                }\n\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) { return ;}\n\n                if (!parents[baseType]) {\n                    logger.throwArgumentError(`unknown type ${ JSON.stringify(baseType) }`, \"types\", types);\n                }\n\n                // Add linkage\n                parents[baseType].push(name);\n                links[name][baseType] = true;\n            });\n        }\n\n        // Deduce the primary type\n        const primaryTypes = Object.keys(parents).filter((n) => (parents[n].length === 0));\n\n        if (primaryTypes.length === 0) {\n            logger.throwArgumentError(\"missing primary type\", \"types\", types);\n        } else if (primaryTypes.length > 1) {\n            logger.throwArgumentError(`ambiguous primary types or unused types: ${ primaryTypes.map((t) => (JSON.stringify(t))).join(\", \") }`, \"types\", types);\n        }\n\n        defineReadOnly(this, \"primaryType\", primaryTypes[0]);\n\n        // Check for circular type references\n        function checkCircular(type: string, found: Record<string, boolean>) {\n            if (found[type]) {\n                logger.throwArgumentError(`circular type reference to ${ JSON.stringify(type) }`, \"types\", types);\n            }\n\n            found[type] = true;\n\n            Object.keys(links[type]).forEach((child) => {\n                if (!parents[child]) { return; }\n\n                // Recursively check children\n                checkCircular(child, found);\n\n                // Mark all ancestors as having this decendant\n                Object.keys(found).forEach((subtype) => {\n                    subtypes[subtype][child] = true;\n                });\n            });\n\n            delete found[type];\n        }\n        checkCircular(this.primaryType, { });\n\n        // Compute each fully describe type\n        for (const name in subtypes) {\n            const st = Object.keys(subtypes[name]);\n            st.sort();\n            this._types[name] = encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\");\n        }\n    }\n\n    getEncoder(type: string): (value: any) => string {\n        let encoder = this._encoderCache[type];\n        if (!encoder) {\n            encoder = this._encoderCache[type] = this._getEncoder(type);\n        }\n        return encoder;\n    }\n\n    _getEncoder(type: string): (value: any) => string {\n\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return encoder; }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            const length = parseInt(match[3]);\n            return (value: Array<any>) => {\n                if (length >= 0 && value.length !== length) {\n                    logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n                }\n\n                let result = value.map(subEncoder);\n                if (this._types[subtype]) {\n                    result = result.map(keccak256);\n                }\n\n                return keccak256(hexConcat(result));\n            };\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = id(this._types[type]);\n            return (value: Record<string, any>) => {\n                const values = fields.map(({ name, type }) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this._types[type]) { return keccak256(result); }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return hexConcat(values);\n            }\n        }\n\n        return logger.throwArgumentError(`unknown type: ${ type }`, \"type\", type);\n    }\n\n    encodeType(name: string): string {\n        const result = this._types[name];\n        if (!result) {\n            logger.throwArgumentError(`unknown type: ${ JSON.stringify(name) }`, \"name\", name);\n        }\n        return result;\n    }\n\n    encodeData(type: string, value: any): string {\n        return this.getEncoder(type)(value);\n    }\n\n    hashStruct(name: string, value: Record<string, any>): string {\n        return keccak256(this.encodeData(name, value));\n    }\n\n    encode(value: Record<string, any>): string {\n        return this.encodeData(this.primaryType, value);\n    }\n\n    hash(value: Record<string, any>): string {\n        return this.hashStruct(this.primaryType, value);\n    }\n\n    _visit(type: string, value: any, callback: (type: string, data: any) => any): any {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return callback(type, value); }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const length = parseInt(match[3]);\n            if (length >= 0 && value.length !== length) {\n                logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n            }\n            return value.map((v: any) => this._visit(subtype, v, callback));\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type }) => {\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, <Record<string, any>>{});\n        }\n\n        return logger.throwArgumentError(`unknown type: ${ type }`, \"type\", type);\n    }\n\n    visit(value: Record<string, any>, callback: (type: string, data: any) => any): any {\n        return this._visit(this.primaryType, value, callback);\n    }\n\n    static from(types: Record<string, Array<TypedDataField>>): TypedDataEncoder {\n        return new TypedDataEncoder(types);\n    }\n\n    static getPrimaryType(types: Record<string, Array<TypedDataField>>): string {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n\n    static hashStruct(name: string, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n\n    static hashDomain(domain: TypedDataDomain): string {\n        const domainFields: Array<TypedDataField> = [ ];\n        for (const name in domain) {\n            const type = domainFieldTypes[name];\n            if (!type) {\n                logger.throwArgumentError(`invalid typed-data domain key: ${ JSON.stringify(name) }`, \"domain\", domain);\n            }\n            domainFields.push({ name, type });\n        }\n\n        domainFields.sort((a, b) => {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    }\n\n    static encode(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return hexConcat([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n\n    static hash(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return keccak256(TypedDataEncoder.encode(domain, types, value));\n    }\n\n    // Replaces all address types with ENS names with their looked up address\n    static async resolveNames(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, resolveName: (name: string) => Promise<string>): Promise<{ domain: TypedDataDomain, value: any }> {\n        // Make a copy to isolate it from the object passed in\n        domain = shallowCopy(domain);\n\n        // Look up all ENS names\n        const ensCache: Record<string, string> = { };\n\n        // Do we need to look up the domain's verifyingContract?\n        if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n            ensCache[domain.verifyingContract] = \"0x\";\n        }\n\n        // We are going to use the encoder to visit all the base values\n        const encoder = TypedDataEncoder.from(types);\n\n        // Get a list of all the addresses\n        encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && !isHexString(value, 20)) {\n                ensCache[value] = \"0x\";\n            }\n            return value;\n        });\n\n        // Lookup each name\n        for (const name in ensCache) {\n            ensCache[name] = await resolveName(name);\n        }\n\n        // Replace the domain verifyingContract if needed\n        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n            domain.verifyingContract = ensCache[domain.verifyingContract];\n        }\n\n        // Replace all ENS names with their address\n        value = encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && ensCache[value]) { return ensCache[value]; }\n            return value;\n        });\n\n        return { domain, value };\n    }\n\n    static getPayload(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): any {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n\n        // Derive the EIP712Domain Struct reference type\n        const domainValues: Record<string, any> = { };\n        const domainTypes: Array<{ name: string, type:string }> = [ ];\n\n        domainFieldNames.forEach((name) => {\n            const value = (<any>domain)[name];\n            if (value == null) { return; }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name, type: domainFieldTypes[name] });\n        });\n\n        const encoder = TypedDataEncoder.from(types);\n\n        const typesWithDomain = shallowCopy(types);\n        if (typesWithDomain.EIP712Domain) {\n            logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        } else {\n            typesWithDomain.EIP712Domain = domainTypes;\n        }\n\n        // Validate the data structures and types\n        encoder.encode(value);\n\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type: string, value: any) => {\n\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return hexlify(arrayify(value));\n                }\n\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return BigNumber.from(value).toString();\n                }\n\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        if (typeof(value) !== \"string\") {\n                            logger.throwArgumentError(`invalid string`, \"value\", value);\n                        }\n                        return value;\n                }\n\n                return logger.throwArgumentError(\"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function decode(textData: string): Uint8Array {\n    textData = atob(textData);\n    const data = [];\n    for (let i = 0; i < textData.length; i++) {\n        data.push(textData.charCodeAt(i));\n    }\n    return arrayify(data);\n}\n\nexport function encode(data: BytesLike): string {\n    data = arrayify(data);\n    let textData = \"\";\n    for (let i = 0; i < data.length; i++) {\n        textData += String.fromCharCode(data[i]);\n    }\n    return btoa(textData);\n}\n\n\n","export const version = \"web/5.6.0\";\n","\"use strict\";\n\nimport { arrayify } from \"@ethersproject/bytes\";\n\nimport type { GetUrlResponse, Options } from \"./types\";\n\nexport { GetUrlResponse, Options };\n\nexport async function getUrl(href: string, options?: Options): Promise<GetUrlResponse> {\n    if (options == null) { options = { }; }\n\n    const request: RequestInit = {\n        method: (options.method || \"GET\"),\n        headers: (options.headers || { }),\n        body: (options.body || undefined),\n    };\n\n    if (options.skipFetchSetup !== true) {\n        request.mode = <RequestMode>\"cors\";              // no-cors, cors, *same-origin\n        request.cache = <RequestCache>\"no-cache\";        // *default, no-cache, reload, force-cache, only-if-cached\n        request.credentials = <RequestCredentials>\"same-origin\";  // include, *same-origin, omit\n        request.redirect = <RequestRedirect>\"follow\";    // manual, *follow, error\n        request.referrer = \"client\";                     // no-referrer, *client\n    };\n\n    const response = await fetch(href, request);\n    const body = await response.arrayBuffer();\n\n    const headers: { [ name: string ]: string } = { };\n    if (response.headers.forEach) {\n        response.headers.forEach((value, key) => {\n            headers[key.toLowerCase()] = value;\n        });\n    } else {\n        (<() => Array<string>>((<any>(response.headers)).keys))().forEach((key) => {\n            headers[key.toLowerCase()] = response.headers.get(key);\n        });\n    }\n\n    return {\n        headers: headers,\n        statusCode: response.status,\n        statusMessage: response.statusText,\n        body: arrayify(new Uint8Array(body)),\n    }\n}\n","\"use strict\";\n\nimport { decode as base64Decode, encode as base64Encode } from \"@ethersproject/base64\";\nimport { hexlify, isBytesLike } from \"@ethersproject/bytes\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { getUrl, GetUrlResponse, Options } from \"./geturl\";\n\nfunction staller(duration: number): Promise<void> {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n\nfunction bodyify(value: any, type: string): string {\n    if (value == null) { return null; }\n\n    if (typeof(value) === \"string\") { return value; }\n\n    if (isBytesLike(value)) {\n        if (type && (type.split(\"/\")[0] === \"text\" || type.split(\";\")[0].trim() === \"application/json\")) {\n            try {\n                return toUtf8String(value);\n            } catch (error) { };\n        }\n        return hexlify(value);\n    }\n\n    return value;\n}\n\n// Exported Types\nexport type ConnectionInfo = {\n    url: string,\n    headers?: { [key: string]: string | number }\n\n    user?: string,\n    password?: string,\n\n    allowInsecureAuthentication?: boolean,\n    allowGzip?: boolean,\n\n    throttleLimit?: number,\n    throttleSlotInterval?: number;\n    throttleCallback?: (attempt: number, url: string) => Promise<boolean>,\n\n    skipFetchSetup?: boolean;\n    errorPassThrough?: boolean;\n\n    timeout?: number,\n};\n\nexport interface OnceBlockable {\n    once(eventName: \"block\", handler: () => void): void;\n}\n\nexport interface OncePollable {\n    once(eventName: \"poll\", handler: () => void): void;\n}\n\nexport type PollOptions = {\n    timeout?: number,\n    floor?: number,\n    ceiling?: number,\n    interval?: number,\n    retryLimit?: number,\n    onceBlock?: OnceBlockable\n    oncePoll?: OncePollable\n};\n\nexport type FetchJsonResponse = {\n    statusCode: number;\n    headers: { [ header: string ]: string };\n};\n\n\ntype Header = { key: string, value: string };\n\n// This API is still a work in progress; the future changes will likely be:\n// - ConnectionInfo => FetchDataRequest<T = any>\n// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }\n//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)\n// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T\n// For this reason, it should be considered internal until the API is finalized\nexport function _fetchData<T = Uint8Array>(connection: string | ConnectionInfo, body?: Uint8Array, processFunc?: (value: Uint8Array, response: FetchJsonResponse) => T): Promise<T> {\n\n    // How many times to retry in the event of a throttle\n    const attemptLimit = (typeof(connection) === \"object\" && connection.throttleLimit != null) ? connection.throttleLimit: 12;\n    logger.assertArgument((attemptLimit > 0 && (attemptLimit % 1) === 0),\n        \"invalid connection throttle limit\", \"connection.throttleLimit\", attemptLimit);\n\n    const throttleCallback = ((typeof(connection) === \"object\") ? connection.throttleCallback: null);\n    const throttleSlotInterval = ((typeof(connection) === \"object\" && typeof(connection.throttleSlotInterval) === \"number\") ? connection.throttleSlotInterval: 100);\n    logger.assertArgument((throttleSlotInterval > 0 && (throttleSlotInterval % 1) === 0),\n        \"invalid connection throttle slot interval\", \"connection.throttleSlotInterval\", throttleSlotInterval);\n\n    const errorPassThrough = ((typeof(connection) === \"object\") ? !!(connection.errorPassThrough): false);\n\n    const headers: { [key: string]: Header } = { };\n\n    let url: string = null;\n\n    // @TODO: Allow ConnectionInfo to override some of these values\n    const options: Options = {\n        method: \"GET\",\n    };\n\n    let allow304 = false;\n\n    let timeout = 2 * 60 * 1000;\n\n    if (typeof(connection) === \"string\") {\n        url = connection;\n\n    } else if (typeof(connection) === \"object\") {\n        if (connection == null || connection.url == null) {\n            logger.throwArgumentError(\"missing URL\", \"connection.url\", connection);\n        }\n\n        url = connection.url;\n\n        if (typeof(connection.timeout) === \"number\" && connection.timeout > 0) {\n            timeout = connection.timeout;\n        }\n\n        if (connection.headers) {\n            for (const key in connection.headers) {\n                headers[key.toLowerCase()] = { key: key, value: String(connection.headers[key]) };\n                if ([\"if-none-match\", \"if-modified-since\"].indexOf(key.toLowerCase()) >= 0) {\n                    allow304 = true;\n                }\n            }\n        }\n\n        options.allowGzip = !!connection.allowGzip;\n\n        if (connection.user != null && connection.password != null) {\n            if (url.substring(0, 6) !== \"https:\" && connection.allowInsecureAuthentication !== true) {\n                logger.throwError(\n                    \"basic authentication requires a secure https url\",\n                    Logger.errors.INVALID_ARGUMENT,\n                    { argument: \"url\", url: url, user: connection.user, password: \"[REDACTED]\" }\n                );\n            }\n\n            const authorization = connection.user + \":\" + connection.password;\n            headers[\"authorization\"] = {\n                key: \"Authorization\",\n                value: \"Basic \" + base64Encode(toUtf8Bytes(authorization))\n            };\n        }\n\n        if (connection.skipFetchSetup != null) {\n            options.skipFetchSetup = !!connection.skipFetchSetup;\n        }\n    }\n    const reData = new RegExp(\"^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$\", \"i\");\n    const dataMatch = ((url) ? url.match(reData): null);\n    if (dataMatch) {\n        try {\n            const response = {\n                statusCode: 200,\n                statusMessage: \"OK\",\n                headers: { \"content-type\": dataMatch[1] },\n                body: base64Decode(dataMatch[2])\n            };\n\n            let result: T = <T><unknown>response.body;\n            if (processFunc) {\n                result = processFunc(response.body, response);\n            }\n            return Promise.resolve(<T><unknown>result);\n\n        } catch (error) {\n            logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                body: bodyify(dataMatch[1], dataMatch[2]),\n                error: error,\n                requestBody: null,\n                requestMethod: \"GET\",\n                url: url\n            });\n        }\n    }\n\n    if (body) {\n        options.method = \"POST\";\n        options.body = body;\n        if (headers[\"content-type\"] == null) {\n            headers[\"content-type\"] = { key: \"Content-Type\", value: \"application/octet-stream\" };\n        }\n        if (headers[\"content-length\"] == null) {\n            headers[\"content-length\"] = { key: \"Content-Length\", value: String(body.length) };\n        }\n    }\n\n    const flatHeaders: { [ key: string ]: string } = { };\n    Object.keys(headers).forEach((key) => {\n        const header = headers[key];\n        flatHeaders[header.key] = header.value;\n    });\n    options.headers = flatHeaders;\n\n    const runningTimeout = (function() {\n        let timer: NodeJS.Timer = null;\n        const promise: Promise<never> = new Promise(function(resolve, reject) {\n            if (timeout) {\n                timer = setTimeout(() => {\n                    if (timer == null) { return; }\n                    timer = null;\n\n                    reject(logger.makeError(\"timeout\", Logger.errors.TIMEOUT, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        timeout: timeout,\n                        url: url\n                    }));\n                }, timeout);\n            }\n        });\n\n        const cancel = function() {\n            if (timer == null) { return; }\n            clearTimeout(timer);\n            timer = null;\n        }\n\n        return { promise, cancel };\n    })();\n\n    const runningFetch = (async function() {\n\n        for (let attempt = 0; attempt < attemptLimit; attempt++) {\n            let response: GetUrlResponse = null;\n\n            try {\n                response = await getUrl(url, options);\n\n                if (attempt < attemptLimit) {\n                    if (response.statusCode === 301 || response.statusCode === 302) {\n                        // Redirection; for now we only support absolute locataions\n                        const location = response.headers.location || \"\";\n                        if (options.method === \"GET\" && location.match(/^https:/)) {\n                            url = response.headers.location;\n                            continue;\n                        }\n\n                    } else if (response.statusCode === 429) {\n                        // Exponential back-off throttling\n                        let tryAgain = true;\n                        if (throttleCallback) {\n                            tryAgain = await throttleCallback(attempt, url);\n                        }\n\n                        if (tryAgain) {\n                            let stall = 0;\n\n                            const retryAfter = response.headers[\"retry-after\"];\n                            if (typeof(retryAfter) === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                                stall = parseInt(retryAfter) * 1000;\n                            } else {\n                                stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                            }\n\n                            //console.log(\"Stalling 429\");\n                            await staller(stall);\n                            continue;\n                        }\n                    }\n                }\n\n            } catch (error) {\n                response = (<any>error).response;\n                if (response == null) {\n                    runningTimeout.cancel();\n                    logger.throwError(\"missing response\", Logger.errors.SERVER_ERROR, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        serverError: error,\n                        url: url\n                    });\n                }\n            }\n\n\n            let body = response.body;\n\n            if (allow304 && response.statusCode === 304) {\n                body = null;\n            } else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {\n                runningTimeout.cancel();\n                logger.throwError(\"bad response\", Logger.errors.SERVER_ERROR, {\n                    status: response.statusCode,\n                    headers: response.headers,\n                    body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"]: null)),\n                    requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                    requestMethod: options.method,\n                    url: url\n                });\n            }\n\n            if (processFunc) {\n                try {\n                    const result = await processFunc(body, response);\n                    runningTimeout.cancel();\n                    return result;\n\n                } catch (error) {\n                    // Allow the processFunc to trigger a throttle\n                    if (error.throttleRetry && attempt < attemptLimit) {\n                        let tryAgain = true;\n                        if (throttleCallback) {\n                            tryAgain = await throttleCallback(attempt, url);\n                        }\n\n                        if (tryAgain) {\n                            const timeout = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                            //console.log(\"Stalling callback\");\n                            await staller(timeout);\n                            continue;\n                        }\n                    }\n\n                    runningTimeout.cancel();\n                    logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                        body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"]: null)),\n                        error: error,\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        url: url\n                    });\n                }\n            }\n\n            runningTimeout.cancel();\n\n            // If we had a processFunc, it either returned a T or threw above.\n            // The \"body\" is now a Uint8Array.\n            return <T>(<unknown>body);\n        }\n\n        return logger.throwError(\"failed response\", Logger.errors.SERVER_ERROR, {\n            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n            requestMethod: options.method,\n            url: url\n        });\n    })();\n\n    return Promise.race([ runningTimeout.promise, runningFetch ]);\n}\n\nexport function fetchJson(connection: string | ConnectionInfo, json?: string, processFunc?: (value: any, response: FetchJsonResponse) => any): Promise<any> {\n    let processJsonFunc = (value: Uint8Array, response: FetchJsonResponse) => {\n        let result: any = null;\n        if (value != null) {\n            try {\n                result = JSON.parse(toUtf8String(value));\n            } catch (error) {\n                logger.throwError(\"invalid JSON\", Logger.errors.SERVER_ERROR, {\n                    body: value,\n                    error: error\n                });\n            }\n        }\n\n        if (processFunc) {\n            result = processFunc(result, response);\n        }\n\n        return result;\n    }\n\n    // If we have json to send, we must\n    // - add content-type of application/json (unless already overridden)\n    // - convert the json to bytes\n    let body: Uint8Array = null;\n    if (json != null) {\n        body = toUtf8Bytes(json);\n\n        // Create a connection with the content-type set for JSON\n        const updated: ConnectionInfo = (typeof(connection) === \"string\") ? ({ url: connection }): shallowCopy(connection);\n        if (updated.headers) {\n            const hasContentType = (Object.keys(updated.headers).filter((k) => (k.toLowerCase() === \"content-type\")).length) !== 0;\n            if (!hasContentType) {\n                updated.headers = shallowCopy(updated.headers);\n                updated.headers[\"content-type\"] = \"application/json\";\n            }\n        } else {\n            updated.headers = { \"content-type\": \"application/json\" };\n        }\n        connection = updated;\n    }\n\n    return _fetchData<any>(connection, body, processJsonFunc);\n}\n\nexport function poll<T>(func: () => Promise<T>, options?: PollOptions): Promise<T> {\n    if (!options) { options = {}; }\n    options = shallowCopy(options);\n    if (options.floor == null) { options.floor = 0; }\n    if (options.ceiling == null) { options.ceiling = 10000; }\n    if (options.interval == null) { options.interval = 250; }\n\n    return new Promise(function(resolve, reject) {\n\n        let timer: NodeJS.Timer = null;\n        let done: boolean = false;\n\n        // Returns true if cancel was successful. Unsuccessful cancel means we're already done.\n        const cancel = (): boolean => {\n            if (done) { return false; }\n            done = true;\n            if (timer) { clearTimeout(timer); }\n            return true;\n        };\n\n        if (options.timeout) {\n            timer = setTimeout(() => {\n                if (cancel()) { reject(new Error(\"timeout\")); }\n            }, options.timeout)\n        }\n\n        const retryLimit = options.retryLimit;\n\n        let attempt = 0;\n        function check() {\n            return func().then(function(result) {\n\n                // If we have a result, or are allowed null then we're done\n                if (result !== undefined) {\n                    if (cancel()) { resolve(result); }\n\n                } else if (options.oncePoll) {\n                    options.oncePoll.once(\"poll\", check);\n\n                } else if (options.onceBlock) {\n                    options.onceBlock.once(\"block\", check);\n\n                // Otherwise, exponential back-off (up to 10s) our next request\n                } else if (!done) {\n                    attempt++;\n                    if (attempt > retryLimit) {\n                        if (cancel()) { reject(new Error(\"retry limit reached\")); }\n                        return;\n                    }\n\n                    let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                    if (timeout < options.floor) { timeout = options.floor; }\n                    if (timeout > options.ceiling) { timeout = options.ceiling; }\n\n                    setTimeout(check, timeout);\n                }\n\n                return null;\n            }, function(error) {\n                if (cancel()) { reject(error); }\n            });\n        }\n        check();\n    });\n}\n\n","export const version = \"abstract-provider/5.6.0\";\n","\"use strict\";\n\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { BytesLike, isHexString } from \"@ethersproject/bytes\";\nimport { Network } from \"@ethersproject/networks\";\nimport { Deferrable, Description, defineReadOnly, resolveProperties } from \"@ethersproject/properties\";\nimport { AccessListish, Transaction } from \"@ethersproject/transactions\";\nimport { OnceBlockable } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\n\nexport type TransactionRequest = {\n    to?: string,\n    from?: string,\n    nonce?: BigNumberish,\n\n    gasLimit?: BigNumberish,\n    gasPrice?: BigNumberish,\n\n    data?: BytesLike,\n    value?: BigNumberish,\n    chainId?: number\n\n    type?: number;\n    accessList?: AccessListish;\n\n    maxPriorityFeePerGas?: BigNumberish;\n    maxFeePerGas?: BigNumberish;\n\n    customData?: Record<string, any>;\n    ccipReadEnabled?: boolean;\n}\n\nexport interface TransactionResponse extends Transaction {\n    hash: string;\n\n    // Only if a transaction has been mined\n    blockNumber?: number,\n    blockHash?: string,\n    timestamp?: number,\n\n    confirmations: number,\n\n    // Not optional (as it is in Transaction)\n    from: string;\n\n    // The raw transaction\n    raw?: string,\n\n    // This function waits until the transaction has been mined\n    wait: (confirmations?: number) => Promise<TransactionReceipt>\n};\n\nexport type BlockTag = string | number;\n\nexport interface _Block {\n    hash: string;\n    parentHash: string;\n    number: number;\n\n    timestamp: number;\n    nonce: string;\n    difficulty: number;\n    _difficulty: BigNumber;\n\n    gasLimit: BigNumber;\n    gasUsed: BigNumber;\n\n    miner: string;\n    extraData: string;\n\n    baseFeePerGas?: null | BigNumber;\n}\n\nexport interface Block extends _Block {\n    transactions: Array<string>;\n}\n\nexport interface BlockWithTransactions extends _Block {\n    transactions: Array<TransactionResponse>;\n}\n\n\nexport interface Log {\n    blockNumber: number;\n    blockHash: string;\n    transactionIndex: number;\n\n    removed: boolean;\n\n    address: string;\n    data: string;\n\n    topics: Array<string>;\n\n    transactionHash: string;\n    logIndex: number;\n}\n\nexport interface TransactionReceipt {\n    to: string;\n    from: string;\n    contractAddress: string,\n    transactionIndex: number,\n    root?: string,\n    gasUsed: BigNumber,\n    logsBloom: string,\n    blockHash: string,\n    transactionHash: string,\n    logs: Array<Log>,\n    blockNumber: number,\n    confirmations: number,\n    cumulativeGasUsed: BigNumber,\n    effectiveGasPrice: BigNumber,\n    byzantium: boolean,\n    type: number;\n    status?: number\n};\n\nexport interface FeeData {\n    maxFeePerGas: null | BigNumber;\n    maxPriorityFeePerGas: null | BigNumber;\n    gasPrice: null | BigNumber;\n}\n\nexport interface EventFilter {\n    address?: string;\n    topics?: Array<string | Array<string> | null>;\n}\n\nexport interface Filter extends EventFilter {\n    fromBlock?: BlockTag,\n    toBlock?: BlockTag,\n}\n\nexport interface FilterByBlockHash extends EventFilter {\n    blockHash?: string;\n}\n\n//export type CallTransactionable = {\n//    call(transaction: TransactionRequest): Promise<TransactionResponse>;\n//};\n\nexport abstract class ForkEvent extends Description {\n    readonly expiry: number;\n\n    readonly _isForkEvent?: boolean;\n\n    static isForkEvent(value: any): value is ForkEvent {\n        return !!(value && value._isForkEvent);\n    }\n}\n\nexport class BlockForkEvent extends ForkEvent {\n    readonly blockHash: string;\n\n    readonly _isBlockForkEvent?: boolean;\n\n    constructor(blockHash: string, expiry?: number) {\n        if (!isHexString(blockHash, 32)) {\n            logger.throwArgumentError(\"invalid blockHash\", \"blockHash\", blockHash);\n        }\n\n        super({\n            _isForkEvent: true,\n            _isBlockForkEvent: true,\n            expiry: (expiry || 0),\n            blockHash: blockHash\n        });\n    }\n}\n\nexport class TransactionForkEvent extends ForkEvent {\n    readonly hash: string;\n\n    readonly _isTransactionOrderForkEvent?: boolean;\n\n    constructor(hash: string, expiry?: number) {\n        if (!isHexString(hash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"hash\", hash);\n        }\n\n        super({\n            _isForkEvent: true,\n            _isTransactionForkEvent: true,\n            expiry: (expiry || 0),\n            hash: hash\n        });\n    }\n}\n\nexport class TransactionOrderForkEvent extends ForkEvent {\n    readonly beforeHash: string;\n    readonly afterHash: string;\n\n    constructor(beforeHash: string, afterHash: string, expiry?: number) {\n        if (!isHexString(beforeHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"beforeHash\", beforeHash);\n        }\n        if (!isHexString(afterHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"afterHash\", afterHash);\n        }\n\n        super({\n            _isForkEvent: true,\n            _isTransactionOrderForkEvent: true,\n            expiry: (expiry || 0),\n            beforeHash: beforeHash,\n            afterHash: afterHash\n        });\n    }\n}\n\nexport type EventType = string | Array<string | Array<string>> | EventFilter | ForkEvent;\n\nexport type Listener = (...args: Array<any>) => void;\n\n///////////////////////////////\n// Exported Abstracts\nexport abstract class Provider implements OnceBlockable {\n\n    // Network\n    abstract getNetwork(): Promise<Network>;\n\n    // Latest State\n    abstract getBlockNumber(): Promise<number>;\n    abstract getGasPrice(): Promise<BigNumber>;\n    async getFeeData(): Promise<FeeData> {\n        const { block, gasPrice } = await resolveProperties({\n            block: this.getBlock(\"latest\"),\n            gasPrice: this.getGasPrice().catch((error) => {\n                // @TODO: Why is this now failing on Calaveras?\n                //console.log(error);\n                return null;\n            })\n        });\n\n        let maxFeePerGas = null, maxPriorityFeePerGas = null;\n\n        if (block && block.baseFeePerGas) {\n            // We may want to compute this more accurately in the future,\n            // using the formula \"check if the base fee is correct\".\n            // See: https://eips.ethereum.org/EIPS/eip-1559\n            maxPriorityFeePerGas = BigNumber.from(\"1500000000\");\n            maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);\n        }\n\n        return { maxFeePerGas, maxPriorityFeePerGas, gasPrice };\n    }\n\n    // Account\n    abstract getBalance(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<BigNumber>;\n    abstract getTransactionCount(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<number>;\n    abstract getCode(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> ;\n    abstract getStorageAt(addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;\n\n    // Execution\n    abstract sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse>;\n    abstract call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;\n    abstract estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber>;\n\n    // Queries\n    abstract getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block>;\n    abstract getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<BlockWithTransactions>;\n    abstract getTransaction(transactionHash: string): Promise<TransactionResponse>;\n    abstract getTransactionReceipt(transactionHash: string): Promise<TransactionReceipt>;\n\n    // Bloom-filter Queries\n    abstract getLogs(filter: Filter): Promise<Array<Log>>;\n\n    // ENS\n    abstract resolveName(name: string | Promise<string>): Promise<null | string>;\n    abstract lookupAddress(address: string | Promise<string>): Promise<null | string>;\n\n    // Event Emitter (ish)\n    abstract on(eventName: EventType, listener: Listener): Provider;\n    abstract once(eventName: EventType, listener: Listener): Provider;\n    abstract emit(eventName: EventType, ...args: Array<any>): boolean\n    abstract listenerCount(eventName?: EventType): number;\n    abstract listeners(eventName?: EventType): Array<Listener>;\n    abstract off(eventName: EventType, listener?: Listener): Provider;\n    abstract removeAllListeners(eventName?: EventType): Provider;\n\n    // Alias for \"on\"\n    addListener(eventName: EventType, listener: Listener): Provider {\n        return this.on(eventName, listener);\n    }\n\n    // Alias for \"off\"\n    removeListener(eventName: EventType, listener: Listener): Provider {\n        return this.off(eventName, listener);\n    }\n\n    // @TODO: This *could* be implemented here, but would pull in events...\n    abstract waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number): Promise<TransactionReceipt>;\n\n    readonly _isProvider: boolean;\n\n    constructor() {\n        logger.checkAbstract(new.target, Provider);\n        defineReadOnly(this, \"_isProvider\", true);\n    }\n\n    static isProvider(value: any): value is Provider {\n        return !!(value && value._isProvider);\n    }\n\n/*\n    static getResolver(network: Network, callable: CallTransactionable, namehash: string): string {\n        // No ENS...\n        if (!network.ensAddress) {\n            errors.throwError(\n                \"network does support ENS\",\n                errors.UNSUPPORTED_OPERATION,\n                { operation: \"ENS\", network: network.name }\n            );\n        }\n\n        // Not a namehash\n        if (!isHexString(namehash, 32)) {\n            errors.throwArgumentError(\"invalid name hash\", \"namehash\", namehash);\n        }\n\n        // keccak256(\"resolver(bytes32)\")\n        let data = \"0x0178b8bf\" + namehash.substring(2);\n        let transaction = { to: network.ensAddress, data: data };\n\n        return provider.call(transaction).then((data) => {\n            return provider.formatter.callAddress(data);\n        });\n    }\n\n    static resolveNamehash(network: Network, callable: CallTransactionable, namehash: string): string {\n        return this.getResolver(network, callable, namehash).then((resolverAddress) => {\n            if (!resolverAddress) { return null; }\n\n            // keccak256(\"addr(bytes32)\")\n            let data = \"0x3b3b57de\" + namehash(name).substring(2);\n            let transaction = { to: resolverAddress, data: data };\n            return callable.call(transaction).then((data) => {\n                return this.formatter.callAddress(data);\n            });\n\n        })\n    }\n*/\n}\n","/**\n * var basex = require(\"base-x\");\n *\n * This implementation is heavily based on base-x. The main reason to\n * deviate was to prevent the dependency of Buffer.\n *\n * Contributors:\n *\n * base-x encoding\n * Forked from https://github.com/cryptocoinjs/bs58\n * Originally written by Mike Hearn for BitcoinJ\n * Copyright (c) 2011 Google Inc\n * Ported to JavaScript by Stefan Thomas\n * Merged Buffer refactorings from base58-native by Stephen Pair\n * Copyright (c) 2013 BitPay Inc\n *\n * The MIT License (MIT)\n *\n * Copyright base-x contributors (c) 2016\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nexport class BaseX {\n    readonly alphabet: string;\n    readonly base: number;\n\n    _alphabetMap: { [ character: string ]: number };\n    _leader: string;\n\n    constructor(alphabet: string) {\n        defineReadOnly(this, \"alphabet\", alphabet);\n        defineReadOnly(this, \"base\", alphabet.length);\n\n        defineReadOnly(this, \"_alphabetMap\", { });\n        defineReadOnly(this, \"_leader\", alphabet.charAt(0));\n\n        // pre-compute lookup table\n        for (let i = 0; i < alphabet.length; i++) {\n            this._alphabetMap[alphabet.charAt(i)] = i;\n        }\n    }\n\n    encode(value: BytesLike): string {\n        let source = arrayify(value);\n\n        if (source.length === 0) { return \"\"; }\n\n        let digits = [ 0 ]\n        for (let i = 0; i < source.length; ++i) {\n            let carry = source[i];\n            for (let j = 0; j < digits.length; ++j) {\n                carry += digits[j] << 8;\n                digits[j] = carry % this.base;\n                carry = (carry / this.base) | 0;\n            }\n\n            while (carry > 0) {\n                digits.push(carry % this.base);\n                carry = (carry / this.base) | 0;\n            }\n        }\n\n        let string = \"\"\n\n        // deal with leading zeros\n        for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {\n            string += this._leader;\n        }\n\n        // convert digits to a string\n        for (let q = digits.length - 1; q >= 0; --q) {\n            string += this.alphabet[digits[q]];\n        }\n\n        return string;\n    }\n\n    decode(value: string): Uint8Array {\n        if (typeof(value) !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n\n        let bytes: Array<number> = [];\n        if (value.length === 0) { return new Uint8Array(bytes); }\n\n        bytes.push(0);\n        for (let i = 0; i < value.length; i++) {\n            let byte = this._alphabetMap[value[i]];\n\n            if (byte === undefined) {\n                throw new Error(\"Non-base\" + this.base + \" character\");\n            }\n\n            let carry = byte;\n            for (let j = 0; j < bytes.length; ++j) {\n                carry += bytes[j] * this.base;\n                bytes[j] = carry & 0xff;\n                carry >>= 8;\n            }\n\n            while (carry > 0) {\n                bytes.push(carry & 0xff);\n                carry >>= 8;\n            }\n        }\n\n        // deal with leading zeros\n        for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {\n            bytes.push(0)\n        }\n\n        return arrayify(new Uint8Array(bytes.reverse()))\n    }\n}\n\nconst Base32 = new BaseX(\"abcdefghijklmnopqrstuvwxyz234567\");\nconst Base58 = new BaseX(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\n\nexport { Base32, Base58 };\n\n//console.log(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\"))\n//console.log(Base58.encode(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\")))\n","\"use strict\";\n\nimport { toUtf8CodePoints, _toUtf8String, UnicodeNormalizationForm } from \"./utf8\";\n\ntype Ranged = {\n    l: number,          // Lo value\n    h: number,          // High value (less the lo)\n    d?: number,         // Delta/stride (default: 1)\n    s?: number,         // Shift (default: 1)\n    e?: Array<number>   // Exceptions to skip\n};\n\ntype Table = { [ src: number ]: Array<number> };\n\nfunction bytes2(data: string): Array<number> {\n    if ((data.length % 4) !== 0) { throw new Error(\"bad data\"); }\n    let result = [];\n    for (let i = 0; i < data.length; i += 4) {\n        result.push(parseInt(data.substring(i, i + 4), 16));\n    }\n    return result;\n}\n\nfunction createTable(data: string, func?: (value: string) => Array<number>): Table {\n    if (!func) {\n        func = function(value: string) { return [ parseInt(value, 16) ]; }\n    }\n\n    let lo = 0;\n\n    let result: Table = { };\n    data.split(\",\").forEach((pair) => {\n        let comps = pair.split(\":\");\n        lo += parseInt(comps[0], 16);\n        result[lo] = func(comps[1]);\n    });\n\n    return result;\n}\n\nfunction createRangeTable(data: string): Array<Ranged> {\n    let hi = 0;\n    return data.split(\",\").map((v) => {\n        let comps = v.split(\"-\");\n        if (comps.length === 1) {\n            comps[1] = \"0\";\n        } else if (comps[1] === \"\") {\n            comps[1] = \"1\";\n        }\n\n        let lo = hi + parseInt(comps[0], 16);\n        hi = parseInt(comps[1], 16);\n        return { l: lo, h: hi };\n    });\n}\n\nfunction matchMap(value: number, ranges: Array<Ranged>): Ranged {\n    let lo = 0;\n    for (let i = 0; i < ranges.length; i++) {\n        let range = ranges[i];\n        lo += range.l;\n        if (value >= lo && value <= lo + range.h && ((value - lo) % (range.d || 1)) === 0) {\n            if (range.e && range.e.indexOf(value - lo) !== -1) { continue; }\n            return range;\n        }\n    }\n    return null;\n}\n\nconst Table_A_1_ranges = createRangeTable(\"221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d\");\n\n// @TODO: Make this relative...\nconst Table_B_1_flags = \"ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff\".split(\",\").map((v) => parseInt(v, 16));\n\nconst Table_B_2_ranges: Array<Ranged> = [\n    { h: 25, s: 32, l: 65 },\n    { h: 30, s: 32, e: [ 23 ], l: 127 },\n    { h: 54, s: 1, e: [ 48 ], l: 64, d: 2 },\n    { h: 14, s: 1, l: 57, d: 2 },\n    { h: 44, s: 1, l: 17, d: 2 },\n    { h: 10, s: 1, e: [ 2, 6, 8 ], l: 61, d: 2 },\n    { h: 16, s: 1, l: 68, d: 2 },\n    { h: 84, s: 1, e: [ 18, 24, 66 ], l: 19, d: 2 },\n    { h: 26, s: 32, e: [ 17 ], l: 435 },\n    { h: 22, s: 1, l: 71, d: 2 },\n    { h: 15, s: 80, l: 40 },\n    { h: 31, s: 32, l: 16 },\n    { h: 32, s: 1, l: 80, d: 2 },\n    { h: 52, s: 1, l: 42, d: 2 },\n    { h: 12, s: 1, l: 55, d: 2 },\n    { h: 40, s: 1, e: [ 38 ], l: 15, d: 2 },\n    { h: 14, s: 1, l: 48, d: 2 },\n    { h: 37, s: 48, l: 49 },\n    { h: 148, s: 1, l: 6351, d: 2 },\n    { h: 88, s: 1, l: 160, d: 2 },\n    { h: 15, s: 16, l: 704 },\n    { h: 25, s: 26, l: 854 },\n    { h: 25, s: 32, l: 55915 },\n    { h: 37, s: 40, l: 1247 },\n    { h: 25, s: -119711, l: 53248 },\n    { h: 25, s: -119763, l: 52 },\n    { h: 25, s: -119815, l: 52 },\n    { h: 25, s: -119867, e: [ 1, 4, 5, 7, 8, 11, 12, 17 ], l: 52 },\n    { h: 25, s: -119919, l: 52 },\n    { h: 24, s: -119971, e: [ 2, 7, 8, 17 ], l: 52 },\n    { h: 24, s: -120023, e: [ 2, 7, 13, 15, 16, 17 ], l: 52 },\n    { h: 25, s: -120075, l: 52 },\n    { h: 25, s: -120127, l: 52 },\n    { h: 25, s: -120179, l: 52 },\n    { h: 25, s: -120231, l: 52 },\n    { h: 25, s: -120283, l: 52 },\n    { h: 25, s: -120335, l: 52 },\n    { h: 24, s: -119543, e: [ 17 ], l: 56 },\n    { h: 24, s: -119601, e: [ 17 ], l: 58 },\n    { h: 24, s: -119659, e: [ 17 ], l: 58 },\n    { h: 24, s: -119717, e: [ 17 ], l: 58 },\n    { h: 24, s: -119775, e: [ 17 ], l: 58 }\n];\nconst Table_B_2_lut_abs = createTable(\"b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3\");\nconst Table_B_2_lut_rel = createTable(\"179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7\");\nconst Table_B_2_complex = createTable(\"df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D\", bytes2);\n\nconst Table_C_ranges = createRangeTable(\"80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001\");\n\n\nfunction flatten(values: Array<Array<number>>): Array<number> {\n    return values.reduce((accum, value) => {\n        value.forEach((value) => { accum.push(value); });\n        return accum;\n    }, [ ]);\n}\n\nexport function _nameprepTableA1(codepoint: number): boolean {\n    return !!matchMap(codepoint, Table_A_1_ranges);\n}\n\nexport function _nameprepTableB2(codepoint: number): Array<number> {\n    let range = matchMap(codepoint, Table_B_2_ranges);\n    if (range) { return [ codepoint + range.s ]; }\n\n    let codes = Table_B_2_lut_abs[codepoint];\n    if (codes) { return codes; }\n\n    let shift = Table_B_2_lut_rel[codepoint];\n    if (shift) { return [ codepoint + shift[0] ]; }\n\n    let complex = Table_B_2_complex[codepoint];\n    if (complex) { return complex; }\n\n    return null;\n}\n\nexport function _nameprepTableC(codepoint: number): boolean {\n    return !!matchMap(codepoint, Table_C_ranges);\n}\n\nexport function nameprep(value: string): string {\n\n    // This allows platforms with incomplete normalize to bypass\n    // it for very basic names which the built-in toLowerCase\n    // will certainly handle correctly\n    if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) { return value.toLowerCase(); }\n\n    // Get the code points (keeping the current normalization)\n    let codes = toUtf8CodePoints(value);\n\n    codes = flatten(codes.map((code) => {\n        // Substitute Table B.1 (Maps to Nothing)\n        if (Table_B_1_flags.indexOf(code) >= 0) { return [ ]; }\n        if (code >= 0xfe00 && code <= 0xfe0f) { return [ ]; }\n\n        // Substitute Table B.2 (Case Folding)\n        let codesTableB2 = _nameprepTableB2(code);\n        if (codesTableB2) { return codesTableB2; }\n\n        // No Substitution\n        return [ code ];\n    }));\n\n    // Normalize using form KC\n    codes = toUtf8CodePoints(_toUtf8String(codes), UnicodeNormalizationForm.NFKC);\n\n    // Prohibit Tables C.1.2, C.2.2, C.3, C.4, C.5, C.6, C.7, C.8, C.9\n    codes.forEach((code) => {\n        if (_nameprepTableC(code)) {\n            throw new Error(\"STRINGPREP_CONTAINS_PROHIBITED\");\n        }\n    });\n\n    // Prohibit Unassigned Code Points (Table A.1)\n    codes.forEach((code) => {\n        if (_nameprepTableA1(code)) {\n            throw new Error(\"STRINGPREP_CONTAINS_UNASSIGNED\");\n        }\n    });\n\n    // IDNA extras\n    let name = _toUtf8String(codes);\n\n    // IDNA: 4.2.3.1\n    if (name.substring(0, 1) === \"-\" || name.substring(2, 4) === \"--\" || name.substring(name.length - 1) === \"-\") {\n        throw new Error(\"invalid hyphen\");\n    }\n\n    // IDNA: 4.2.4\n    if (name.length > 63) { throw new Error(\"too long\"); }\n\n\n\n    return name;\n}\n\n","import { concat, hexlify } from \"@ethersproject/bytes\";\nimport { nameprep, toUtf8Bytes } from \"@ethersproject/strings\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\n\nconst Partition = new RegExp(\"^((.*)\\\\.)?([^.]+)$\");\n\nexport function isValidName(name: string): boolean {\n    try {\n        const comps = name.split(\".\");\n        for (let i = 0; i < comps.length; i++) {\n            if (nameprep(comps[i]).length === 0) {\n                throw new Error(\"empty\")\n            }\n        }\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function namehash(name: string): string {\n    /* istanbul ignore if */\n    if (typeof(name) !== \"string\") {\n        logger.throwArgumentError(\"invalid ENS name; not a string\", \"name\", name);\n    }\n\n    let current = name;\n    let result: string | Uint8Array = Zeros;\n    while (current.length) {\n        const partition = current.match(Partition);\n        if (partition == null || partition[2] === \"\") {\n            logger.throwArgumentError(\"invalid ENS address; missing component\", \"name\", name);\n        }\n        const label = toUtf8Bytes(nameprep(partition[3]));\n        result = keccak256(concat([result, keccak256(label)]));\n\n        current = partition[2] || \"\";\n    }\n\n    return hexlify(result);\n}\n\nexport function dnsEncode(name: string): string {\n    return hexlify(concat(name.split(\".\").map((comp) => {\n        // We jam in an _ prefix to fill in with the length later\n        // Note: Nameprep throws if the component is over 63 bytes\n        const bytes = toUtf8Bytes(\"_\" + nameprep(comp));\n        bytes[0] = bytes.length - 1;\n        return bytes;\n    }))) + \"00\";\n}\n","\"use strict\";\n\nimport hash from \"hash.js\";\n//const _ripemd160 = _hash.ripemd160;\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { SupportedAlgorithm } from \"./types\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function ripemd160(data: BytesLike): string {\n    return \"0x\" + (hash.ripemd160().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha256(data: BytesLike): string {\n    return \"0x\" + (hash.sha256().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha512(data: BytesLike): string {\n    return \"0x\" + (hash.sha512().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function computeHmac(algorithm: SupportedAlgorithm, key: BytesLike, data: BytesLike): string {\n    if (!SupportedAlgorithm[algorithm]) {\n        logger.throwError(\"unsupported algorithm \" + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"hmac\",\n            algorithm: algorithm\n        });\n    }\n\n    return \"0x\" + hash.hmac((<any>hash)[algorithm], arrayify(key)).update(arrayify(data)).digest(\"hex\");\n}\n\n","export const version = \"sha2/5.6.0\";\n","\"use strict\";\n\nimport {\n    Block, BlockTag, BlockWithTransactions, EventType, Filter, FilterByBlockHash, ForkEvent,\n    Listener, Log, Provider, TransactionReceipt, TransactionRequest, TransactionResponse\n} from \"@ethersproject/abstract-provider\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, concat, hexConcat, hexDataLength, hexDataSlice, hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { HashZero } from \"@ethersproject/constants\";\nimport { namehash } from \"@ethersproject/hash\";\nimport { getNetwork, Network, Networkish } from \"@ethersproject/networks\";\nimport { Deferrable, defineReadOnly, getStatic, resolveProperties } from \"@ethersproject/properties\";\nimport { Transaction } from \"@ethersproject/transactions\";\nimport { sha256 } from \"@ethersproject/sha2\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { fetchJson, poll } from \"@ethersproject/web\";\n\nimport bech32 from \"bech32\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { Formatter } from \"./formatter\";\n\n//////////////////////////////\n// Event Serializeing\n\nfunction checkTopic(topic: string): string {\n     if (topic == null) { return \"null\"; }\n     if (hexDataLength(topic) !== 32) {\n         logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n     }\n     return topic.toLowerCase();\n}\n\nfunction serializeTopics(topics: Array<string | Array<string>>): string {\n    // Remove trailing null AND-topics; they are redundant\n    topics = topics.slice();\n    while (topics.length > 0 && topics[topics.length - 1] == null) { topics.pop(); }\n\n    return topics.map((topic) => {\n        if (Array.isArray(topic)) {\n\n            // Only track unique OR-topics\n            const unique: { [ topic: string ]: boolean } = { }\n            topic.forEach((topic) => {\n                unique[checkTopic(topic)] = true;\n            });\n\n            // The order of OR-topics does not matter\n            const sorted = Object.keys(unique);\n            sorted.sort();\n\n            return sorted.join(\"|\");\n\n        } else {\n            return checkTopic(topic);\n        }\n    }).join(\"&\");\n}\n\nfunction deserializeTopics(data: string): Array<string | Array<string>> {\n    if (data === \"\") { return [ ]; }\n\n    return data.split(/&/g).map((topic) => {\n        if (topic === \"\") { return [ ]; }\n\n        const comps = topic.split(\"|\").map((topic) => {\n            return ((topic === \"null\") ? null: topic);\n        });\n\n        return ((comps.length === 1) ? comps[0]: comps);\n    });\n}\n\nfunction getEventTag(eventName: EventType): string {\n    if (typeof(eventName) === \"string\") {\n        eventName = eventName.toLowerCase();\n\n        if (hexDataLength(eventName) === 32) {\n            return \"tx:\" + eventName;\n        }\n\n        if (eventName.indexOf(\":\") === -1) {\n            return eventName;\n        }\n\n    } else if (Array.isArray(eventName)) {\n        return \"filter:*:\" + serializeTopics(eventName);\n\n    } else if (ForkEvent.isForkEvent(eventName)) {\n        logger.warn(\"not implemented\");\n        throw new Error(\"not implemented\");\n\n    } else if (eventName && typeof(eventName) === \"object\") {\n        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n    }\n\n    throw new Error(\"invalid event - \" + eventName);\n}\n\n//////////////////////////////\n// Helper Object\n\nfunction getTime() {\n    return (new Date()).getTime();\n}\n\nfunction stall(duration: number): Promise<void> {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n\n//////////////////////////////\n// Provider Object\n\n\n/**\n *  EventType\n *   - \"block\"\n *   - \"poll\"\n *   - \"didPoll\"\n *   - \"pending\"\n *   - \"error\"\n *   - \"network\"\n *   - filter\n *   - topics array\n *   - transaction hash\n */\n\nconst PollableEvents = [ \"block\", \"network\", \"pending\", \"poll\" ];\n\nexport class Event {\n    readonly listener: Listener;\n    readonly once: boolean;\n    readonly tag: string;\n\n    constructor(tag: string, listener: Listener, once: boolean) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"listener\", listener);\n        defineReadOnly(this, \"once\", once);\n    }\n\n    get event(): EventType {\n        switch (this.type) {\n            case \"tx\":\n               return this.hash;\n            case \"filter\":\n               return this.filter;\n        }\n        return this.tag;\n    }\n\n    get type(): string {\n        return this.tag.split(\":\")[0]\n    }\n\n    get hash(): string {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"tx\") { return null; }\n        return comps[1];\n    }\n\n    get filter(): Filter {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"filter\") { return null; }\n        const address = comps[1];\n\n        const topics = deserializeTopics(comps[2]);\n        const filter: Filter = { };\n\n        if (topics.length > 0) { filter.topics = topics; }\n        if (address && address !== \"*\") { filter.address = address; }\n\n        return filter;\n    }\n\n    pollable(): boolean {\n        return (this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0);\n    }\n}\n\nexport interface EnsResolver {\n\n    // Name this Resolver is associated with\n    readonly name: string;\n\n    // The address of the resolver\n    readonly address: string;\n\n    // Multichain address resolution (also normal address resolution)\n    // See: https://eips.ethereum.org/EIPS/eip-2304\n    getAddress(coinType?: 60): Promise<null | string>\n\n    // Contenthash field\n    // See: https://eips.ethereum.org/EIPS/eip-1577\n    getContentHash(): Promise<null | string>;\n\n    // Storage of text records\n    // See: https://eips.ethereum.org/EIPS/eip-634\n    getText(key: string): Promise<null | string>;\n};\n\nexport interface EnsProvider {\n    resolveName(name: string): Promise<null | string>;\n    lookupAddress(address: string): Promise<null | string>;\n    getResolver(name: string): Promise<null | EnsResolver>;\n}\n\ntype CoinInfo = {\n    symbol: string,\n    ilk?: string,     // General family\n    prefix?: string,  // Bech32 prefix\n    p2pkh?: number,   // Pay-to-Public-Key-Hash Version\n    p2sh?: number,    // Pay-to-Script-Hash Version\n};\n\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nconst coinInfos: { [ coinType: string ]: CoinInfo } = {\n    \"0\":   { symbol: \"btc\",  p2pkh: 0x00, p2sh: 0x05, prefix: \"bc\" },\n    \"2\":   { symbol: \"ltc\",  p2pkh: 0x30, p2sh: 0x32, prefix: \"ltc\" },\n    \"3\":   { symbol: \"doge\", p2pkh: 0x1e, p2sh: 0x16 },\n    \"60\":  { symbol: \"eth\",  ilk: \"eth\" },\n    \"61\":  { symbol: \"etc\",  ilk: \"eth\" },\n    \"700\": { symbol: \"xdai\", ilk: \"eth\" },\n};\n\nfunction bytes32ify(value: number): string {\n    return hexZeroPad(BigNumber.from(value).toHexString(), 32);\n}\n\n// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\nfunction base58Encode(data: Uint8Array): string {\n    return Base58.encode(concat([ data, hexDataSlice(sha256(sha256(data)), 0, 4) ]));\n}\n\nexport interface Avatar {\n    url: string;\n    linkage: Array<{ type: string, content: string }>;\n}\n\nconst matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\n\nfunction _parseString(result: string): null | string {\n    try {\n        return toUtf8String(_parseBytes(result));\n    } catch(error) { }\n    return null;\n}\n\nfunction _parseBytes(result: string): null | string {\n    if (result === \"0x\") { return null; }\n\n    const offset = BigNumber.from(hexDataSlice(result, 0, 32)).toNumber();\n    const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();\n    return hexDataSlice(result, offset + 32, offset + 32 + length);\n}\n\n\nexport class Resolver implements EnsResolver {\n    readonly provider: BaseProvider;\n\n    readonly name: string;\n    readonly address: string;\n\n    readonly _resolvedAddress: null | string;\n\n    // The resolvedAddress is only for creating a ReverseLookup resolver\n    constructor(provider: BaseProvider, address: string, name: string, resolvedAddress?: string) {\n        defineReadOnly(this, \"provider\", provider);\n        defineReadOnly(this, \"name\", name);\n        defineReadOnly(this, \"address\", provider.formatter.address(address));\n        defineReadOnly(this, \"_resolvedAddress\", resolvedAddress);\n    }\n\n    async _fetchBytes(selector: string, parameters?: string): Promise<null | string> {\n        // e.g. keccak256(\"addr(bytes32,uint256)\")\n        const tx = {\n            to: this.address,\n            data: hexConcat([ selector, namehash(this.name), (parameters || \"0x\") ])\n        };\n\n        try {\n            return _parseBytes(await this.provider.call(tx));\n        } catch (error) {\n            if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n            return null;\n        }\n    }\n\n    _getAddress(coinType: number, hexBytes: string): string {\n        const coinInfo = coinInfos[String(coinType)];\n\n        if (coinInfo == null) {\n            logger.throwError(`unsupported coin type: ${ coinType }`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${ coinType })`\n            });\n        }\n\n        if (coinInfo.ilk === \"eth\") {\n            return this.provider.formatter.address(hexBytes);\n        }\n\n        const bytes = arrayify(hexBytes);\n\n        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n        if (coinInfo.p2pkh != null) {\n            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n            if (p2pkh) {\n                const length = parseInt(p2pkh[1], 16);\n                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([ [ coinInfo.p2pkh ], (\"0x\" + p2pkh[2]) ]));\n                }\n            }\n        }\n\n        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n        if (coinInfo.p2sh != null) {\n            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n            if (p2sh) {\n                const length = parseInt(p2sh[1], 16);\n                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([ [ coinInfo.p2sh ], (\"0x\" + p2sh[2]) ]));\n                }\n            }\n        }\n\n        // Bech32\n        if (coinInfo.prefix != null) {\n            const length = bytes[1];\n\n            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n            let version = bytes[0];\n            if (version === 0x00) {\n                if (length !== 20 && length !== 32) {\n                    version = -1;\n                }\n            } else {\n                version = -1;\n            }\n\n            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {\n                const words = bech32.toWords(bytes.slice(2));\n                words.unshift(version);\n                return bech32.encode(coinInfo.prefix, words);\n            }\n        }\n\n        return null;\n    }\n\n\n    async getAddress(coinType?: number): Promise<string> {\n        if (coinType == null) { coinType = 60; }\n\n        // If Ethereum, use the standard `addr(bytes32)`\n        if (coinType === 60) {\n            try {\n                // keccak256(\"addr(bytes32)\")\n                const transaction = {\n                    to: this.address,\n                    data: (\"0x3b3b57de\" + namehash(this.name).substring(2))\n                };\n                const hexBytes = await this.provider.call(transaction);\n\n                // No address\n                if (hexBytes === \"0x\" || hexBytes === HashZero) { return null; }\n\n                return this.provider.formatter.callAddress(hexBytes);\n            } catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n                throw error;\n            }\n        }\n\n        // keccak256(\"addr(bytes32,uint256\")\n        const hexBytes = await this._fetchBytes(\"0xf1cb7e06\", bytes32ify(coinType));\n\n        // No address\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        // Compute the address\n        const address = this._getAddress(coinType, hexBytes);\n\n        if (address == null) {\n            logger.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${ coinType })`,\n                coinType: coinType,\n                data: hexBytes\n            });\n        }\n\n        return address;\n    }\n\n    async getAvatar(): Promise<null | Avatar> {\n        const linkage: Array<{ type: string, content: string }> = [ ];\n        try {\n            const avatar = await this.getText(\"avatar\");\n            if (avatar == null) { return null; }\n\n            for (let i = 0; i < matchers.length; i++) {\n                const match = avatar.match(matchers[i]);\n\n                if (match == null) { continue; }\n                switch (match[1]) {\n                    case \"https\":\n                        linkage.push({ type: \"url\", content: avatar });\n                        return { linkage, url: avatar };\n\n                    case \"data\":\n                        linkage.push({ type: \"data\", content: avatar });\n                        return { linkage, url: avatar };\n\n                    case \"ipfs\":\n                        linkage.push({ type: \"ipfs\", content: avatar });\n                        return { linkage, url: `https:/\\/gateway.ipfs.io/ipfs/${ avatar.substring(7) }` }\n\n                    case \"erc721\":\n                    case \"erc1155\": {\n                        // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                        const selector = (match[1] === \"erc721\") ? \"0xc87b56dd\": \"0x0e89341c\";\n                        linkage.push({ type: match[1], content: avatar });\n\n                        // The owner of this name\n                        const owner = (this._resolvedAddress || await this.getAddress());\n\n                        const comps = (match[2] || \"\").split(\"/\");\n                        if (comps.length !== 2) { return null; }\n\n                        const addr = await this.provider.formatter.address(comps[0]);\n                        const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);\n\n                        // Check that this account owns the token\n                        if (match[1] === \"erc721\") {\n                            // ownerOf(uint256 tokenId)\n                            const tokenOwner = this.provider.formatter.callAddress(await this.provider.call({\n                                to: addr, data: hexConcat([ \"0x6352211e\", tokenId ])\n                            }));\n                            if (owner !== tokenOwner) { return null; }\n                            linkage.push({ type: \"owner\", content: tokenOwner });\n\n                        } else if (match[1] === \"erc1155\") {\n                            // balanceOf(address owner, uint256 tokenId)\n                            const balance = BigNumber.from(await this.provider.call({\n                                to: addr, data: hexConcat([ \"0x00fdd58e\", hexZeroPad(owner, 32), tokenId ])\n                            }));\n                            if (balance.isZero()) { return null; }\n                            linkage.push({ type: \"balance\", content: balance.toString() });\n                        }\n\n                        // Call the token contract for the metadata URL\n                        const tx = {\n                            to: this.provider.formatter.address(comps[0]),\n                            data: hexConcat([ selector, tokenId ])\n                        };\n                        let metadataUrl = _parseString(await this.provider.call(tx))\n                        if (metadataUrl == null) { return null; }\n                        linkage.push({ type: \"metadata-url\", content: metadataUrl });\n\n                        // ERC-1155 allows a generic {id} in the URL\n                        if (match[1] === \"erc1155\") {\n                            metadataUrl = metadataUrl.replace(\"{id}\", tokenId.substring(2));\n                        }\n\n                        // Get the token metadata\n                        const metadata = await fetchJson(metadataUrl);\n\n                        // Pull the image URL out\n                        if (!metadata || typeof(metadata.image) !== \"string\" || !metadata.image.match(/^https:\\/\\//i)) {\n                            return null;\n                        }\n                        linkage.push({ type: \"metadata\", content: JSON.stringify(metadata) });\n                        linkage.push({ type: \"url\", content: metadata.image });\n\n                        return { linkage, url: metadata.image };\n                    }\n                }\n            }\n        } catch (error) { }\n\n        return null;\n    }\n\n    async getContentHash(): Promise<string> {\n\n        // keccak256(\"contenthash()\")\n        const hexBytes = await this._fetchBytes(\"0xbc1c58d1\");\n\n        // No contenthash\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        // IPFS (CID: 1, Type: DAG-PB)\n        const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n        if (ipfs) {\n            const length = parseInt(ipfs[3], 16);\n            if (ipfs[4].length === length * 2) {\n                return \"ipfs:/\\/\" + Base58.encode(\"0x\" + ipfs[1]);\n            }\n        }\n\n        // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n        const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/)\n        if (swarm) {\n            if (swarm[1].length === (32 * 2)) {\n                return \"bzz:/\\/\" + swarm[1]\n            }\n        }\n\n        return logger.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"getContentHash()\",\n            data: hexBytes\n        });\n    }\n\n    async getText(key: string): Promise<string> {\n\n        // The key encoded as parameter to fetchBytes\n        let keyBytes = toUtf8Bytes(key);\n\n        // The nodehash consumes the first slot, so the string pointer targets\n        // offset 64, with the length at offset 64 and data starting at offset 96\n        keyBytes = concat([ bytes32ify(64), bytes32ify(keyBytes.length), keyBytes ]);\n\n        // Pad to word-size (32 bytes)\n        if ((keyBytes.length % 32) !== 0) {\n            keyBytes = concat([ keyBytes, hexZeroPad(\"0x\", 32 - (key.length % 32)) ])\n        }\n\n        const hexBytes = await this._fetchBytes(\"0x59d1d43c\", hexlify(keyBytes));\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        return toUtf8String(hexBytes);\n    }\n}\n\nlet defaultFormatter: Formatter = null;\n\nlet nextPollId = 1;\n\nexport class BaseProvider extends Provider implements EnsProvider {\n    _networkPromise: Promise<Network>;\n    _network: Network;\n\n    _events: Array<Event>;\n\n    formatter: Formatter;\n\n    // To help mitigate the eventually consistent nature of the blockchain\n    // we keep a mapping of events we emit. If we emit an event X, we expect\n    // that a user should be able to query for that event in the callback,\n    // if the node returns null, we stall the response until we get back a\n    // meaningful value, since we may be hitting a re-org, or a node that\n    // has not indexed the event yet.\n    // Events:\n    //   - t:{hash}    - Transaction hash\n    //   - b:{hash}    - BlockHash\n    //   - block       - The most recent emitted block\n    _emitted: { [ eventName: string ]: number | \"pending\" };\n\n    _pollingInterval: number;\n    _poller: NodeJS.Timer;\n    _bootstrapPoll: NodeJS.Timer;\n\n    _lastBlockNumber: number;\n\n    _fastBlockNumber: number;\n    _fastBlockNumberPromise: Promise<number>;\n    _fastQueryDate: number;\n\n    _maxInternalBlockNumber: number;\n    _internalBlockNumber: Promise<{ blockNumber: number, reqTime: number, respTime: number }>;\n\n    readonly anyNetwork: boolean;\n\n\n    /**\n     *  ready\n     *\n     *  A Promise<Network> that resolves only once the provider is ready.\n     *\n     *  Sub-classes that call the super with a network without a chainId\n     *  MUST set this. Standard named networks have a known chainId.\n     *\n     */\n\n    constructor(network: Networkish | Promise<Network>) {\n        logger.checkNew(new.target, Provider);\n\n        super();\n\n        // Events being listened to\n        this._events = [];\n\n        this._emitted = { block: -2 };\n\n        this.formatter = new.target.getFormatter();\n\n        // If network is any, this Provider allows the underlying\n        // network to change dynamically, and we auto-detect the\n        // current network\n        defineReadOnly(this, \"anyNetwork\", (network === \"any\"));\n        if (this.anyNetwork) { network = this.detectNetwork(); }\n\n        if (network instanceof Promise) {\n            this._networkPromise = network;\n\n            // Squash any \"unhandled promise\" errors; that do not need to be handled\n            network.catch((error) => { });\n\n            // Trigger initial network setting (async)\n            this._ready().catch((error) => { });\n\n        } else {\n            const knownNetwork = getStatic<(network: Networkish) => Network>(new.target, \"getNetwork\")(network);\n            if (knownNetwork) {\n                defineReadOnly(this, \"_network\", knownNetwork);\n                this.emit(\"network\", knownNetwork, null);\n\n            } else {\n                logger.throwArgumentError(\"invalid network\", \"network\", network);\n            }\n        }\n\n        this._maxInternalBlockNumber = -1024;\n\n        this._lastBlockNumber = -2;\n\n        this._pollingInterval = 4000;\n\n        this._fastQueryDate = 0;\n    }\n\n    async _ready(): Promise<Network> {\n        if (this._network == null) {\n            let network: Network = null;\n            if (this._networkPromise) {\n                try {\n                    network = await this._networkPromise;\n                } catch (error) { }\n            }\n\n            // Try the Provider's network detection (this MUST throw if it cannot)\n            if (network == null) {\n                network = await this.detectNetwork();\n            }\n\n            // This should never happen; every Provider sub-class should have\n            // suggested a network by here (or have thrown).\n            if (!network) {\n                logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, { });\n            }\n\n            // Possible this call stacked so do not call defineReadOnly again\n            if (this._network == null) {\n                if (this.anyNetwork) {\n                    this._network = network;\n                } else {\n                    defineReadOnly(this, \"_network\", network);\n                }\n                this.emit(\"network\", network, null);\n            }\n        }\n\n        return this._network;\n    }\n\n    // This will always return the most recently established network.\n    // For \"any\", this can change (a \"network\" event is emitted before\n    // any change is reflected); otherwise this cannot change\n    get ready(): Promise<Network> {\n        return poll(() => {\n            return this._ready().then((network) => {\n                return network;\n            }, (error) => {\n                // If the network isn't running yet, we will wait\n                if (error.code === Logger.errors.NETWORK_ERROR && error.event === \"noNetwork\") {\n                    return undefined;\n                }\n                throw error;\n            });\n        });\n    }\n\n    // @TODO: Remove this and just create a singleton formatter\n    static getFormatter(): Formatter {\n        if (defaultFormatter == null) {\n            defaultFormatter = new Formatter();\n        }\n        return defaultFormatter;\n    }\n\n    // @TODO: Remove this and just use getNetwork\n    static getNetwork(network: Networkish): Network {\n        return getNetwork((network == null) ? \"homestead\": network);\n    }\n\n    // Fetches the blockNumber, but will reuse any result that is less\n    // than maxAge old or has been requested since the last request\n    async _getInternalBlockNumber(maxAge: number): Promise<number> {\n        await this._ready();\n\n        // Allowing stale data up to maxAge old\n        if (maxAge > 0) {\n\n            // While there are pending internal block requests...\n            while (this._internalBlockNumber) {\n\n                // ...\"remember\" which fetch we started with\n                const internalBlockNumber = this._internalBlockNumber;\n\n                try {\n                    // Check the result is not too stale\n                    const result = await internalBlockNumber;\n                    if ((getTime() - result.respTime) <= maxAge) {\n                        return result.blockNumber;\n                    }\n\n                    // Too old; fetch a new value\n                    break;\n\n                } catch(error) {\n\n                    // The fetch rejected; if we are the first to get the\n                    // rejection, drop through so we replace it with a new\n                    // fetch; all others blocked will then get that fetch\n                    // which won't match the one they \"remembered\" and loop\n                    if (this._internalBlockNumber === internalBlockNumber) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        const reqTime = getTime();\n\n        const checkInternalBlockNumber = resolveProperties({\n            blockNumber: this.perform(\"getBlockNumber\", { }),\n            networkError: this.getNetwork().then((network) => (null), (error) => (error))\n        }).then(({ blockNumber, networkError }) => {\n            if (networkError) {\n                // Unremember this bad internal block number\n                if (this._internalBlockNumber === checkInternalBlockNumber) {\n                    this._internalBlockNumber = null;\n                }\n                throw networkError;\n            }\n\n            const respTime = getTime();\n\n            blockNumber = BigNumber.from(blockNumber).toNumber();\n            if (blockNumber < this._maxInternalBlockNumber) { blockNumber = this._maxInternalBlockNumber; }\n\n            this._maxInternalBlockNumber = blockNumber;\n            this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n            return { blockNumber, reqTime, respTime };\n        });\n\n        this._internalBlockNumber = checkInternalBlockNumber;\n\n        // Swallow unhandled exceptions; if needed they are handled else where\n        checkInternalBlockNumber.catch((error) => {\n            // Don't null the dead (rejected) fetch, if it has already been updated\n            if (this._internalBlockNumber === checkInternalBlockNumber) {\n                this._internalBlockNumber = null;\n            }\n        });\n\n        return (await checkInternalBlockNumber).blockNumber;\n    }\n\n    async poll(): Promise<void> {\n        const pollId = nextPollId++;\n\n        // Track all running promises, so we can trigger a post-poll once they are complete\n        const runners: Array<Promise<void>> = [];\n\n        let blockNumber: number = null;\n        try {\n            blockNumber = await this._getInternalBlockNumber(100 + this.pollingInterval / 2);\n        } catch (error) {\n            this.emit(\"error\", error);\n            return;\n        }\n        this._setFastBlockNumber(blockNumber);\n\n        // Emit a poll event after we have the latest (fast) block number\n        this.emit(\"poll\", pollId, blockNumber);\n\n        // If the block has not changed, meh.\n        if (blockNumber === this._lastBlockNumber) {\n            this.emit(\"didPoll\", pollId);\n            return;\n        }\n\n        // First polling cycle, trigger a \"block\" events\n        if (this._emitted.block === -2) {\n            this._emitted.block = blockNumber - 1;\n        }\n\n        if (Math.abs((<number>(this._emitted.block)) - blockNumber) > 1000) {\n            logger.warn(`network block skew detected; skipping block events (emitted=${ this._emitted.block } blockNumber${ blockNumber })`);\n            this.emit(\"error\", logger.makeError(\"network block skew detected\", Logger.errors.NETWORK_ERROR, {\n                blockNumber: blockNumber,\n                event: \"blockSkew\",\n                previousBlockNumber: this._emitted.block\n            }));\n            this.emit(\"block\", blockNumber);\n\n        } else {\n            // Notify all listener for each block that has passed\n            for (let i = (<number>this._emitted.block) + 1; i <= blockNumber; i++) {\n                this.emit(\"block\", i);\n            }\n        }\n\n        // The emitted block was updated, check for obsolete events\n        if ((<number>this._emitted.block) !== blockNumber) {\n            this._emitted.block = blockNumber;\n\n            Object.keys(this._emitted).forEach((key) => {\n                // The block event does not expire\n                if (key === \"block\") { return; }\n\n                // The block we were at when we emitted this event\n                const eventBlockNumber = this._emitted[key];\n\n                // We cannot garbage collect pending transactions or blocks here\n                // They should be garbage collected by the Provider when setting\n                // \"pending\" events\n                if (eventBlockNumber === \"pending\") { return; }\n\n                // Evict any transaction hashes or block hashes over 12 blocks\n                // old, since they should not return null anyways\n                if (blockNumber - eventBlockNumber > 12) {\n                    delete this._emitted[key];\n                }\n            });\n        }\n\n        // First polling cycle\n        if (this._lastBlockNumber === -2) {\n            this._lastBlockNumber = blockNumber - 1;\n        }\n\n        // Find all transaction hashes we are waiting on\n        this._events.forEach((event) => {\n            switch (event.type) {\n                case \"tx\": {\n                    const hash = event.hash;\n                    let runner = this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt || receipt.blockNumber == null) { return null; }\n                        this._emitted[\"t:\" + hash] = receipt.blockNumber;\n                        this.emit(hash, receipt);\n                        return null;\n                    }).catch((error: Error) => { this.emit(\"error\", error); });\n\n                    runners.push(runner);\n\n                    break;\n                }\n\n                case \"filter\": {\n                    const filter = event.filter;\n                    filter.fromBlock = this._lastBlockNumber + 1;\n                    filter.toBlock = blockNumber;\n\n                    const runner = this.getLogs(filter).then((logs) => {\n                        if (logs.length === 0) { return; }\n                        logs.forEach((log: Log) => {\n                            this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n                            this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n                            this.emit(filter, log);\n                        });\n                    }).catch((error: Error) => { this.emit(\"error\", error); });\n                    runners.push(runner);\n\n                    break;\n                }\n            }\n        });\n\n        this._lastBlockNumber = blockNumber;\n\n        // Once all events for this loop have been processed, emit \"didPoll\"\n        Promise.all(runners).then(() => {\n            this.emit(\"didPoll\", pollId);\n        }).catch((error) => { this.emit(\"error\", error); });\n\n        return;\n    }\n\n    // Deprecated; do not use this\n    resetEventsBlock(blockNumber: number): void {\n        this._lastBlockNumber = blockNumber - 1;\n        if (this.polling) { this.poll(); }\n    }\n\n    get network(): Network {\n        return this._network;\n    }\n\n    // This method should query the network if the underlying network\n    // can change, such as when connected to a JSON-RPC backend\n    async detectNetwork(): Promise<Network> {\n        return logger.throwError(\"provider does not support network detection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"provider.detectNetwork\"\n        });\n    }\n\n    async getNetwork(): Promise<Network> {\n        const network = await this._ready();\n\n        // Make sure we are still connected to the same network; this is\n        // only an external call for backends which can have the underlying\n        // network change spontaneously\n        const currentNetwork = await this.detectNetwork();\n        if (network.chainId !== currentNetwork.chainId) {\n\n            // We are allowing network changes, things can get complex fast;\n            // make sure you know what you are doing if you use \"any\"\n            if (this.anyNetwork) {\n                this._network = currentNetwork;\n\n                // Reset all internal block number guards and caches\n                this._lastBlockNumber = -2;\n                this._fastBlockNumber = null;\n                this._fastBlockNumberPromise = null;\n                this._fastQueryDate = 0;\n                this._emitted.block = -2;\n                this._maxInternalBlockNumber = -1024;\n                this._internalBlockNumber = null;\n\n                // The \"network\" event MUST happen before this method resolves\n                // so any events have a chance to unregister, so we stall an\n                // additional event loop before returning from /this/ call\n                this.emit(\"network\", currentNetwork, network);\n                await stall(0);\n\n                return this._network;\n            }\n\n            const error = logger.makeError(\"underlying network changed\", Logger.errors.NETWORK_ERROR, {\n                event: \"changed\",\n                network: network,\n                detectedNetwork: currentNetwork\n            });\n\n            this.emit(\"error\", error);\n            throw error;\n        }\n\n        return network;\n    }\n\n    get blockNumber(): number {\n        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {\n            this._setFastBlockNumber(blockNumber);\n        }, (error) => { });\n\n        return (this._fastBlockNumber != null) ? this._fastBlockNumber: -1;\n    }\n\n    get polling(): boolean {\n        return (this._poller != null);\n    }\n\n    set polling(value: boolean) {\n        if (value && !this._poller) {\n            this._poller = setInterval(() => { this.poll(); }, this.pollingInterval);\n\n            if (!this._bootstrapPoll) {\n                this._bootstrapPoll = setTimeout(() => {\n                    this.poll();\n\n                    // We block additional polls until the polling interval\n                    // is done, to prevent overwhelming the poll function\n                    this._bootstrapPoll = setTimeout(() => {\n                        // If polling was disabled, something may require a poke\n                        // since starting the bootstrap poll and it was disabled\n                        if (!this._poller) { this.poll(); }\n\n                        // Clear out the bootstrap so we can do another\n                        this._bootstrapPoll = null;\n                    }, this.pollingInterval);\n                }, 0);\n            }\n\n        } else if (!value && this._poller) {\n            clearInterval(this._poller);\n            this._poller = null;\n        }\n    }\n\n    get pollingInterval(): number {\n        return this._pollingInterval;\n    }\n\n    set pollingInterval(value: number) {\n        if (typeof(value) !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n            throw new Error(\"invalid polling interval\");\n        }\n\n        this._pollingInterval = value;\n\n        if (this._poller) {\n            clearInterval(this._poller);\n            this._poller = setInterval(() => { this.poll(); }, this._pollingInterval);\n        }\n    }\n\n    _getFastBlockNumber(): Promise<number> {\n        const now = getTime();\n\n        // Stale block number, request a newer value\n        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {\n            this._fastQueryDate = now;\n            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {\n                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n                    this._fastBlockNumber = blockNumber;\n                }\n                return this._fastBlockNumber;\n            });\n        }\n\n        return this._fastBlockNumberPromise;\n    }\n\n    _setFastBlockNumber(blockNumber: number): void {\n        // Older block, maybe a stale request\n        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) { return; }\n\n        // Update the time we updated the blocknumber\n        this._fastQueryDate = getTime();\n\n        // Newer block number, use  it\n        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n            this._fastBlockNumber = blockNumber;\n            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n        }\n    }\n\n    async waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number): Promise<TransactionReceipt> {\n        return this._waitForTransaction(transactionHash, (confirmations == null) ? 1: confirmations, timeout || 0, null);\n    }\n\n    async _waitForTransaction(transactionHash: string, confirmations: number, timeout: number, replaceable: { data: string, from: string, nonce: number, to: string, value: BigNumber, startBlock: number }): Promise<TransactionReceipt> {\n        const receipt = await this.getTransactionReceipt(transactionHash);\n\n        // Receipt is already good\n        if ((receipt ? receipt.confirmations: 0) >= confirmations) { return receipt; }\n\n        // Poll until the receipt is good...\n        return new Promise((resolve, reject) => {\n            const cancelFuncs: Array<() => void> = [];\n\n            let done = false;\n            const alreadyDone = function() {\n                if (done) { return true; }\n                done = true;\n                cancelFuncs.forEach((func) => { func(); });\n                return false;\n            };\n\n            const minedHandler = (receipt: TransactionReceipt) => {\n                if (receipt.confirmations < confirmations) { return; }\n                if (alreadyDone()) { return; }\n                resolve(receipt);\n            }\n            this.on(transactionHash, minedHandler);\n            cancelFuncs.push(() => { this.removeListener(transactionHash, minedHandler); });\n\n            if (replaceable) {\n                let lastBlockNumber = replaceable.startBlock;\n                let scannedBlock: number = null;\n                const replaceHandler = async (blockNumber: number) => {\n                    if (done) { return; }\n\n                    // Wait 1 second; this is only used in the case of a fault, so\n                    // we will trade off a little bit of latency for more consistent\n                    // results and fewer JSON-RPC calls\n                    await stall(1000);\n\n                    this.getTransactionCount(replaceable.from).then(async (nonce) => {\n                        if (done) { return; }\n\n                        if (nonce <= replaceable.nonce) {\n                            lastBlockNumber = blockNumber;\n\n                        } else {\n                            // First check if the transaction was mined\n                            {\n                                const mined = await this.getTransaction(transactionHash);\n                                if (mined && mined.blockNumber != null) { return; }\n                            }\n\n                            // First time scanning. We start a little earlier for some\n                            // wiggle room here to handle the eventually consistent nature\n                            // of blockchain (e.g. the getTransactionCount was for a\n                            // different block)\n                            if (scannedBlock == null) {\n                                scannedBlock = lastBlockNumber - 3;\n                                if (scannedBlock < replaceable.startBlock) {\n                                    scannedBlock = replaceable.startBlock;\n                                }\n                            }\n\n                            while (scannedBlock <= blockNumber) {\n                                if (done) { return; }\n\n                                const block = await this.getBlockWithTransactions(scannedBlock);\n                                for (let ti = 0; ti < block.transactions.length; ti++) {\n                                    const tx = block.transactions[ti];\n\n                                    // Successfully mined!\n                                    if (tx.hash === transactionHash) { return; }\n\n                                    // Matches our transaction from and nonce; its a replacement\n                                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {\n                                        if (done) { return; }\n\n                                        // Get the receipt of the replacement\n                                        const receipt = await this.waitForTransaction(tx.hash, confirmations);\n\n                                        // Already resolved or rejected (prolly a timeout)\n                                        if (alreadyDone()) { return; }\n\n                                        // The reason we were replaced\n                                        let reason = \"replaced\";\n                                        if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {\n                                            reason = \"repriced\";\n                                        } else  if (tx.data === \"0x\" && tx.from === tx.to && tx.value.isZero()) {\n                                            reason = \"cancelled\"\n                                        }\n\n                                        // Explain why we were replaced\n                                        reject(logger.makeError(\"transaction was replaced\", Logger.errors.TRANSACTION_REPLACED, {\n                                            cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                                            reason,\n                                            replacement: this._wrapTransaction(tx),\n                                            hash: transactionHash,\n                                            receipt\n                                        }));\n\n                                        return;\n                                    }\n                                }\n                                scannedBlock++;\n                            }\n                        }\n\n                        if (done) { return; }\n                        this.once(\"block\", replaceHandler);\n\n                    }, (error) => {\n                        if (done) { return; }\n                        this.once(\"block\", replaceHandler);\n                    });\n                };\n\n                if (done) { return; }\n                this.once(\"block\", replaceHandler);\n\n                cancelFuncs.push(() => {\n                    this.removeListener(\"block\", replaceHandler);\n                });\n            }\n\n            if (typeof(timeout) === \"number\" && timeout > 0) {\n                const timer = setTimeout(() => {\n                    if (alreadyDone()) { return; }\n                    reject(logger.makeError(\"timeout exceeded\", Logger.errors.TIMEOUT, { timeout: timeout }));\n                }, timeout);\n                if (timer.unref) { timer.unref(); }\n\n                cancelFuncs.push(() => { clearTimeout(timer); });\n            }\n        });\n    }\n\n    async getBlockNumber(): Promise<number> {\n        return this._getInternalBlockNumber(0);\n    }\n\n    async getGasPrice(): Promise<BigNumber> {\n        await this.getNetwork();\n\n        const result = await this.perform(\"getGasPrice\", { });\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getGasPrice\",\n                result, error\n            });\n        }\n    }\n\n    async getBalance(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<BigNumber> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getBalance\", params);\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getBalance\",\n                params, result, error\n            });\n        }\n    }\n\n    async getTransactionCount(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<number> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getTransactionCount\", params);\n        try {\n            return BigNumber.from(result).toNumber();\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getTransactionCount\",\n                params, result, error\n            });\n        }\n    }\n\n    async getCode(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getCode\", params);\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getCode\",\n                params, result, error\n            });\n        }\n    }\n\n    async getStorageAt(addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag),\n            position: Promise.resolve(position).then((p) => hexValue(p))\n        });\n        const result = await this.perform(\"getStorageAt\", params);\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getStorageAt\",\n                params, result, error\n            });\n        }\n    }\n\n    // This should be called by any subclass wrapping a TransactionResponse\n    _wrapTransaction(tx: Transaction, hash?: string, startBlock?: number): TransactionResponse {\n        if (hash != null && hexDataLength(hash) !== 32) { throw new Error(\"invalid response - sendTransaction\"); }\n\n        const result = <TransactionResponse>tx;\n\n        // Check the hash we expect is the same as the hash the server reported\n        if (hash != null && tx.hash !== hash) {\n            logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });\n        }\n\n        result.wait = async (confirms?: number, timeout?: number) => {\n            if (confirms == null) { confirms = 1; }\n            if (timeout == null) { timeout = 0; }\n\n            // Get the details to detect replacement\n            let replacement = undefined;\n            if (confirms !== 0 && startBlock != null) {\n                replacement = {\n                    data: tx.data,\n                    from: tx.from,\n                    nonce: tx.nonce,\n                    to: tx.to,\n                    value: tx.value,\n                    startBlock\n                };\n            }\n\n            const receipt = await this._waitForTransaction(tx.hash, confirms, timeout, replacement);\n            if (receipt == null && confirms === 0) { return null; }\n\n            // No longer pending, allow the polling loop to garbage collect this\n            this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n\n            if (receipt.status === 0) {\n                logger.throwError(\"transaction failed\", Logger.errors.CALL_EXCEPTION, {\n                    transactionHash: tx.hash,\n                    transaction: tx,\n                    receipt: receipt\n                });\n            }\n            return receipt;\n        };\n\n        return result;\n    }\n\n    async sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse> {\n        await this.getNetwork();\n        const hexTx = await Promise.resolve(signedTransaction).then(t => hexlify(t));\n        const tx = this.formatter.transaction(signedTransaction);\n        if (tx.confirmations == null) { tx.confirmations = 0; }\n        const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n        try {\n            const hash = await this.perform(\"sendTransaction\", { signedTransaction: hexTx });\n            return this._wrapTransaction(tx, hash, blockNumber);\n        } catch (error) {\n            (<any>error).transaction = tx;\n            (<any>error).transactionHash = tx.hash;\n            throw error;\n        }\n    }\n\n    async _getTransactionRequest(transaction: Deferrable<TransactionRequest>): Promise<Transaction> {\n        const values: any = await transaction;\n\n        const tx: any = { };\n\n        [\"from\", \"to\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? this._getAddress(v): null))\n        });\n\n        [\"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"value\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? BigNumber.from(v): null));\n        });\n\n        [\"type\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => ((v != null) ? v: null));\n        });\n\n        if (values.accessList) {\n            tx.accessList = this.formatter.accessList(values.accessList);\n        }\n\n        [\"data\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? hexlify(v): null));\n        });\n\n        return this.formatter.transactionRequest(await resolveProperties(tx));\n    }\n\n    async _getFilter(filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>): Promise<Filter | FilterByBlockHash> {\n        filter = await filter;\n\n        const result: any = { };\n\n        if (filter.address != null) {\n            result.address = this._getAddress(filter.address);\n        }\n\n        [\"blockHash\", \"topics\"].forEach((key) => {\n            if ((<any>filter)[key] == null) { return; }\n            result[key] = (<any>filter)[key];\n        });\n\n        [\"fromBlock\", \"toBlock\"].forEach((key) => {\n            if ((<any>filter)[key] == null) { return; }\n            result[key] = this._getBlockTag((<any>filter)[key]);\n        });\n\n        return this.formatter.filter(await resolveProperties(result));\n    }\n\n    async call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            transaction: this._getTransactionRequest(transaction),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"call\", params);\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"call\",\n                params, result, error\n            });\n        }\n    }\n\n    async estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            transaction: this._getTransactionRequest(transaction)\n        });\n\n        const result = await this.perform(\"estimateGas\", params);\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"estimateGas\",\n                params, result, error\n            });\n        }\n    }\n\n    async _getAddress(addressOrName: string | Promise<string>): Promise<string> {\n        addressOrName = await addressOrName;\n        if (typeof(addressOrName) !== \"string\") {\n            logger.throwArgumentError(\"invalid address or ENS name\", \"name\", addressOrName);\n        }\n\n        const address = await this.resolveName(addressOrName);\n        if (address == null) {\n            logger.throwError(\"ENS name not configured\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `resolveName(${ JSON.stringify(addressOrName) })`\n            });\n        }\n        return address;\n    }\n\n    async _getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>, includeTransactions?: boolean): Promise<Block | BlockWithTransactions> {\n        await this.getNetwork();\n\n        blockHashOrBlockTag = await blockHashOrBlockTag;\n\n        // If blockTag is a number (not \"latest\", etc), this is the block number\n        let blockNumber = -128;\n\n        const params: { [key: string]: any } = {\n            includeTransactions: !!includeTransactions\n        };\n\n        if (isHexString(blockHashOrBlockTag, 32)) {\n            params.blockHash = blockHashOrBlockTag;\n        } else {\n            try {\n                params.blockTag = await this._getBlockTag(blockHashOrBlockTag);\n                if (isHexString(params.blockTag)) {\n                    blockNumber = parseInt(params.blockTag.substring(2), 16);\n                }\n            } catch (error) {\n                logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n            }\n        }\n\n        return poll(async () => {\n            const block = await this.perform(\"getBlock\", params);\n\n            // Block was not found\n            if (block == null) {\n\n                // For blockhashes, if we didn't say it existed, that blockhash may\n                // not exist. If we did see it though, perhaps from a log, we know\n                // it exists, and this node is just not caught up yet.\n                if (params.blockHash != null) {\n                    if (this._emitted[\"b:\" + params.blockHash] == null) { return null; }\n                }\n\n                // For block tags, if we are asking for a future block, we return null\n                if (params.blockTag != null) {\n                    if (blockNumber > this._emitted.block) { return null; }\n                }\n\n                // Retry on the next block\n                return undefined;\n            }\n\n            // Add transactions\n            if (includeTransactions) {\n                let blockNumber: number = null;\n                for (let i = 0; i < block.transactions.length; i++) {\n                    const tx = block.transactions[i];\n                    if (tx.blockNumber == null) {\n                        tx.confirmations = 0;\n\n                    } else if (tx.confirmations == null) {\n                        if (blockNumber == null) {\n                            blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                        }\n\n                        // Add the confirmations using the fast block number (pessimistic)\n                        let confirmations = (blockNumber - tx.blockNumber) + 1;\n                        if (confirmations <= 0) { confirmations = 1; }\n                        tx.confirmations = confirmations;\n                    }\n                }\n\n                const blockWithTxs: any = this.formatter.blockWithTransactions(block);\n                blockWithTxs.transactions = blockWithTxs.transactions.map((tx: TransactionResponse) => this._wrapTransaction(tx));\n                return blockWithTxs;\n            }\n\n            return this.formatter.block(block);\n\n        }, { oncePoll: this });\n    }\n\n    getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block> {\n        return <Promise<Block>>(this._getBlock(blockHashOrBlockTag, false));\n    }\n\n    getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<BlockWithTransactions> {\n        return <Promise<BlockWithTransactions>>(this._getBlock(blockHashOrBlockTag, true));\n    }\n\n    async getTransaction(transactionHash: string | Promise<string>): Promise<TransactionResponse> {\n        await this.getNetwork();\n        transactionHash = await transactionHash;\n\n        const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n\n        return poll(async () => {\n            const result = await this.perform(\"getTransaction\", params);\n\n            if (result == null) {\n                if (this._emitted[\"t:\" + transactionHash] == null) {\n                    return null;\n                }\n                return undefined;\n            }\n\n            const tx = this.formatter.transactionResponse(result);\n\n            if (tx.blockNumber == null) {\n                tx.confirmations = 0;\n\n            } else if (tx.confirmations == null) {\n                const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n\n                // Add the confirmations using the fast block number (pessimistic)\n                let confirmations = (blockNumber - tx.blockNumber) + 1;\n                if (confirmations <= 0) { confirmations = 1; }\n                tx.confirmations = confirmations;\n            }\n\n            return this._wrapTransaction(tx);\n        }, { oncePoll: this });\n    }\n\n    async getTransactionReceipt(transactionHash: string | Promise<string>): Promise<TransactionReceipt> {\n        await this.getNetwork();\n\n        transactionHash = await transactionHash;\n\n        const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n\n        return poll(async () => {\n            const result = await this.perform(\"getTransactionReceipt\", params);\n\n            if (result == null) {\n                if (this._emitted[\"t:\" + transactionHash] == null) {\n                    return null;\n                }\n                return undefined;\n            }\n\n            // \"geth-etc\" returns receipts before they are ready\n            if (result.blockHash == null) { return undefined; }\n\n            const receipt = this.formatter.receipt(result);\n\n            if (receipt.blockNumber == null) {\n                receipt.confirmations = 0;\n\n            } else if (receipt.confirmations == null) {\n                const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n\n                // Add the confirmations using the fast block number (pessimistic)\n                let confirmations = (blockNumber - receipt.blockNumber) + 1;\n                if (confirmations <= 0) { confirmations = 1; }\n                receipt.confirmations = confirmations;\n            }\n\n            return receipt;\n        }, { oncePoll: this });\n    }\n\n    async getLogs(filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>): Promise<Array<Log>> {\n        await this.getNetwork();\n        const params = await resolveProperties({ filter: this._getFilter(filter) });\n        const logs: Array<Log> = await this.perform(\"getLogs\", params);\n        logs.forEach((log) => {\n            if (log.removed == null) { log.removed = false; }\n        });\n        return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n    }\n\n    async getEtherPrice(): Promise<number> {\n        await this.getNetwork();\n        return this.perform(\"getEtherPrice\", { });\n    }\n\n    async _getBlockTag(blockTag: BlockTag | Promise<BlockTag>): Promise<BlockTag> {\n        blockTag = await blockTag;\n\n        if (typeof(blockTag) === \"number\" && blockTag < 0) {\n            if (blockTag % 1) {\n                logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n            }\n\n            let blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n            blockNumber += blockTag;\n            if (blockNumber < 0) { blockNumber = 0; }\n            return this.formatter.blockTag(blockNumber)\n        }\n\n        return this.formatter.blockTag(blockTag);\n    }\n\n\n    async getResolver(name: string): Promise<null | Resolver> {\n        try {\n            const address = await this._getResolver(name);\n            if (address == null) { return null; }\n            return new Resolver(this, address, name);\n        } catch (error) {\n            if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n            return null;\n        }\n    }\n\n    async _getResolver(name: string): Promise<string> {\n        // Get the resolver from the blockchain\n        const network = await this.getNetwork();\n\n        // No ENS...\n        if (!network.ensAddress) {\n            logger.throwError(\n                \"network does not support ENS\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { operation: \"ENS\", network: network.name }\n            );\n        }\n\n        // keccak256(\"resolver(bytes32)\")\n        const transaction = {\n            to: network.ensAddress,\n            data: (\"0x0178b8bf\" + namehash(name).substring(2))\n        };\n\n        try {\n            return this.formatter.callAddress(await this.call(transaction));\n        } catch (error) {\n            if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n            throw error;\n        }\n    }\n\n    async resolveName(name: string | Promise<string>): Promise<null | string> {\n        name = await name;\n\n        // If it is already an address, nothing to resolve\n        try {\n            return Promise.resolve(this.formatter.address(name));\n        } catch (error) {\n            // If is is a hexstring, the address is bad (See #694)\n            if (isHexString(name)) { throw error; }\n        }\n\n        if (typeof(name) !== \"string\") {\n            logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n        }\n\n        // Get the addr from the resovler\n        const resolver = await this.getResolver(name);\n        if (!resolver) { return null; }\n\n        return await resolver.getAddress();\n    }\n\n    async lookupAddress(address: string | Promise<string>): Promise<null | string> {\n        address = await address;\n        address = this.formatter.address(address);\n\n        const reverseName = address.substring(2).toLowerCase() + \".addr.reverse\";\n\n        const resolverAddress = await this._getResolver(reverseName);\n        if (!resolverAddress) { return null; }\n\n        // keccak(\"name(bytes32)\")\n        let bytes = arrayify(await this.call({\n            to: resolverAddress,\n            data: (\"0x691f3431\" + namehash(reverseName).substring(2))\n        }));\n\n        // Strip off the dynamic string pointer (0x20)\n        if (bytes.length < 32 || !BigNumber.from(bytes.slice(0, 32)).eq(32)) { return null; }\n        bytes = bytes.slice(32);\n\n        // Not a length-prefixed string\n        if (bytes.length < 32) { return null; }\n\n        // Get the length of the string (from the length-prefix)\n        const length = BigNumber.from(bytes.slice(0, 32)).toNumber();\n        bytes = bytes.slice(32);\n\n        // Length longer than available data\n        if (length > bytes.length) { return null; }\n\n        const name = toUtf8String(bytes.slice(0, length));\n\n        // Make sure the reverse record matches the foward record\n        const addr = await this.resolveName(name);\n        if (addr != address) { return null; }\n\n        return name;\n    }\n\n    async getAvatar(nameOrAddress: string): Promise<null | string> {\n        let resolver: Resolver = null;\n        if (isHexString(nameOrAddress)) {\n            // Address; reverse lookup\n            const address = this.formatter.address(nameOrAddress);\n\n            const reverseName = address.substring(2).toLowerCase() + \".addr.reverse\";\n\n            const resolverAddress = await this._getResolver(reverseName);\n            if (!resolverAddress) { return null; }\n\n            resolver = new Resolver(this, resolverAddress, \"_\", address);\n\n        } else {\n            // ENS name; forward lookup\n            resolver = await this.getResolver(nameOrAddress);\n        }\n\n        const avatar = await resolver.getAvatar();\n        if (avatar == null) { return null; }\n\n        return avatar.url;\n    }\n\n    perform(method: string, params: any): Promise<any> {\n        return logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n    }\n\n    _startEvent(event: Event): void {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n\n    _stopEvent(event: Event): void {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n\n    _addEventListener(eventName: EventType, listener: Listener, once: boolean): this {\n        const event = new Event(getEventTag(eventName), listener, once)\n        this._events.push(event);\n        this._startEvent(event);\n\n        return this;\n    }\n\n    on(eventName: EventType, listener: Listener): this {\n        return this._addEventListener(eventName, listener, false);\n    }\n\n    once(eventName: EventType, listener: Listener): this {\n        return this._addEventListener(eventName, listener, true);\n    }\n\n\n    emit(eventName: EventType, ...args: Array<any>): boolean {\n        let result = false;\n\n        let stopped: Array<Event> = [ ];\n\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag) { return true; }\n\n            setTimeout(() => {\n                event.listener.apply(this, args);\n            }, 0);\n\n            result = true;\n\n            if (event.once) {\n                stopped.push(event);\n                return false;\n            }\n\n            return true;\n        });\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return result;\n    }\n\n    listenerCount(eventName?: EventType): number {\n        if (!eventName) { return this._events.length; }\n\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event) => {\n            return (event.tag === eventTag);\n        }).length;\n    }\n\n    listeners(eventName?: EventType): Array<Listener> {\n        if (eventName == null) {\n            return this._events.map((event) => event.listener);\n        }\n\n        let eventTag = getEventTag(eventName);\n        return this._events\n            .filter((event) => (event.tag === eventTag))\n            .map((event) => event.listener);\n    }\n\n    off(eventName: EventType, listener?: Listener): this {\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n\n        const stopped: Array<Event> = [ ];\n\n        let found = false;\n\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag || event.listener != listener) { return true; }\n            if (found) { return true; }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return this;\n    }\n\n    removeAllListeners(eventName?: EventType): this {\n        let stopped: Array<Event> = [ ];\n        if (eventName == null) {\n            stopped = this._events;\n\n            this._events = [ ];\n        } else {\n            const eventTag = getEventTag(eventName);\n            this._events = this._events.filter((event) => {\n                if (event.tag !== eventTag) { return true; }\n                stopped.push(event);\n                return false;\n            });\n        }\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return this;\n    }\n}\n","export const HashZero = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n\n","\"use strict\";\n\n// See: https://github.com/ethereum/wiki/wiki/JSON-RPC\n\nimport { Provider, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { Signer, TypedDataDomain, TypedDataField, TypedDataSigner } from \"@ethersproject/abstract-signer\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { Bytes, hexlify, hexValue, isHexString } from \"@ethersproject/bytes\";\nimport { _TypedDataEncoder } from \"@ethersproject/hash\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { checkProperties, deepCopy, Deferrable, defineReadOnly, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { AccessList, accessListify } from \"@ethersproject/transactions\";\nimport { ConnectionInfo, fetchJson, poll } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { BaseProvider, Event } from \"./base-provider\";\n\n\nconst errorGas = [ \"call\", \"estimateGas\" ];\n\nfunction checkError(method: string, error: any, params: any): any {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === Logger.errors.SERVER_ERROR) {\n        const e = error.error;\n        if (e && e.message.match(\"reverted\") && isHexString(e.data)) {\n            return e.data;\n        }\n\n        logger.throwError(\"missing revert data in call exception\", Logger.errors.CALL_EXCEPTION, {\n            error, data: \"0x\"\n        });\n    }\n\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof(error.error.message) === \"string\") {\n        message = error.error.message;\n    } else if (typeof(error.body) === \"string\") {\n        message = error.body;\n    } else if (typeof(error.responseText) === \"string\") {\n        message = error.responseText;\n    }\n    message = (message || \"\").toLowerCase();\n\n    const transaction = params.transaction || params.signedTransaction;\n\n    // \"insufficient funds for gas * price + value + cost(data)\"\n    if (message.match(/insufficient funds|base fee exceeds gas limit/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n            error, method, transaction\n        });\n    }\n\n    // \"nonce too low\"\n    if (message.match(/nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n            error, method, transaction\n        });\n    }\n\n    // \"replacement transaction underpriced\"\n    if (message.match(/replacement transaction underpriced/)) {\n        logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n        });\n    }\n\n    // \"replacement transaction underpriced\"\n    if (message.match(/only replay-protected/)) {\n        logger.throwError(\"legacy pre-eip-155 transactions not supported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            error, method, transaction\n        });\n    }\n\n    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n\n    throw error;\n}\n\nfunction timer(timeout: number): Promise<any> {\n    return new Promise(function(resolve) {\n        setTimeout(resolve, timeout);\n    });\n}\n\nfunction getResult(payload: { error?: { code?: number, data?: any, message?: string }, result?: any }): any {\n    if (payload.error) {\n        // @TODO: not any\n        const error: any = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n\n    return payload.result;\n}\n\nfunction getLowerCase(value: string): string {\n    if (value) { return value.toLowerCase(); }\n    return value;\n}\n\nconst _constructorGuard = {};\n\nexport class JsonRpcSigner extends Signer implements TypedDataSigner {\n    readonly provider: JsonRpcProvider;\n    _index: number;\n    _address: string;\n\n    constructor(constructorGuard: any, provider: JsonRpcProvider, addressOrIndex?: string | number) {\n        logger.checkNew(new.target, JsonRpcSigner);\n\n        super();\n\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n        }\n\n        defineReadOnly(this, \"provider\", provider);\n\n        if (addressOrIndex == null) { addressOrIndex = 0; }\n\n        if (typeof(addressOrIndex) === \"string\") {\n            defineReadOnly(this, \"_address\", this.provider.formatter.address(addressOrIndex));\n            defineReadOnly(this, \"_index\", null);\n\n        } else if (typeof(addressOrIndex) === \"number\") {\n            defineReadOnly(this, \"_index\", addressOrIndex);\n            defineReadOnly(this, \"_address\", null);\n\n        } else {\n            logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n        }\n    }\n\n    connect(provider: Provider): JsonRpcSigner {\n        return logger.throwError(\"cannot alter JSON-RPC Signer connection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"connect\"\n        });\n    }\n\n    connectUnchecked(): JsonRpcSigner {\n        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n    }\n\n    getAddress(): Promise<string> {\n        if (this._address) {\n            return Promise.resolve(this._address);\n        }\n\n        return this.provider.send(\"eth_accounts\", []).then((accounts) => {\n            if (accounts.length <= this._index) {\n                logger.throwError(\"unknown account #\" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"getAddress\"\n                });\n            }\n            return this.provider.formatter.address(accounts[this._index])\n        });\n    }\n\n    sendUncheckedTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        transaction = shallowCopy(transaction);\n\n        const fromAddress = this.getAddress().then((address) => {\n            if (address) { address = address.toLowerCase(); }\n            return address;\n        });\n\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (transaction.gasLimit == null) {\n            const estimate = shallowCopy(transaction);\n            estimate.from = fromAddress;\n            transaction.gasLimit = this.provider.estimateGas(estimate);\n        }\n\n        if (transaction.to != null) {\n            transaction.to = Promise.resolve(transaction.to).then(async (to) => {\n                if (to == null) { return null; }\n                const address = await this.provider.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            });\n        }\n\n        return resolveProperties({\n            tx: resolveProperties(transaction),\n            sender: fromAddress\n        }).then(({ tx, sender }) => {\n\n            if (tx.from != null) {\n                if (tx.from.toLowerCase() !== sender) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n            } else {\n                tx.from = sender;\n            }\n\n            const hexTx = (<any>this.provider.constructor).hexlifyTransaction(tx, { from: true });\n\n            return this.provider.send(\"eth_sendTransaction\", [ hexTx ]).then((hash) => {\n                return hash;\n            }, (error) => {\n                return checkError(\"sendTransaction\", error, hexTx);\n            });\n        });\n    }\n\n    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        return logger.throwError(\"signing transactions is unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"signTransaction\"\n        });\n    }\n\n    async sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        // This cannot be mined any earlier than any recent block\n        const blockNumber = await this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);\n\n        // Send the transaction\n        const hash = await this.sendUncheckedTransaction(transaction);\n\n        try {\n            // Unfortunately, JSON-RPC only provides and opaque transaction hash\n            // for a response, and we need the actual transaction, so we poll\n            // for it; it should show up very quickly\n            return await poll(async () => {\n                const tx = await this.provider.getTransaction(hash);\n                if (tx === null) { return undefined; }\n                return this.provider._wrapTransaction(tx, hash, blockNumber);\n            }, { oncePoll: this.provider });\n        } catch (error) {\n            (<any>error).transactionHash = hash;\n            throw error;\n        }\n    }\n\n    async signMessage(message: Bytes | string): Promise<string> {\n        const data = ((typeof(message) === \"string\") ? toUtf8Bytes(message): message);\n        const address = await this.getAddress();\n\n        return await this.provider.send(\"personal_sign\", [ hexlify(data), address.toLowerCase() ]);\n    }\n\n    async _legacySignMessage(message: Bytes | string): Promise<string> {\n        const data = ((typeof(message) === \"string\") ? toUtf8Bytes(message): message);\n        const address = await this.getAddress();\n\n        // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n        return await this.provider.send(\"eth_sign\", [ address.toLowerCase(), hexlify(data) ]);\n    }\n\n    async _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        // Populate any ENS names (in-place)\n        const populated = await _TypedDataEncoder.resolveNames(domain, types, value, (name: string) => {\n            return this.provider.resolveName(name);\n        });\n\n        const address = await this.getAddress();\n\n        return await this.provider.send(\"eth_signTypedData_v4\", [\n            address.toLowerCase(),\n            JSON.stringify(_TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n        ]);\n    }\n\n    async unlock(password: string): Promise<boolean> {\n        const provider = this.provider;\n\n        const address = await this.getAddress();\n\n        return provider.send(\"personal_unlockAccount\", [ address.toLowerCase(), password, null ]);\n    }\n}\n\nclass UncheckedJsonRpcSigner extends JsonRpcSigner {\n    sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        return this.sendUncheckedTransaction(transaction).then((hash) => {\n            return <TransactionResponse>{\n                hash: hash,\n                nonce: null,\n                gasLimit: null,\n                gasPrice: null,\n                data: null,\n                value: null,\n                chainId: null,\n                confirmations: 0,\n                from: null,\n                wait: (confirmations?: number) => { return this.provider.waitForTransaction(hash, confirmations); }\n            };\n        });\n    }\n}\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, gasLimit: true, gasPrice:true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true\n}\n\nexport class JsonRpcProvider extends BaseProvider {\n    readonly connection: ConnectionInfo;\n\n    _pendingFilter: Promise<number>;\n    _nextId: number;\n\n    // During any given event loop, the results for a given call will\n    // all be the same, so we can dedup the calls to save requests and\n    // bandwidth. @TODO: Try out generalizing this against send?\n    _eventLoopCache: Record<string, Promise<any>>;\n    get _cache(): Record<string, Promise<any>> {\n        if (this._eventLoopCache == null) {\n            this._eventLoopCache = { };\n        }\n        return this._eventLoopCache;\n    }\n\n    constructor(url?: ConnectionInfo | string, network?: Networkish) {\n        logger.checkNew(new.target, JsonRpcProvider);\n\n        let networkOrReady: Networkish | Promise<Network> = network;\n\n        // The network is unknown, query the JSON-RPC for it\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then((network) => {\n                        resolve(network);\n                    }, (error) => {\n                        reject(error);\n                    });\n                }, 0);\n            });\n        }\n\n        super(networkOrReady);\n\n        // Default URL\n        if (!url) { url = getStatic<() => string>(this.constructor, \"defaultUrl\")(); }\n\n        if (typeof(url) === \"string\") {\n            defineReadOnly(this, \"connection\",Object.freeze({\n                url: url\n            }));\n        } else {\n            defineReadOnly(this, \"connection\", Object.freeze(shallowCopy(url)));\n        }\n\n        this._nextId = 42;\n    }\n\n    static defaultUrl(): string {\n        return \"http:/\\/localhost:8545\";\n    }\n\n    detectNetwork(): Promise<Network> {\n        if (!this._cache[\"detectNetwork\"]) {\n            this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n\n            // Clear this cache at the beginning of the next event loop\n            setTimeout(() => {\n                this._cache[\"detectNetwork\"] = null;\n            }, 0);\n        }\n        return this._cache[\"detectNetwork\"];\n    }\n\n    async _uncachedDetectNetwork(): Promise<Network> {\n        await timer(0);\n\n        let chainId = null;\n        try {\n            chainId = await this.send(\"eth_chainId\", [ ]);\n        } catch (error) {\n            try {\n                chainId = await this.send(\"net_version\", [ ]);\n            } catch (error) { }\n        }\n\n        if (chainId != null) {\n            const getNetwork = getStatic<(network: Networkish) => Network>(this.constructor, \"getNetwork\");\n            try {\n                return getNetwork(BigNumber.from(chainId).toNumber());\n            } catch (error) {\n                return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                    chainId: chainId,\n                    event: \"invalidNetwork\",\n                    serverError: error\n                });\n            }\n        }\n\n        return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n            event: \"noNetwork\"\n        });\n    }\n\n    getSigner(addressOrIndex?: string | number): JsonRpcSigner {\n        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n    }\n\n    getUncheckedSigner(addressOrIndex?: string | number): UncheckedJsonRpcSigner {\n        return this.getSigner(addressOrIndex).connectUnchecked();\n    }\n\n    listAccounts(): Promise<Array<string>> {\n        return this.send(\"eth_accounts\", []).then((accounts: Array<string>) => {\n            return accounts.map((a) => this.formatter.address(a));\n        });\n    }\n\n    send(method: string, params: Array<any>): Promise<any> {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: deepCopy(request),\n            provider: this\n        });\n\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        const cache = ([ \"eth_chainId\", \"eth_blockNumber\" ].indexOf(method) >= 0);\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n\n        const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: request,\n                response: result,\n                provider: this\n            });\n\n            return result;\n\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                error: error,\n                request: request,\n                provider: this\n            });\n\n            throw error;\n        });\n\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(() => {\n                this._cache[method] = null;\n            }, 0);\n        }\n\n        return result;\n    }\n\n    prepareRequest(method: string, params: any): [ string, Array<any> ] {\n        switch (method) {\n            case \"getBlockNumber\":\n                return [ \"eth_blockNumber\", [] ];\n\n            case \"getGasPrice\":\n                return [ \"eth_gasPrice\", [] ];\n\n            case \"getBalance\":\n                return [ \"eth_getBalance\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getTransactionCount\":\n                return [ \"eth_getTransactionCount\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getCode\":\n                return [ \"eth_getCode\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getStorageAt\":\n                return [ \"eth_getStorageAt\", [ getLowerCase(params.address), params.position, params.blockTag ] ];\n\n            case \"sendTransaction\":\n                return [ \"eth_sendRawTransaction\", [ params.signedTransaction ] ]\n\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return [ \"eth_getBlockByNumber\", [ params.blockTag, !!params.includeTransactions ] ];\n                } else if (params.blockHash) {\n                    return [ \"eth_getBlockByHash\", [ params.blockHash, !!params.includeTransactions ] ];\n                }\n                return null;\n\n            case \"getTransaction\":\n                return [ \"eth_getTransactionByHash\", [ params.transactionHash ] ];\n\n            case \"getTransactionReceipt\":\n                return [ \"eth_getTransactionReceipt\", [ params.transactionHash ] ];\n\n            case \"call\": {\n                const hexlifyTransaction = getStatic<(t: TransactionRequest, a?: { [key: string]: boolean }) => { [key: string]: string }>(this.constructor, \"hexlifyTransaction\");\n                return [ \"eth_call\", [ hexlifyTransaction(params.transaction, { from: true }), params.blockTag ] ];\n            }\n\n            case \"estimateGas\": {\n                const hexlifyTransaction = getStatic<(t: TransactionRequest, a?: { [key: string]: boolean }) => { [key: string]: string }>(this.constructor, \"hexlifyTransaction\");\n                return [ \"eth_estimateGas\", [ hexlifyTransaction(params.transaction, { from: true }) ] ];\n            }\n\n            case \"getLogs\":\n                if (params.filter && params.filter.address != null) {\n                    params.filter.address = getLowerCase(params.filter.address);\n                }\n                return [ \"eth_getLogs\", [ params.filter ] ];\n\n            default:\n                break;\n        }\n\n        return null;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n        // Legacy networks do not like the type field being passed along (which\n        // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n        if (method === \"call\" || method === \"estimateGas\") {\n            const tx = params.transaction;\n            if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {\n                // If there are no EIP-1559 properties, it might be non-EIP-a559\n                if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                    const feeData = await this.getFeeData();\n                    if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                        // Network doesn't know about EIP-1559 (and hence type)\n                        params = shallowCopy(params);\n                        params.transaction = shallowCopy(tx);\n                        delete params.transaction.type;\n                    }\n                }\n            }\n        }\n\n        const args = this.prepareRequest(method,  params);\n\n        if (args == null) {\n            logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n        }\n        try {\n            return await this.send(args[0], args[1])\n        } catch (error) {\n            return checkError(method, error, params);\n        }\n    }\n\n    _startEvent(event: Event): void {\n        if (event.tag === \"pending\") { this._startPending(); }\n        super._startEvent(event);\n    }\n\n    _startPending(): void {\n        if (this._pendingFilter != null) { return; }\n        const self = this;\n\n        const pendingFilter: Promise<number> = this.send(\"eth_newPendingTransactionFilter\", []);\n        this._pendingFilter = pendingFilter;\n\n        pendingFilter.then(function(filterId) {\n            function poll() {\n                self.send(\"eth_getFilterChanges\", [ filterId ]).then(function(hashes: Array<string>) {\n                    if (self._pendingFilter != pendingFilter) { return null; }\n\n                    let seq = Promise.resolve();\n                    hashes.forEach(function(hash) {\n                        // @TODO: This should be garbage collected at some point... How? When?\n                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n                        seq = seq.then(function() {\n                            return self.getTransaction(hash).then(function(tx) {\n                                self.emit(\"pending\", tx);\n                                return null;\n                            });\n                        });\n                    });\n\n                    return seq.then(function() {\n                        return timer(1000);\n                    });\n                }).then(function() {\n                    if (self._pendingFilter != pendingFilter) {\n                        self.send(\"eth_uninstallFilter\", [ filterId ]);\n                        return;\n                    }\n                    setTimeout(function() { poll(); }, 0);\n\n                    return null;\n                }).catch((error: Error) => { });\n            }\n            poll();\n\n            return filterId;\n        }).catch((error: Error) => { });\n    }\n\n    _stopEvent(event: Event): void {\n        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n            this._pendingFilter = null;\n        }\n        super._stopEvent(event);\n    }\n\n    // Convert an ethers.js transaction into a JSON-RPC transaction\n    //  - gasLimit => gas\n    //  - All values hexlified\n    //  - All numeric values zero-striped\n    //  - All addresses are lowercased\n    // NOTE: This allows a TransactionRequest, but all values should be resolved\n    //       before this is called\n    // @TODO: This will likely be removed in future versions and prepareRequest\n    //        will be the preferred method for this.\n    static hexlifyTransaction(transaction: TransactionRequest, allowExtra?: { [key: string]: boolean }): { [key: string]: string | AccessList } {\n        // Check only allowed properties are given\n        const allowed = shallowCopy(allowedTransactionKeys);\n        if (allowExtra) {\n            for (const key in allowExtra) {\n                if (allowExtra[key]) { allowed[key] = true; }\n            }\n        }\n\n        checkProperties(transaction, allowed);\n\n        const result: { [key: string]: string | AccessList } = {};\n\n        // Some nodes (INFURA ropsten; INFURA mainnet is fine) do not like leading zeros.\n        [\"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(function(key) {\n            if ((<any>transaction)[key] == null) { return; }\n            const value = hexValue((<any>transaction)[key]);\n            if (key === \"gasLimit\") { key = \"gas\"; }\n            result[key] = value;\n        });\n\n        [\"from\", \"to\", \"data\"].forEach(function(key) {\n            if ((<any>transaction)[key] == null) { return; }\n            result[key] = hexlify((<any>transaction)[key]);\n        });\n\n        if ((<any>transaction).accessList) {\n            result[\"accessList\"] = accessListify((<any>transaction).accessList);\n        }\n\n        return result;\n    }\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\n\nlet WS: any = null;\n\ntry {\n    WS = (WebSocket as any);\n    if (WS == null) { throw new Error(\"inject please\"); }\n} catch (error) {\n    const logger = new Logger(version);\n    WS = function() {\n        logger.throwError(\"WebSockets not supported in this environment\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new WebSocket()\"\n        });\n    }\n}\n//export default WS;\n//module.exports = WS;\nexport { WS as WebSocket };\n","\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Event } from \"./base-provider\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nimport { WebSocket } from \"./ws\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicates\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */\n\nlet NextId = 1;\n\nexport type InflightRequest = {\n     callback: (error: Error, result: any) => void;\n     payload: string;\n};\n\nexport type Subscription = {\n    tag: string;\n    processFunc: (payload: any) => void;\n};\n\n\n// For more info about the Real-time Event API see:\n//   https://geth.ethereum.org/docs/rpc/pubsub\n\nexport class WebSocketProvider extends JsonRpcProvider {\n    readonly _websocket: any;\n    readonly _requests: { [ name: string ]: InflightRequest };\n    readonly _detectNetwork: Promise<Network>;\n\n    // Maps event tag to subscription ID (we dedupe identical events)\n    readonly _subIds: { [ tag: string ]: Promise<string> };\n\n    // Maps Subscription ID to Subscription\n    readonly _subs: { [ name: string ]: Subscription };\n\n    _wsReady: boolean;\n\n    constructor(url: string, network?: Networkish) {\n        // This will be added in the future; please open an issue to expedite\n        if (network === \"any\") {\n            logger.throwError(\"WebSocketProvider does not support 'any' network yet\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"network:any\"\n            });\n        }\n\n        super(url, network);\n        this._pollingInterval = -1;\n\n        this._wsReady = false;\n\n        defineReadOnly(this, \"_websocket\", new WebSocket(this.connection.url));\n        defineReadOnly(this, \"_requests\", { });\n        defineReadOnly(this, \"_subs\", { });\n        defineReadOnly(this, \"_subIds\", { });\n        defineReadOnly(this, \"_detectNetwork\", super.detectNetwork());\n\n        // Stall sending requests until the socket is open...\n        this._websocket.onopen = () => {\n            this._wsReady = true;\n            Object.keys(this._requests).forEach((id) => {\n                this._websocket.send(this._requests[id].payload);\n            });\n        };\n\n        this._websocket.onmessage = (messageEvent: { data: string }) => {\n            const data = messageEvent.data;\n            const result = JSON.parse(data);\n            if (result.id != null) {\n                const id = String(result.id);\n                const request = this._requests[id];\n                delete this._requests[id];\n\n                if (result.result !== undefined) {\n                    request.callback(null, result.result);\n\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: JSON.parse(request.payload),\n                        response: result.result,\n                        provider: this\n                    });\n\n                } else {\n                    let error: Error = null;\n                    if (result.error) {\n                        error = new Error(result.error.message || \"unknown error\");\n                        defineReadOnly(<any>error, \"code\", result.error.code || null);\n                        defineReadOnly(<any>error, \"response\", data);\n                    } else {\n                        error = new Error(\"unknown error\");\n                    }\n\n                    request.callback(error, undefined);\n\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: JSON.parse(request.payload),\n                        provider: this\n                    });\n\n                }\n\n            } else if (result.method === \"eth_subscription\") {\n                // Subscription...\n                const sub = this._subs[result.params.subscription];\n                if (sub) {\n                    //this.emit.apply(this,                  );\n                    sub.processFunc(result.params.result)\n                }\n\n            } else {\n                console.warn(\"this should not happen\");\n            }\n        };\n\n        // This Provider does not actually poll, but we want to trigger\n        // poll events for things that depend on them (like stalling for\n        // block and transaction lookups)\n        const fauxPoll = setInterval(() => {\n            this.emit(\"poll\");\n        }, 1000);\n        if (fauxPoll.unref) { fauxPoll.unref(); }\n    }\n\n    detectNetwork(): Promise<Network> {\n        return this._detectNetwork;\n    }\n\n    get pollingInterval(): number {\n        return 0;\n    }\n\n    resetEventsBlock(blockNumber: number): void {\n        logger.throwError(\"cannot reset events block on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resetEventBlock\"\n        });\n    }\n\n    set pollingInterval(value: number) {\n        logger.throwError(\"cannot set polling interval on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPollingInterval\"\n        });\n    }\n\n    async poll(): Promise<void> {\n        return null;\n    }\n\n    set polling(value: boolean) {\n        if (!value) { return; }\n\n        logger.throwError(\"cannot set polling on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPolling\"\n        });\n    }\n\n    send(method: string, params?: Array<any>): Promise<any> {\n        const rid = NextId++;\n\n        return new Promise((resolve, reject) => {\n            function callback(error: Error, result: any) {\n                if (error) { return reject(error); }\n                return resolve(result);\n            }\n\n            const payload = JSON.stringify({\n                method: method,\n                params: params,\n                id: rid,\n                jsonrpc: \"2.0\"\n            });\n\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: JSON.parse(payload),\n                provider: this\n            });\n\n            this._requests[String(rid)] = { callback, payload };\n\n            if (this._wsReady) { this._websocket.send(payload); }\n        });\n    }\n\n    static defaultUrl(): string {\n        return \"ws:/\\/localhost:8546\";\n    }\n\n    async _subscribe(tag: string, param: Array<any>, processFunc: (result: any) => void): Promise<void> {\n        let subIdPromise = this._subIds[tag];\n        if (subIdPromise == null) {\n            subIdPromise = Promise.all(param).then((param) => {\n                return this.send(\"eth_subscribe\", param);\n            });\n            this._subIds[tag] = subIdPromise;\n        }\n        const subId = await subIdPromise;\n        this._subs[subId] = { tag, processFunc };\n    }\n\n    _startEvent(event: Event): void {\n        switch (event.type) {\n            case \"block\":\n                this._subscribe(\"block\", [ \"newHeads\" ], (result: any) => {\n                    const blockNumber = BigNumber.from(result.number).toNumber();\n                    this._emitted.block = blockNumber;\n                    this.emit(\"block\", blockNumber);\n                });\n                break;\n\n            case \"pending\":\n                this._subscribe(\"pending\", [ \"newPendingTransactions\" ], (result: any) => {\n                    this.emit(\"pending\", result);\n                });\n                break;\n\n            case \"filter\":\n                this._subscribe(event.tag, [ \"logs\", this._getFilter(event.filter) ], (result: any) => {\n                    if (result.removed == null) { result.removed = false; }\n                    this.emit(event.filter, this.formatter.filterLog(result));\n                });\n                break;\n\n            case \"tx\": {\n                const emitReceipt = (event: Event) => {\n                    const hash = event.hash;\n                    this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt) { return; }\n                        this.emit(hash, receipt);\n                    });\n                };\n\n                // In case it is already mined\n                emitReceipt(event);\n\n                // To keep things simple, we start up a single newHeads subscription\n                // to keep an eye out for transactions we are watching for.\n                // Starting a subscription for an event (i.e. \"tx\") that is already\n                // running is (basically) a nop.\n                this._subscribe(\"tx\", [ \"newHeads\" ], (result: any) => {\n                    this._events.filter((e) => (e.type === \"tx\")).forEach(emitReceipt);\n                });\n                break;\n            }\n\n            // Nothing is needed\n            case \"debug\":\n            case \"poll\":\n            case \"willPoll\":\n            case \"didPoll\":\n            case \"error\":\n                break;\n\n            default:\n                console.log(\"unhandled:\", event);\n                break;\n        }\n    }\n\n    _stopEvent(event: Event): void {\n        let tag = event.tag;\n\n        if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e) => (e.type === \"tx\")).length) {\n                return;\n            }\n            tag = \"tx\";\n        } else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n\n        const subId = this._subIds[tag];\n        if (!subId) { return; }\n\n       delete this._subIds[tag];\n       subId.then((subId) => {\n            if (!this._subs[subId]) { return; }\n            delete this._subs[subId];\n            this.send(\"eth_unsubscribe\", [ subId ]);\n        });\n    }\n\n    async destroy(): Promise<void> {\n        // Wait until we have connected before trying to disconnect\n        if (this._websocket.readyState === WebSocket.CONNECTING) {\n            await (new Promise((resolve) => {\n                this._websocket.onopen = function() {\n                    resolve(true);\n                };\n\n                this._websocket.onerror = function() {\n                    resolve(false);\n                };\n            }));\n        }\n\n        // Hangup\n        // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n        this._websocket.close(1000);\n    }\n}\n","\n\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly, getStatic } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { CommunityResourcable } from \"./formatter\";\nimport { JsonRpcProvider, JsonRpcSigner } from \"./json-rpc-provider\";\n\ntype getUrlFunc = (network: Network, apiKey: string) => string | ConnectionInfo;\n\n// A StaticJsonRpcProvider is useful when you *know* for certain that\n// the backend will never change, as it never calls eth_chainId to\n// verify its backend. However, if the backend does change, the effects\n// are undefined and may include:\n// - inconsistent results\n// - locking up the UI\n// - block skew warnings\n// - wrong results\n// If the network is not explicit (i.e. auto-detection is expected), the\n// node MUST be running and available to respond to requests BEFORE this\n// is instantiated.\nexport class StaticJsonRpcProvider extends JsonRpcProvider {\n    async detectNetwork(): Promise<Network> {\n        let network = this.network;\n        if (network == null) {\n            network = await super.detectNetwork();\n\n            if (!network) {\n                logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, { });\n            }\n\n            // If still not set, set it\n            if (this._network == null) {\n                // A static network does not support \"any\"\n                defineReadOnly(this, \"_network\", network);\n\n                this.emit(\"network\", network, null);\n            }\n        }\n        return network;\n    }\n}\n\nexport abstract class UrlJsonRpcProvider extends StaticJsonRpcProvider implements CommunityResourcable {\n    readonly apiKey: any;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        logger.checkAbstract(new.target, UrlJsonRpcProvider);\n\n        // Normalize the Network and API Key\n        network = getStatic<(network: Networkish) => Network>(new.target, \"getNetwork\")(network);\n        apiKey = getStatic<(apiKey: string) => string>(new.target, \"getApiKey\")(apiKey);\n\n        const connection = getStatic<getUrlFunc>(new.target, \"getUrl\")(network, apiKey);\n\n        super(connection, network);\n\n        if (typeof(apiKey) === \"string\") {\n            defineReadOnly(this, \"apiKey\", apiKey);\n        } else if (apiKey != null) {\n            Object.keys(apiKey).forEach((key) => {\n                defineReadOnly<any, any>(this, key, apiKey[key]);\n            });\n        }\n    }\n\n    _startPending(): void {\n        logger.warn(\"WARNING: API provider does not support pending filters\");\n    }\n\n    isCommunityResource(): boolean {\n        return false;\n    }\n\n    getSigner(address?: string): JsonRpcSigner {\n        return logger.throwError(\n            \"API provider does not support signing\",\n            Logger.errors.UNSUPPORTED_OPERATION,\n            { operation: \"getSigner\" }\n        );\n    }\n\n    listAccounts(): Promise<Array<string>> {\n        return Promise.resolve([]);\n    }\n\n    // Return a defaultApiKey if null, otherwise validate the API key\n    static getApiKey(apiKey: any): any {\n        return apiKey;\n    }\n\n    // Returns the url or connection for the given network and API key. The\n    // API key will have been sanitized by the getApiKey first, so any validation\n    // or transformations can be done there.\n    static getUrl(network: Network, apiKey: any): string | ConnectionInfo {\n        return logger.throwError(\"not implemented; sub-classes must override getUrl\", Logger.errors.NOT_IMPLEMENTED, {\n            operation: \"getUrl\"\n        });\n    }\n}\n","\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { CommunityResourcable, showThrottleMessage } from \"./formatter\";\nimport { WebSocketProvider } from \"./websocket-provider\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\n// This key was provided to ethers.js by Alchemy to be used by the\n// default provider, but it is recommended that for your own\n// production environments, that you acquire your own API key at:\n//   https://dashboard.alchemyapi.io\n\nconst defaultApiKey = \"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\"\n\nexport class AlchemyWebSocketProvider extends WebSocketProvider implements CommunityResourcable {\n    readonly apiKey: string;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        const provider = new AlchemyProvider(network, apiKey);\n\n        const url = provider.connection.url.replace(/^http/i, \"ws\")\n                                           .replace(\".alchemyapi.\", \".ws.alchemyapi.\");\n\n        super(url, provider.network);\n        defineReadOnly(this, \"apiKey\", provider.apiKey);\n    }\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n\nexport class AlchemyProvider extends UrlJsonRpcProvider {\n\n    static getWebSocketProvider(network?: Networkish, apiKey?: any): AlchemyWebSocketProvider {\n        return new AlchemyWebSocketProvider(network, apiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey == null) { return defaultApiKey; }\n        if (apiKey && typeof(apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey;\n    }\n\n    static getUrl(network: Network, apiKey: string): ConnectionInfo {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"eth-mainnet.alchemyapi.io/v2/\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.alchemyapi.io/v2/\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.alchemyapi.io/v2/\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.alchemyapi.io/v2/\";\n                break;\n            case \"kovan\":\n                host = \"eth-kovan.alchemyapi.io/v2/\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.g.alchemy.com/v2/\";\n                break;\n            default:\n               logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n\n        return {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + apiKey),\n            throttleCallback: (attempt: number, url: string) => {\n                if (apiKey === defaultApiKey) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n    }\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n","\"use strict\";\n\nimport { Network } from \"@ethersproject/networks\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport class CloudflareProvider extends UrlJsonRpcProvider {\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey != null) {\n            logger.throwArgumentError(\"apiKey not supported for cloudflare\", \"apiKey\", apiKey);\n        }\n        return null;\n    }\n\n    static getUrl(network: Network, apiKey?: any): string {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://cloudflare-eth.com/\";\n                break;\n            default:\n               logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n\n        return host;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n        // The Cloudflare provider does not support eth_blockNumber,\n        // so we get the latest block and pull it from that\n        if (method === \"getBlockNumber\") {\n            const block = await super.perform(\"getBlock\", { blockTag: \"latest\" });\n            return block.number;\n        }\n\n        return super.perform(method, params);\n    }\n}\n","\"use strict\";\n\nimport { BlockTag, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { hexlify, hexValue, isHexString } from \"@ethersproject/bytes\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { deepCopy, defineReadOnly } from \"@ethersproject/properties\";\nimport { accessListify } from \"@ethersproject/transactions\";\nimport { ConnectionInfo, fetchJson } from \"@ethersproject/web\";\n\nimport { showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { BaseProvider } from \"./base-provider\";\n\n\n// The transaction has already been sanitized by the calls in Provider\nfunction getTransactionPostData(transaction: TransactionRequest): Record<string, string> {\n    const result: Record<string, string> = { };\n    for (let key in transaction) {\n        if ((<any>transaction)[key] == null) { continue; }\n        let value = (<any>transaction)[key];\n        if (key === \"type\" && value === 0) { continue; }\n\n        // Quantity-types require no leading zero, unless 0\n        if ((<any>{ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true })[key]) {\n            value = hexValue(hexlify(value));\n        } else if (key === \"accessList\") {\n            value = \"[\" + accessListify(value).map((set) => {\n                return `{address:\"${ set.address }\",storageKeys:[\"${ set.storageKeys.join('\",\"') }\"]}`;\n            }).join(\",\") + \"]\";\n        } else {\n            value = hexlify(value);\n        }\n        result[key] = value;\n    }\n    return result;\n}\n\nfunction getResult(result: { status?: number, message?: string, result?: any }): any {\n    // getLogs, getHistory have weird success responses\n    if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\n        return result.result;\n    }\n\n    if (result.status != 1 || result.message != \"OK\") {\n        const error: any = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        if ((result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n            error.throttleRetry = true;\n        }\n        throw error;\n    }\n\n    return result.result;\n}\n\nfunction getJsonResult(result: { jsonrpc: string, result?: any, error?: { code?: number, data?: any, message?: string} } ): any {\n    // This response indicates we are being throttled\n    if (result && (<any>result).status == 0 && (<any>result).message == \"NOTOK\" && (result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n        const error: any = new Error(\"throttled response\");\n        error.result = JSON.stringify(result);\n        error.throttleRetry = true;\n        throw error;\n    }\n\n    if (result.jsonrpc != \"2.0\") {\n        // @TODO: not any\n        const error: any = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        throw error;\n    }\n\n    if (result.error) {\n        // @TODO: not any\n        const error: any = new Error(result.error.message || \"unknown error\");\n        if (result.error.code) { error.code = result.error.code; }\n        if (result.error.data) { error.data = result.error.data; }\n        throw error;\n    }\n\n    return result.result;\n}\n\n// The blockTag was normalized as a string by the Provider pre-perform operations\nfunction checkLogTag(blockTag: string): number | \"latest\" {\n    if (blockTag === \"pending\") { throw new Error(\"pending not supported\"); }\n    if (blockTag === \"latest\") { return blockTag; }\n\n    return parseInt(blockTag.substring(2), 16);\n}\n\n\nconst defaultApiKey = \"9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB\";\n\nfunction checkError(method: string, error: any, transaction: any): any {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === Logger.errors.SERVER_ERROR) {\n        const e = error.error;\n\n        // Etherscan keeps changing their string\n        if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {\n            // Etherscan prefixes the data like \"Reverted 0x1234\"\n            let data = e.data;\n            if (data) { data = \"0x\" + data.replace(/^.*0x/i, \"\"); }\n\n            if (isHexString(data)) { return data; }\n\n            logger.throwError(\"missing revert data in call exception\", Logger.errors.CALL_EXCEPTION, {\n                error, data: \"0x\"\n            });\n        }\n    }\n\n    // Get the message from any nested error structure\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR) {\n        if (error.error && typeof(error.error.message) === \"string\") {\n            message = error.error.message;\n        } else if (typeof(error.body) === \"string\") {\n            message = error.body;\n        } else if (typeof(error.responseText) === \"string\") {\n            message = error.responseText;\n        }\n    }\n    message = (message || \"\").toLowerCase();\n\n    // \"Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0\"\n    if (message.match(/insufficient funds/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n           error, method, transaction\n        });\n    }\n\n    // \"Transaction with the same hash was already imported.\"\n    if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n           error, method, transaction\n        });\n    }\n\n    // \"Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce.\"\n    if (message.match(/another transaction with same nonce/)) {\n         logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n         });\n    }\n\n    if (message.match(/execution failed due to an exception|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n\n    throw error;\n}\n\nexport class EtherscanProvider extends BaseProvider{\n    readonly baseUrl: string;\n    readonly apiKey: string;\n\n    constructor(network?: Networkish, apiKey?: string) {\n        logger.checkNew(new.target, EtherscanProvider);\n\n        super(network);\n\n        defineReadOnly(this, \"baseUrl\", this.getBaseUrl());\n        defineReadOnly(this, \"apiKey\", apiKey || defaultApiKey);\n    }\n\n    getBaseUrl(): string {\n        switch(this.network ? this.network.name: \"invalid\") {\n            case \"homestead\":\n                return \"https:/\\/api.etherscan.io\";\n            case \"ropsten\":\n                return \"https:/\\/api-ropsten.etherscan.io\";\n            case \"rinkeby\":\n                return \"https:/\\/api-rinkeby.etherscan.io\";\n            case \"kovan\":\n                return \"https:/\\/api-kovan.etherscan.io\";\n            case \"goerli\":\n                return \"https:/\\/api-goerli.etherscan.io\";\n            default:\n        }\n\n        return logger.throwArgumentError(\"unsupported network\", \"network\", name);\n    }\n\n    getUrl(module: string, params: Record<string, string>): string {\n        const query = Object.keys(params).reduce((accum, key) => {\n            const value = params[key];\n            if (value != null) {\n                accum += `&${ key }=${ value }`\n            }\n            return accum\n        }, \"\");\n        const apiKey = ((this.apiKey) ? `&apikey=${ this.apiKey }`: \"\");\n        return `${ this.baseUrl }/api?module=${ module }${ query }${ apiKey }`;\n    }\n\n    getPostUrl(): string {\n        return `${ this.baseUrl }/api`;\n    }\n\n    getPostData(module: string, params: Record<string, any>): Record<string, any> {\n        params.module = module;\n        params.apikey = this.apiKey;\n        return params;\n    }\n\n    async fetch(module: string, params: Record<string, any>, post?: boolean): Promise<any> {\n        const url = (post ? this.getPostUrl(): this.getUrl(module, params));\n        const payload = (post ? this.getPostData(module, params): null);\n        const procFunc = (module === \"proxy\") ? getJsonResult: getResult;\n\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: url,\n            provider: this\n        });\n\n        const connection: ConnectionInfo = {\n            url: url,\n            throttleSlotInterval: 1000,\n            throttleCallback: (attempt: number, url: string) => {\n                if (this.isCommunityResource()) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n\n        let payloadStr: string = null;\n        if (payload) {\n            connection.headers = { \"content-type\": \"application/x-www-form-urlencoded; charset=UTF-8\" };\n            payloadStr = Object.keys(payload).map((key) => {\n                return `${ key }=${ payload[key] }`\n            }).join(\"&\");\n        }\n\n        const result = await fetchJson(connection, payloadStr, procFunc || getJsonResult);\n\n        this.emit(\"debug\", {\n            action: \"response\",\n            request: url,\n            response: deepCopy(result),\n            provider: this\n        });\n\n        return result;\n    }\n\n    async detectNetwork(): Promise<Network> {\n        return this.network;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n\n        switch (method) {\n            case \"getBlockNumber\":\n                return this.fetch(\"proxy\", { action: \"eth_blockNumber\" });\n\n            case \"getGasPrice\":\n                return this.fetch(\"proxy\", { action: \"eth_gasPrice\" });\n\n            case \"getBalance\":\n                // Returns base-10 result\n                return this.fetch(\"account\", {\n                    action: \"balance\",\n                    address: params.address,\n                    tag: params.blockTag\n                });\n\n            case \"getTransactionCount\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionCount\",\n                    address: params.address,\n                    tag: params.blockTag\n                });\n\n            case \"getCode\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getCode\",\n                    address: params.address,\n                    tag: params.blockTag\n                });\n\n            case \"getStorageAt\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getStorageAt\",\n                    address: params.address,\n                    position: params.position,\n                    tag: params.blockTag\n                });\n\n            case \"sendTransaction\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_sendRawTransaction\",\n                    hex: params.signedTransaction\n                }, true).catch((error) => {\n                    return checkError(\"sendTransaction\", error, params.signedTransaction);\n                });\n\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getBlockByNumber\",\n                        tag: params.blockTag,\n                        boolean: (params.includeTransactions ? \"true\": \"false\")\n                    });\n                }\n                throw new Error(\"getBlock by blockHash not implemented\");\n\n            case \"getTransaction\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionByHash\",\n                    txhash: params.transactionHash\n                });\n\n            case \"getTransactionReceipt\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionReceipt\",\n                    txhash: params.transactionHash\n                });\n\n            case \"call\": {\n                if (params.blockTag !== \"latest\") {\n                    throw new Error(\"EtherscanProvider does not support blockTag for call\");\n                }\n\n                const postData = getTransactionPostData(params.transaction);\n                postData.module = \"proxy\";\n                postData.action = \"eth_call\";\n\n                try {\n                    return await this.fetch(\"proxy\", postData, true);\n                } catch (error) {\n                    return checkError(\"call\", error, params.transaction);\n                }\n            }\n\n            case \"estimateGas\": {\n                const postData = getTransactionPostData(params.transaction);\n                postData.module = \"proxy\";\n                postData.action = \"eth_estimateGas\";\n\n                try {\n                    return await this.fetch(\"proxy\", postData, true);\n                } catch (error) {\n                    return checkError(\"estimateGas\", error, params.transaction);\n                }\n            }\n\n            case \"getLogs\": {\n                const args: Record<string, any> = { action: \"getLogs\" }\n\n                if (params.filter.fromBlock) {\n                    args.fromBlock = checkLogTag(params.filter.fromBlock);\n                }\n\n                if (params.filter.toBlock) {\n                    args.toBlock = checkLogTag(params.filter.toBlock);\n                }\n\n                if (params.filter.address) {\n                    args.address = params.filter.address;\n                }\n\n                // @TODO: We can handle slightly more complicated logs using the logs API\n                if (params.filter.topics && params.filter.topics.length > 0) {\n                    if (params.filter.topics.length > 1) {\n                        logger.throwError(\"unsupported topic count\", Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\n                    }\n\n                    if (params.filter.topics.length === 1) {\n                        const topic0 = params.filter.topics[0];\n                        if (typeof(topic0) !== \"string\" || topic0.length !== 66) {\n                            logger.throwError(\"unsupported topic format\", Logger.errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\n                        }\n                        args.topic0 = topic0;\n                    }\n                }\n\n                const logs: Array<any> = await this.fetch(\"logs\", args);\n\n                // Cache txHash => blockHash\n                let blocks: { [tag: string]: string } = {};\n\n                // Add any missing blockHash to the logs\n                for (let i = 0; i < logs.length; i++) {\n                    const log = logs[i];\n                    if (log.blockHash != null) { continue; }\n                    if (blocks[log.blockNumber] == null) {\n                        const block = await this.getBlock(log.blockNumber);\n                        if (block) {\n                            blocks[log.blockNumber] = block.hash;\n                        }\n                    }\n                    log.blockHash = blocks[log.blockNumber];\n                }\n\n                return logs;\n            }\n\n            case \"getEtherPrice\":\n                if (this.network.name !== \"homestead\") { return 0.0; }\n                return parseFloat((await this.fetch(\"stats\", { action: \"ethprice\" })).ethusd);\n\n            default:\n                break;\n         }\n\n        return super.perform(method, params);\n    }\n\n    // Note: The `page` page parameter only allows pagination within the\n    //       10,000 window available without a page and offset parameter\n    //       Error: Result window is too large, PageNo x Offset size must\n    //              be less than or equal to 10000\n    async getHistory(addressOrName: string | Promise<string>, startBlock?: BlockTag, endBlock?: BlockTag): Promise<Array<TransactionResponse>> {\n        const params = {\n            action: \"txlist\",\n            address: (await this.resolveName(addressOrName)),\n            startblock: ((startBlock == null) ? 0: startBlock),\n            endblock: ((endBlock == null) ? 99999999: endBlock),\n            sort: \"asc\"\n        };\n\n        const result = await this.fetch(\"account\", params);\n\n        return result.map((tx: any) => {\n            [\"contractAddress\", \"to\"].forEach(function(key) {\n                if (tx[key] == \"\") { delete tx[key]; }\n            });\n            if (tx.creates == null && tx.contractAddress != null) {\n                tx.creates = tx.contractAddress;\n            }\n            const item = this.formatter.transactionResponse(tx);\n            if (tx.timeStamp) { item.timestamp = parseInt(tx.timeStamp); }\n            return item;\n        });\n    }\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n","\"use strict\";\n\nexport function shuffled(array: Array<any>): Array<any> {\n    array = array.slice();\n\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        const tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n\n    return array;\n}\n","\"use strict\";\n\nimport { Block, BlockWithTransactions, Provider } from \"@ethersproject/abstract-provider\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { Network } from \"@ethersproject/networks\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { shuffled } from \"@ethersproject/random\";\nimport { poll } from \"@ethersproject/web\";\n\nimport { BaseProvider } from \"./base-provider\";\nimport { isCommunityResource } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction now() { return (new Date()).getTime(); }\n\n// Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\nfunction checkNetworks(networks: Array<Network>): Network {\n    let result = null;\n\n    for (let i = 0; i < networks.length; i++) {\n        const network = networks[i];\n\n        // Null! We do not know our network; bail.\n        if (network == null) { return null; }\n\n        if (result) {\n            // Make sure the network matches the previous networks\n            if (!(result.name === network.name && result.chainId === network.chainId &&\n                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {\n\n                logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n           }\n        } else {\n            result = network;\n        }\n    }\n\n    return result;\n}\n\nfunction median(values: Array<number>, maxDelta?: number): number {\n    values = values.slice().sort();\n    const middle = Math.floor(values.length / 2);\n\n    // Odd length; take the middle\n    if (values.length % 2) {\n        return values[middle];\n    }\n\n    // Even length; take the average of the two middle\n    const a = values[middle - 1], b = values[middle];\n\n    if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n        return null;\n    }\n\n    return (a + b) / 2;\n}\n\nfunction serialize(value: any): string {\n    if (value === null) {\n        return \"null\";\n    } else if (typeof(value) === \"number\" || typeof(value) === \"boolean\") {\n        return JSON.stringify(value);\n    } else if (typeof(value) === \"string\") {\n        return value;\n    } else if (BigNumber.isBigNumber(value)) {\n        return value.toString();\n    } else if (Array.isArray(value)) {\n        return JSON.stringify(value.map((i) => serialize(i)));\n    } else if (typeof(value) === \"object\") {\n        const keys = Object.keys(value);\n        keys.sort();\n        return \"{\" + keys.map((key) => {\n            let v = value[key];\n            if (typeof(v) === \"function\") {\n                v = \"[function]\";\n            } else {\n                v = serialize(v);\n            }\n            return JSON.stringify(key) + \":\" + v;\n        }).join(\",\") + \"}\";\n    }\n\n    throw new Error(\"unknown value type: \" + typeof(value));\n}\n\n// Next request ID to use for emitting debug info\nlet nextRid = 1;\n\n\nexport interface FallbackProviderConfig {\n    // The Provider\n    provider: Provider;\n\n    // The priority to favour this Provider; lower values are used first (higher priority)\n    priority?: number;\n\n    // Timeout before also triggering the next provider; this does not stop\n    // this provider and if its result comes back before a quorum is reached\n    // it will be incorporated into the vote\n    // - lower values will cause more network traffic but may result in a\n    //   faster result.\n    stallTimeout?: number;\n\n    // How much this provider contributes to the quorum; sometimes a specific\n    // provider may be more reliable or trustworthy than others, but usually\n    // this should be left as the default\n    weight?: number;\n};\n\n// A Staller is used to provide a delay to give a Provider a chance to response\n// before asking the next Provider to try.\ntype Staller = {\n    wait: (func: () => void) => Promise<void>\n    getPromise: () => Promise<void>,\n    cancel: () => void\n};\n\nfunction stall(duration: number): Staller {\n    let cancel: () => void = null;\n\n    let timer: NodeJS.Timer = null;\n    let promise = <Promise<void>>(new Promise((resolve) => {\n        cancel = function() {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            resolve();\n        }\n        timer = setTimeout(cancel, duration);\n    }));\n\n    const wait = (func: () => void) => {\n        promise = promise.then(func);\n        return promise;\n    }\n\n    function getPromise(): Promise<void> {\n        return promise;\n    }\n\n    return { cancel, getPromise, wait };\n}\n\nconst ForwardErrors = [\n    Logger.errors.CALL_EXCEPTION,\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n    Logger.errors.UNPREDICTABLE_GAS_LIMIT\n];\n\nconst ForwardProperties = [\n    \"address\",\n    \"args\",\n    \"errorArgs\",\n    \"errorSignature\",\n    \"method\",\n    \"transaction\",\n];\n\n\n// @TODO: Make this an object with staller and cancel built-in\ninterface RunningConfig extends FallbackProviderConfig {\n    start?: number;\n    done?: boolean;\n    cancelled?: boolean;\n    runner?: Promise<any>;\n    staller?: Staller;\n    result?: any;\n    error?: Error;\n};\n\nfunction exposeDebugConfig(config: RunningConfig, now?: number): any {\n    const result: any = {\n        weight: config.weight\n    };\n    Object.defineProperty(result, \"provider\", { get: () => config.provider });\n    if (config.start) { result.start = config.start; }\n    if (now) { result.duration = (now - config.start); }\n    if (config.done) {\n        if (config.error) {\n            result.error = config.error;\n        } else {\n            result.result = config.result || null;\n        }\n    }\n    return result;\n}\n\nfunction normalizedTally(normalize: (value: any) => string, quorum: number): (configs: Array<RunningConfig>) => any {\n    return function(configs: Array<RunningConfig>): any {\n\n        // Count the votes for each result\n        const tally: { [ key: string]: { count: number, result: any } } = { };\n        configs.forEach((c) => {\n            const value = normalize(c.result);\n            if (!tally[value]) { tally[value] = { count: 0, result: c.result }; }\n            tally[value].count++;\n        });\n\n        // Check for a quorum on any given result\n        const keys = Object.keys(tally);\n        for (let i = 0; i < keys.length; i++) {\n            const check = tally[keys[i]];\n            if (check.count >= quorum) {\n                return check.result;\n            }\n        }\n\n        // No quroum\n        return undefined;\n    }\n}\nfunction getProcessFunc(provider: FallbackProvider, method: string, params: { [ key: string ]: any }): (configs: Array<RunningConfig>) => any {\n\n    let normalize = serialize;\n\n    switch (method) {\n        case \"getBlockNumber\":\n            // Return the median value, unless there is (median + 1) is also\n            // present, in which case that is probably true and the median\n            // is going to be stale soon. In the event of a malicious node,\n            // the lie will be true soon enough.\n            return function(configs: Array<RunningConfig>): number {\n                const values = configs.map((c) => c.result);\n\n                // Get the median block number\n                let blockNumber = median(configs.map((c) => c.result), 2);\n                if (blockNumber == null) { return undefined; }\n\n                blockNumber = Math.ceil(blockNumber);\n\n                // If the next block height is present, its prolly safe to use\n                if (values.indexOf(blockNumber + 1) >= 0) { blockNumber++; }\n\n                // Don't ever roll back the blockNumber\n                if (blockNumber >= provider._highestBlockNumber) {\n                    provider._highestBlockNumber = blockNumber;\n                }\n\n                return provider._highestBlockNumber;\n            };\n\n        case \"getGasPrice\":\n            // Return the middle (round index up) value, similar to median\n            // but do not average even entries and choose the higher.\n            // Malicious actors must compromise 50% of the nodes to lie.\n            return function(configs: Array<RunningConfig>): BigNumber {\n                const values = configs.map((c) => c.result);\n                values.sort();\n                return values[Math.floor(values.length / 2)];\n            }\n\n        case \"getEtherPrice\":\n            // Returns the median price. Malicious actors must compromise at\n            // least 50% of the nodes to lie (in a meaningful way).\n            return function(configs: Array<RunningConfig>): number {\n                return median(configs.map((c) => c.result));\n            }\n\n        // No additional normalizing required; serialize is enough\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n        case \"getStorageAt\":\n        case \"call\":\n        case \"estimateGas\":\n        case \"getLogs\":\n            break;\n\n        // We drop the confirmations from transactions as it is approximate\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            normalize = function(tx: any): string {\n                if (tx == null) { return null; }\n\n                tx = shallowCopy(tx);\n                tx.confirmations = -1;\n                return serialize(tx);\n            }\n            break;\n\n        // We drop the confirmations from transactions as it is approximate\n        case \"getBlock\":\n            // We drop the confirmations from transactions as it is approximate\n            if (params.includeTransactions) {\n                normalize = function(block: BlockWithTransactions): string {\n                    if (block == null) { return null; }\n\n                    block = shallowCopy(block);\n                    block.transactions = block.transactions.map((tx) => {\n                        tx = shallowCopy(tx);\n                        tx.confirmations = -1;\n                        return tx;\n                    });\n                    return serialize(block);\n                };\n            } else {\n                normalize = function(block: Block): string {\n                    if (block == null) { return null; }\n                    return serialize(block);\n                }\n            }\n            break;\n\n        default:\n            throw new Error(\"unknown method: \" + method);\n    }\n\n    // Return the result if and only if the expected quorum is\n    // satisfied and agreed upon for the final result.\n    return normalizedTally(normalize, provider.quorum);\n\n}\n\n// If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\nasync function waitForSync(config: RunningConfig, blockNumber: number): Promise<BaseProvider> {\n    const provider = <BaseProvider>(config.provider);\n\n    if ((provider.blockNumber != null && provider.blockNumber >= blockNumber) || blockNumber === -1) {\n        return provider;\n    }\n\n    return poll(() => {\n        return new Promise((resolve, reject) => {\n            setTimeout(function() {\n\n                // We are synced\n                if (provider.blockNumber >= blockNumber) { return resolve(provider); }\n\n                // We're done; just quit\n                if (config.cancelled) { return resolve(null); }\n\n                // Try again, next block\n                return resolve(undefined);\n            }, 0);\n        });\n    }, { oncePoll: provider });\n}\n\nasync function getRunner(config: RunningConfig, currentBlockNumber: number, method: string, params: { [ key: string]: any }): Promise<any> {\n    let provider = config.provider;\n\n    switch (method) {\n        case \"getBlockNumber\":\n        case \"getGasPrice\":\n            return provider[method]();\n        case \"getEtherPrice\":\n            if ((<any>provider).getEtherPrice) {\n                return (<any>provider).getEtherPrice();\n            }\n            break;\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[method](params.address, params.blockTag || \"latest\");\n        case \"getStorageAt\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\");\n        case \"getBlock\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[(params.includeTransactions ? \"getBlockWithTransactions\": \"getBlock\")](params.blockTag || params.blockHash);\n        case \"call\":\n        case \"estimateGas\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[method](params.transaction);\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            return provider[method](params.transactionHash);\n        case \"getLogs\": {\n            let filter = params.filter;\n            if ((filter.fromBlock && isHexString(filter.fromBlock)) || (filter.toBlock && isHexString(filter.toBlock))) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider.getLogs(filter);\n        }\n    }\n\n    return logger.throwError(\"unknown method error\", Logger.errors.UNKNOWN_ERROR, {\n        method: method,\n        params: params\n    });\n}\n\nexport class FallbackProvider extends BaseProvider {\n    readonly providerConfigs: ReadonlyArray<FallbackProviderConfig>;\n    readonly quorum: number;\n\n    // Due to the highly asyncronous nature of the blockchain, we need\n    // to make sure we never unroll the blockNumber due to our random\n    // sample of backends\n    _highestBlockNumber: number;\n\n    constructor(providers: Array<Provider | FallbackProviderConfig>, quorum?: number) {\n        logger.checkNew(new.target, FallbackProvider);\n\n        if (providers.length === 0) {\n            logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n        }\n\n        const providerConfigs: Array<FallbackProviderConfig> = providers.map((configOrProvider, index) => {\n            if (Provider.isProvider(configOrProvider)) {\n                const stallTimeout = isCommunityResource(configOrProvider) ? 2000: 750;\n                const priority = 1;\n                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });\n            }\n\n            const config: FallbackProviderConfig = shallowCopy(configOrProvider);\n\n            if (config.priority == null) { config.priority = 1; }\n            if (config.stallTimeout == null) {\n                config.stallTimeout = isCommunityResource(configOrProvider) ? 2000: 750;\n            }\n            if (config.weight == null) { config.weight = 1; }\n\n            const weight = config.weight;\n            if (weight % 1 || weight > 512 || weight < 1) {\n                logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", `providers[${ index }].weight`, weight);\n            }\n\n            return Object.freeze(config);\n        });\n\n        const total = providerConfigs.reduce((accum, c) => (accum + c.weight), 0);\n\n        if (quorum == null) {\n            quorum = total / 2;\n        } else if (quorum > total) {\n            logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n        }\n\n        // Are all providers' networks are known\n        let networkOrReady: Network | Promise<Network> = checkNetworks(providerConfigs.map((c) => (<any>(c.provider)).network));\n\n        // Not all networks are known; we must stall\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then(resolve, reject);\n                }, 0);\n            });\n        }\n\n        super(networkOrReady);\n\n        // Preserve a copy, so we do not get mutated\n        defineReadOnly(this, \"providerConfigs\", Object.freeze(providerConfigs));\n        defineReadOnly(this, \"quorum\", quorum);\n\n        this._highestBlockNumber = -1;\n    }\n\n    async detectNetwork(): Promise<Network> {\n        const networks = await Promise.all(this.providerConfigs.map((c) => c.provider.getNetwork()));\n        return checkNetworks(networks);\n    }\n\n    async perform(method: string, params: { [name: string]: any }): Promise<any> {\n        // Sending transactions is special; always broadcast it to all backends\n        if (method === \"sendTransaction\") {\n            const results: Array<string | Error> = await Promise.all(this.providerConfigs.map((c) => {\n                return c.provider.sendTransaction(params.signedTransaction).then((result) => {\n                    return result.hash;\n                }, (error) => {\n                    return error;\n                });\n            }));\n\n            // Any success is good enough (other errors are likely \"already seen\" errors\n            for (let i = 0; i < results.length; i++) {\n                const result = results[i];\n                if (typeof(result) === \"string\") { return result; }\n            }\n\n            // They were all an error; pick the first error\n            throw results[0];\n        }\n\n        // We need to make sure we are in sync with our backends, so we need\n        // to know this before we can make a lot of calls\n        if (this._highestBlockNumber === -1 && method !== \"getBlockNumber\") {\n            await this.getBlockNumber();\n        }\n\n        const processFunc = getProcessFunc(this, method, params);\n\n        // Shuffle the providers and then sort them by their priority; we\n        // shallowCopy them since we will store the result in them too\n        const configs: Array<RunningConfig> = shuffled(this.providerConfigs.map(shallowCopy));\n        configs.sort((a, b) => (a.priority - b.priority));\n\n        const currentBlockNumber = this._highestBlockNumber;\n\n        let i = 0;\n        let first = true;\n        while (true) {\n            const t0 = now();\n\n            // Compute the inflight weight (exclude anything past)\n            let inflightWeight = configs.filter((c) => (c.runner && ((t0 - c.start) < c.stallTimeout)))\n                                        .reduce((accum, c) => (accum + c.weight), 0);\n\n            // Start running enough to meet quorum\n            while (inflightWeight < this.quorum && i < configs.length) {\n                const config = configs[i++];\n\n                const rid = nextRid++;\n\n                config.start = now();\n                config.staller = stall(config.stallTimeout);\n                config.staller.wait(() => { config.staller = null; });\n\n                config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {\n                    config.done = true;\n                    config.result = result;\n\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, now()),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                     }\n\n                }, (error) => {\n                    config.done = true;\n                    config.error = error;\n\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, now()),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                    }\n                });\n\n                if (this.listenerCount(\"debug\")) {\n                    this.emit(\"debug\", {\n                        action: \"request\",\n                        rid: rid,\n                        backend: exposeDebugConfig(config, null),\n                        request: { method: method, params: deepCopy(params) },\n                        provider: this\n                    });\n                }\n\n                inflightWeight += config.weight;\n            }\n\n            // Wait for anything meaningful to finish or stall out\n            const waiting: Array<Promise<any>> = [ ];\n            configs.forEach((c) => {\n                if (c.done || !c.runner) { return; }\n                waiting.push(c.runner);\n                if (c.staller) { waiting.push(c.staller.getPromise()); }\n            });\n\n            if (waiting.length) { await Promise.race(waiting); }\n\n            // Check the quorum and process the results; the process function\n            // may additionally decide the quorum is not met\n            const results = configs.filter((c) => (c.done && c.error == null));\n            if (results.length >= this.quorum) {\n                const result = processFunc(results);\n                if (result !== undefined) {\n                    // Shut down any stallers\n                    configs.forEach(c => {\n                        if (c.staller) { c.staller.cancel(); }\n                        c.cancelled = true;\n                    });\n                    return result;\n                }\n                if (!first) { await stall(100).getPromise(); }\n                first = false;\n            }\n\n            // No result, check for errors that should be forwarded\n            const errors = configs.reduce((accum, c) => {\n                if (!c.done || c.error == null) { return accum; }\n\n                const code = (<any>(c.error)).code;\n                if (ForwardErrors.indexOf(code) >= 0) {\n                    if (!accum[code]) { accum[code] = { error: c.error, weight: 0 }; }\n                    accum[code].weight += c.weight;\n                }\n\n                return accum;\n            }, <{ [ code: string ]: { error: Error, weight: number } }>({ }));\n\n            Object.keys(errors).forEach((errorCode: string) => {\n                const tally = errors[errorCode];\n                if (tally.weight < this.quorum) { return; }\n\n                // Shut down any stallers\n                configs.forEach(c => {\n                    if (c.staller) { c.staller.cancel(); }\n                    c.cancelled = true;\n                });\n\n                const e = <any>(tally.error);\n\n                const props: { [ name: string ]: any } = { };\n                ForwardProperties.forEach((name) => {\n                    if (e[name] == null) { return; }\n                    props[name] = e[name];\n                });\n\n                logger.throwError(e.reason || e.message, <any>errorCode, props);\n            });\n\n            // All configs have run to completion; we will never get more data\n            if (configs.filter((c) => !c.done).length === 0) { break; }\n        }\n\n        // Shut down any stallers; shouldn't be any\n        configs.forEach(c => {\n            if (c.staller) { c.staller.cancel(); }\n            c.cancelled = true;\n        });\n\n        return logger.throwError(\"failed to meet quorum\", Logger.errors.SERVER_ERROR, {\n            method: method,\n            params: params,\n            //results: configs.map((c) => c.result),\n            //errors: configs.map((c) => c.error),\n            results: configs.map((c) => exposeDebugConfig(c)),\n            provider: this\n        });\n    }\n}\n","\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { CommunityResourcable, showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\n\nconst defaultProjectId = \"84842078b09946638c03157f83405213\"\n\nexport class InfuraWebSocketProvider extends WebSocketProvider implements CommunityResourcable {\n    readonly apiKey: string;\n    readonly projectId: string;\n    readonly projectSecret: string;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        const provider = new InfuraProvider(network, apiKey);\n        const connection = provider.connection;\n        if (connection.password) {\n            logger.throwError(\"INFURA WebSocket project secrets unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"InfuraProvider.getWebSocketProvider()\"\n            });\n        }\n\n        const url = connection.url.replace(/^http/i, \"ws\").replace(\"/v3/\", \"/ws/v3/\");\n        super(url, network);\n\n        defineReadOnly(this, \"apiKey\", provider.projectId);\n        defineReadOnly(this, \"projectId\", provider.projectId);\n        defineReadOnly(this, \"projectSecret\", provider.projectSecret);\n    }\n\n    isCommunityResource(): boolean {\n        return (this.projectId === defaultProjectId);\n    }\n}\n\nexport class InfuraProvider extends UrlJsonRpcProvider {\n    readonly projectId: string;\n    readonly projectSecret: string;\n\n    static getWebSocketProvider(network?: Networkish, apiKey?: any): InfuraWebSocketProvider {\n        return new InfuraWebSocketProvider(network, apiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        const apiKeyObj: { apiKey: string, projectId: string, projectSecret: string } = {\n            apiKey: defaultProjectId,\n            projectId: defaultProjectId,\n            projectSecret: null\n        };\n\n        if (apiKey == null) { return apiKeyObj; }\n\n        if (typeof(apiKey) === \"string\") {\n            apiKeyObj.projectId = apiKey;\n\n        } else if (apiKey.projectSecret != null) {\n            logger.assertArgument((typeof(apiKey.projectId) === \"string\"),\n                \"projectSecret requires a projectId\", \"projectId\", apiKey.projectId);\n            logger.assertArgument((typeof(apiKey.projectSecret) === \"string\"),\n                \"invalid projectSecret\", \"projectSecret\", \"[REDACTED]\");\n\n            apiKeyObj.projectId = apiKey.projectId;\n            apiKeyObj.projectSecret = apiKey.projectSecret;\n\n        } else if (apiKey.projectId) {\n            apiKeyObj.projectId = apiKey.projectId;\n        }\n\n        apiKeyObj.apiKey = apiKeyObj.projectId;\n\n        return apiKeyObj;\n    }\n\n    static getUrl(network: Network, apiKey: any): ConnectionInfo {\n        let host: string = null;\n        switch(network ? network.name: \"unknown\") {\n            case \"homestead\":\n                host = \"mainnet.infura.io\";\n                break;\n            case \"ropsten\":\n                host = \"ropsten.infura.io\";\n                break;\n            case \"rinkeby\":\n                host = \"rinkeby.infura.io\";\n                break;\n            case \"kovan\":\n                host = \"kovan.infura.io\";\n                break;\n            case \"goerli\":\n                host = \"goerli.infura.io\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.infura.io\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.infura.io\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n\n        const connection: ConnectionInfo = {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + \"/v3/\" + apiKey.projectId),\n            throttleCallback: (attempt: number, url: string) => {\n                if (apiKey.projectId === defaultProjectId) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret\n        }\n\n        return connection;\n    }\n\n    isCommunityResource(): boolean {\n        return (this.projectId === defaultProjectId);\n    }\n}\n","/* istanbul ignore file */\n\n\"use strict\";\n\nimport { Network } from \"@ethersproject/networks\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n// Special API key provided by Nodesmith for ethers.js\nconst defaultApiKey = \"ETHERS_JS_SHARED\";\n\nexport class NodesmithProvider extends UrlJsonRpcProvider {\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey && typeof(apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey || defaultApiKey;\n    }\n\n    static getUrl(network: Network, apiKey?: any): string {\n        logger.warn(\"NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.\");\n\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc\";\n                break;\n            case \"ropsten\":\n                host = \"https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc\";\n                break;\n            case \"rinkeby\":\n                host = \"https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc\";\n                break;\n            case \"goerli\":\n                host = \"https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc\";\n                break;\n            case \"kovan\":\n                host = \"https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc\";\n                break;\n            default:\n               logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n\n        return (host + \"?apiKey=\" + apiKey);\n    }\n}\n","\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { getStatic } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\n// These are load-balancer-based application IDs\nconst defaultApplicationIds: Record<string, string> = {\n    homestead: \"6004bcd10040261633ade990\",\n    ropsten: \"6004bd4d0040261633ade991\",\n    rinkeby: \"6004bda20040261633ade994\",\n    goerli: \"6004bd860040261633ade992\",\n};\n\nexport class PocketProvider extends UrlJsonRpcProvider {\n    readonly applicationId: string;\n    readonly applicationSecretKey: string;\n    readonly loadBalancer: boolean;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        // We need a bit of creativity in the constructor because\n        // Pocket uses different default API keys based on the network\n\n        if (apiKey == null) {\n            const n = getStatic<(network: Networkish) => Network>(new.target, \"getNetwork\")(network);\n            if (n) {\n                const applicationId = defaultApplicationIds[n.name];\n                if (applicationId) {\n                    apiKey = {\n                        applicationId: applicationId,\n                        loadBalancer: true\n                    };\n                }\n            }\n\n            // If there was any issue above, we don't know this network\n            if (apiKey == null) {\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n            }\n\n        }\n\n        super(network, apiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        // Most API Providers allow null to get the default configuration, but\n        // Pocket requires the network to decide the default provider, so we\n        // rely on hijacking the constructor to add a sensible default for us\n\n        if (apiKey == null) {\n            logger.throwArgumentError(\"PocketProvider.getApiKey does not support null apiKey\", \"apiKey\", apiKey);\n        }\n\n        const apiKeyObj: { applicationId: string, applicationSecretKey: string, loadBalancer: boolean } = {\n            applicationId: null,\n            loadBalancer: false,\n            applicationSecretKey: null\n        };\n\n        // Parse applicationId and applicationSecretKey\n        if (typeof (apiKey) === \"string\") {\n            apiKeyObj.applicationId = apiKey;\n\n        } else if (apiKey.applicationSecretKey != null) {\n            logger.assertArgument((typeof (apiKey.applicationId) === \"string\"),\n                \"applicationSecretKey requires an applicationId\", \"applicationId\", apiKey.applicationId);\n            logger.assertArgument((typeof (apiKey.applicationSecretKey) === \"string\"),\n                \"invalid applicationSecretKey\", \"applicationSecretKey\", \"[REDACTED]\");\n\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;\n            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;\n\n        } else if (apiKey.applicationId) {\n            logger.assertArgument((typeof (apiKey.applicationId) === \"string\"),\n                \"apiKey.applicationId must be a string\", \"apiKey.applicationId\", apiKey.applicationId);\n\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;\n\n        } else {\n            logger.throwArgumentError(\"unsupported PocketProvider apiKey\", \"apiKey\", apiKey);\n        }\n\n        return apiKeyObj;\n    }\n\n    static getUrl(network: Network, apiKey: any): ConnectionInfo {\n        let host: string = null;\n        switch (network ? network.name : \"unknown\") {\n            case \"homestead\":\n                host = \"eth-mainnet.gateway.pokt.network\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.gateway.pokt.network\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.gateway.pokt.network\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.gateway.pokt.network\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n\n        let url = null;\n        if (apiKey.loadBalancer) {\n            url = `https:/\\/${ host }/v1/lb/${ apiKey.applicationId }`\n        } else {\n            url = `https:/\\/${ host }/v1/${ apiKey.applicationId }`\n        }\n\n        const connection: ConnectionInfo = { url };\n\n        // Initialize empty headers\n        connection.headers = {}\n\n        // Apply application secret key\n        if (apiKey.applicationSecretKey != null) {\n            connection.user = \"\";\n            connection.password = apiKey.applicationSecretKey\n        }\n\n        return connection;\n    }\n\n    isCommunityResource(): boolean {\n        return (this.applicationId === defaultApplicationIds[this.network.name]);\n    }\n}\n","\"use strict\";\n\nimport { Networkish } from \"@ethersproject/networks\";\nimport { deepCopy, defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n\n// Exported Types\nexport type ExternalProvider = {\n    isMetaMask?: boolean;\n    isStatus?: boolean;\n    host?: string;\n    path?: string;\n    sendAsync?: (request: { method: string, params?: Array<any> }, callback: (error: any, response: any) => void) => void\n    send?: (request: { method: string, params?: Array<any> }, callback: (error: any, response: any) => void) => void\n    request?: (request: { method: string, params?: Array<any> }) => Promise<any>\n}\n\nlet _nextId = 1;\n\nexport type JsonRpcFetchFunc = (method: string, params?: Array<any>) => Promise<any>;\n\ntype Web3LegacySend = (request: any, callback: (error: Error, response: any) => void) => void;\n\nfunction buildWeb3LegacyFetcher(provider: ExternalProvider, sendFunc: Web3LegacySend) : JsonRpcFetchFunc {\n    const fetcher = \"Web3LegacyFetcher\";\n\n    return function(method: string, params: Array<any>): Promise<any> {\n        const request = {\n            method: method,\n            params: params,\n            id: (_nextId++),\n            jsonrpc: \"2.0\"\n        };\n\n        return new Promise((resolve, reject) => {\n            this.emit(\"debug\", {\n                action: \"request\",\n                fetcher,\n                request: deepCopy(request),\n                provider: this\n            });\n\n            sendFunc(request, (error, response) => {\n\n                if (error) {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        fetcher,\n                        error,\n                        request,\n                        provider: this\n                    });\n\n                    return reject(error);\n                }\n\n                this.emit(\"debug\", {\n                    action: \"response\",\n                    fetcher,\n                    request,\n                    response,\n                    provider: this\n                });\n\n                if (response.error) {\n                    const error = new Error(response.error.message);\n                    (<any>error).code = response.error.code;\n                    (<any>error).data = response.error.data;\n                    return reject(error);\n                }\n\n                resolve(response.result);\n            });\n        });\n    }\n}\n\nfunction buildEip1193Fetcher(provider: ExternalProvider): JsonRpcFetchFunc {\n    return function(method: string, params: Array<any>): Promise<any> {\n        if (params == null) { params = [ ]; }\n\n        const request = { method, params };\n\n        this.emit(\"debug\", {\n            action: \"request\",\n            fetcher: \"Eip1193Fetcher\",\n            request: deepCopy(request),\n            provider: this\n        });\n\n        return provider.request(request).then((response) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                response,\n                provider: this\n            });\n\n            return response;\n\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                error,\n                provider: this\n            });\n\n            throw error;\n        });\n    }\n}\n\nexport class Web3Provider extends JsonRpcProvider {\n    readonly provider: ExternalProvider;\n    readonly jsonRpcFetchFunc: JsonRpcFetchFunc;\n\n    constructor(provider: ExternalProvider | JsonRpcFetchFunc, network?: Networkish) {\n        logger.checkNew(new.target, Web3Provider);\n\n        if (provider == null) {\n            logger.throwArgumentError(\"missing provider\", \"provider\", provider);\n        }\n\n        let path: string = null;\n        let jsonRpcFetchFunc: JsonRpcFetchFunc = null;\n        let subprovider: ExternalProvider = null;\n\n        if (typeof(provider) === \"function\") {\n            path = \"unknown:\";\n            jsonRpcFetchFunc = provider;\n\n        } else {\n            path = provider.host || provider.path || \"\";\n            if (!path && provider.isMetaMask) {\n                path = \"metamask\";\n            }\n\n            subprovider = provider;\n\n            if (provider.request) {\n                if (path === \"\") { path = \"eip-1193:\"; }\n                jsonRpcFetchFunc = buildEip1193Fetcher(provider);\n            } else if (provider.sendAsync) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));\n            } else if (provider.send) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));\n            } else {\n                logger.throwArgumentError(\"unsupported provider\", \"provider\", provider);\n            }\n\n            if (!path) { path = \"unknown:\"; }\n        }\n\n        super(path, network);\n\n        defineReadOnly(this, \"jsonRpcFetchFunc\", jsonRpcFetchFunc);\n        defineReadOnly(this, \"provider\", subprovider);\n    }\n\n    send(method: string, params: Array<any>): Promise<any> {\n        return this.jsonRpcFetchFunc(method, params);\n    }\n}\n","\"use strict\";\n\nimport {\n    Block,\n    BlockTag,\n    EventType,\n    FeeData,\n    Filter,\n    Log,\n    Listener,\n    Provider,\n    TransactionReceipt,\n    TransactionRequest,\n    TransactionResponse\n} from \"@ethersproject/abstract-provider\";\n\nimport { getNetwork } from \"@ethersproject/networks\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\n\nimport { BaseProvider, EnsProvider, EnsResolver, Resolver } from \"./base-provider\";\n\nimport { AlchemyProvider, AlchemyWebSocketProvider } from \"./alchemy-provider\";\nimport { CloudflareProvider } from \"./cloudflare-provider\";\nimport { EtherscanProvider } from \"./etherscan-provider\";\nimport { FallbackProvider, FallbackProviderConfig } from \"./fallback-provider\";\nimport { IpcProvider } from \"./ipc-provider\";\nimport { InfuraProvider, InfuraWebSocketProvider } from \"./infura-provider\";\nimport { JsonRpcProvider, JsonRpcSigner } from \"./json-rpc-provider\";\nimport { JsonRpcBatchProvider } from \"./json-rpc-batch-provider\";\nimport { NodesmithProvider } from \"./nodesmith-provider\";\nimport { PocketProvider } from \"./pocket-provider\";\nimport { StaticJsonRpcProvider, UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Web3Provider } from \"./web3-provider\";\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { ExternalProvider, JsonRpcFetchFunc } from \"./web3-provider\";\n\nimport { CommunityResourcable, Formatter, isCommunityResourcable, isCommunityResource, showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n////////////////////////\n// Helper Functions\n\nfunction getDefaultProvider(network?: Networkish, options?: any): BaseProvider {\n    if (network == null) { network = \"homestead\"; }\n\n    // If passed a URL, figure out the right type of provider based on the scheme\n    if (typeof(network) === \"string\") {\n        // @TODO: Add support for IpcProvider; maybe if it ends in \".ipc\"?\n\n        // Handle http and ws (and their secure variants)\n        const match = network.match(/^(ws|http)s?:/i);\n        if (match) {\n            switch (match[1]) {\n                case \"http\":\n                    return new JsonRpcProvider(network);\n                case \"ws\":\n                    return new WebSocketProvider(network);\n                default:\n                    logger.throwArgumentError(\"unsupported URL scheme\", \"network\", network);\n            }\n        }\n    }\n\n    const n = getNetwork(network);\n    if (!n || !n._defaultProvider) {\n        logger.throwError(\"unsupported getDefaultProvider network\", Logger.errors.NETWORK_ERROR, {\n            operation: \"getDefaultProvider\",\n            network: network\n        });\n    }\n\n    return n._defaultProvider({\n        FallbackProvider,\n\n        AlchemyProvider,\n        CloudflareProvider,\n        EtherscanProvider,\n        InfuraProvider,\n        JsonRpcProvider,\n        NodesmithProvider,\n        PocketProvider,\n        Web3Provider,\n\n        IpcProvider,\n    }, options);\n}\n\n////////////////////////\n// Exports\n\nexport {\n\n    // Abstract Providers (or Abstract-ish)\n    Provider,\n    BaseProvider,\n\n    Resolver,\n\n    UrlJsonRpcProvider,\n\n    ///////////////////////\n    // Concrete Providers\n\n    FallbackProvider,\n\n    AlchemyProvider,\n    AlchemyWebSocketProvider,\n    CloudflareProvider,\n    EtherscanProvider,\n    InfuraProvider,\n    InfuraWebSocketProvider,\n    JsonRpcProvider,\n    JsonRpcBatchProvider,\n    NodesmithProvider,\n    PocketProvider,\n    StaticJsonRpcProvider,\n    Web3Provider,\n    WebSocketProvider,\n\n    IpcProvider,\n\n\n    ///////////////////////\n    // Signer\n\n    JsonRpcSigner,\n\n\n    ///////////////////////\n    // Functions\n\n    getDefaultProvider,\n    getNetwork,\n    isCommunityResource,\n    isCommunityResourcable,\n    showThrottleMessage,\n\n\n    ///////////////////////\n    // Objects\n\n    Formatter,\n\n\n    ///////////////////////\n    // Types\n\n    Block,\n    BlockTag,\n    EventType,\n    FeeData,\n    Filter,\n    Log,\n    Listener,\n    TransactionReceipt,\n    TransactionRequest,\n    TransactionResponse,\n\n    ExternalProvider,\n    JsonRpcFetchFunc,\n\n    FallbackProviderConfig,\n\n    Network,\n    Networkish,\n\n    EnsProvider,\n    EnsResolver,\n\n    CommunityResourcable\n};\n\n","\"use strict\";\n\nconst IpcProvider: any = null;\n\nexport {\n    IpcProvider\n};\n"],"names":["useRawCalls","calls","useChainState","dispatchCalls","value","useEffect","filteredCalls","filter","Boolean","type","JSON","stringify","useMemo","map","call","state","_a","address","_b","data","useChainCalls","result","warnOnInvalidContractCall","console","warn","method","args","encodeCallData","abi","encodeFunctionData","useContractCall","results","idx","decodeFunctionResult","undefined","_permanentCensorErrors","_censorErrors","LogLevels","debug","info","warning","error","off","_logLevel","_globalLogger","LogLevel","ErrorCode","_normalizeError","missing","forEach","form","normalize","Error","push","length","join","String","fromCharCode","message","_checkNormalize","HEX","Logger","version","Object","defineProperty","this","enumerable","writable","logLevel","level","toLowerCase","throwArgumentError","log","apply","_log","levels","DEBUG","INFO","WARNING","code","params","makeError","errors","UNKNOWN_ERROR","messageDetails","keys","key","Uint8Array","hex","i","toString","reason","name","throwError","INVALID_ARGUMENT","argument","condition","UNSUPPORTED_OPERATION","operation","NUMERIC_FAULT","fault","count","expectedCount","MISSING_ARGUMENT","UNEXPECTED_ARGUMENT","target","kind","MISSING_NEW","censorship","permanent","globalLogger","connectContractToSigner","contract","options","library","signer","connect","getSigner","TypeError","useContractFunction","functionName","useEthers","chainId","useState","status","setState","addTransaction","useTransactionsContext","addNotification","useNotificationsContext","resetState","useCallback","promiseTransaction","transactionPromise","transaction","submittedAt","Date","now","transactionName","wait","receipt","errorMessage","_c","_d","_e","e","replacement","cancelled","notification","_f","originalTransaction","usePromiseTransaction","events","setEvents","send","contractWithSigner","logs","reduce","accumulatedLogs","addressEqual","interface","parseLog","_err","MultiCallABI","Interface","MultiCall","MultiCall2","ERC20","ERC20Mock","useEtherBalance","multicallAddress","useTransactions","account","transactions","x","from","promiseArg","resolve","reject","wrappedPromise","Promise","_resolve","_reject","then","val","promise","cancel","__assign","assign","t","s","n","arguments","p","prototype","hasOwnProperty","DefaultOptions","_args","onlyResolvesLast","config","debounceSingleton","debounceCache","DebounceCache","asyncFunction","cancelPrevious","debouncedFunc","DebouncePromise","func","_createDebouncedFunction","finalOptions","debouncedFn","getDebouncedFunction","getWait","defer","deferred","module","exports","fn","lastCallAt","timer","pendingArgs","currentWait","currentTime","getTime","isCold","leading","accumulate","clearTimeout","setTimeout","flush","bind","argsIndex","thisDeferred","url","CALL_EXCEPTION","INSUFFICIENT_FUNDS","NONCE_EXPIRED","REPLACEMENT_UNDERPRICED","TRANSACTION_REPLACED","UNPREDICTABLE_GAS_LIMIT","logger","isHexable","toHexString","addSlice","array","slice","Array","isInteger","isBytes","constructor","v","arrayify","checkSafeUint53","unshift","parseInt","allowMissingPrefix","substring","isHexString","hexPad","concat","items","objects","item","accum","offset","object","set","match","HexCharacters","hexlify","Math","floor","hexZeroPad","BN","_BN","_constructorGuard","MAX_SAFE","_warnedToStringRadix","BigNumber","constructorGuard","checkNew","_hex","_isBigNumber","freeze","toBigNumber","toBN","fromTwos","toTwos","other","add","sub","isZero","throwFault","div","mul","isNeg","umod","pow","isNegative","and","or","xor","maskn","shln","shrn","eq","lt","lte","gt","gte","toNumber","BigInt","toHex","anyValue","keccak256","sha3","getChecksumAddress","chars","split","expanded","charCodeAt","hashed","toUpperCase","ibanLookup","safeDigits","log10","LN10","ibanChecksum","c","block","checksum","getAddress","UnicodeNormalizationForm","Utf8ErrorReason","ignoreFunc","bytes","output","badCodepoint","BAD_PREFIX","UNEXPECTED_CONTINUE","o","OVERRUN","Utf8ErrorFuncs","ignore","replace","OVERLONG","getUtf8CodePoints","onError","extraLength","overlongMask","res","j","nextChar","MISSING_CONTINUE","OUT_OF_RANGE","UTF16_SURROGATE","toUtf8Bytes","str","current","checkNormalize","c2","pair","toUtf8String","codePoint","id","text","defineReadOnly","getStatic","ctor","getPrototypeOf","opaque","bigint","boolean","number","string","_isFrozen","isArray","isFrozen","_deepCopy","deepCopy","Description","Coder","localName","dynamic","Writer","wordSize","_data","_dataLength","_padding","writer","_writeData","paddingOffset","BUFFER_OVERRUN","_getValue","Reader","coerceFunc","allowLoose","_offset","_coerceFunc","coerce","loose","alignedLength","ceil","_peekBytes","readBytes","AddressCoder","_throwError","writeValue","reader","readValue","AnonymousCoder","coder","defaultValue","encode","decode","pack","coders","values","arrayValues","unique","staticWriter","dynamicWriter","updateFuncs","index","dynamicOffset","updateFunc","writeUpdatableValue","baseOffset","appendWriter","unpack","baseReader","subReader","offsetReader","baseType","uniqueNames","get","ArrayCoder","defaultChild","checkArgumentCount","BooleanCoder","DynamicBytesCoder","writeBytes","BytesCoder","FixedBytesCoder","size","NullCoder","NegativeOne","Zero","One","MaxUint256","NumberCoder","signed","maxUintValue","mask","bounds","StringCoder","TupleCoder","types","ModifiersBytes","calldata","memory","storage","ModifiersNest","checkModifier","indexOf","populate","FormatTypes","sighash","minimal","full","json","paramTypeArray","RegExp","ParamType","arrayLength","arrayChildren","fromObject","components","_isParamType","format","indexed","comp","parse","allowIndexed","fromString","isParamType","verifyType","node","param","originalParam","newNode","parent","allowType","allowParams","child","allowName","allowArray","sibling","readArray","parseParamType","parseParams","allowIndex","trim","depth","splitNesting","Fragment","_isFragment","isFragment","FunctionFragment","EventFragment","ConstructorFragment","ErrorFragment","anonymous","inputs","input","isEventFragment","verifyIdentifier","regexParen","modifier","parseGas","gas","comps","parseModifiers","constant","payable","stateMutability","verifyState","isConstructorFragment","parens","outputs","isFunctionFragment","returns","checkForbidden","fragment","sig","isErrorFragment","regexIdentifier","paramTypeBytes","paramTypeNumber","defaultAbiCoder","AbiCoder","_getCoder","component","_getWordSize","_getWriter","_getReader","LogDescription","TransactionDescription","ErrorDescription","Indexed","_isIndexed","BuiltinErrors","signature","wrapAccessError","property","wrap","fragments","bucket","deploy","functions","nameOrSignatureOrSighash","getSighash","matching","f","nameOrSignatureOrTopic","topichash","getEventTopic","getFunction","getError","_","eventFragment","getEvent","_abiCoder","_encodeParams","_decodeParams","functionFragment","errorArgs","errorName","errorSignature","selector","builtin","topics","encodeTopic","pop","dataTypes","dataValues","topicHash","expected","nonIndexed","resultIndexed","resultNonIndexed","nonIndexedIndex","indexedIndex","hash","tx","topic","decodeEventLog","hexData","errorFragment","endOffset","_isInterface","ethDefaultProvider","network","providers","providerList","InfuraProvider","infura","EtherscanProvider","etherscan","AlchemyProvider","alchemy","PocketProvider","pocket","provider","CloudflareProvider","cloudflare","FallbackProvider","quorum","renetwork","etcDefaultProvider","JsonRpcProvider","homestead","ensAddress","_defaultProvider","ropsten","classicMordor","networks","unspecified","mainnet","morden","testnet","rinkeby","kovan","goerli","kintsugi","classic","classicMorden","classicTestnet","classicKotti","xdai","matic","maticmum","optimism","arbitrum","bnb","bnbt","getNetwork","standard","defaultProvider","resolveProperties","promises","all","shallowCopy","isBytesLike","stripZeros","start","hexDataLength","hexDataSlice","hexConcat","hexValue","trimmed","hexStripZeros","splitSignature","r","_vs","recoveryParam","yParityAndS","compact","vs","zeroPad","recId","arrayifyInteger","unarrayifyInteger","_encode","payload","_decodeChildren","childOffset","decoded","_decode","consumed","lengthLength","assert","msg","equal","l","utils","zero2","word","toArray","enc","hi","lo","arr","minAssert","minUtils","getNAF","num","w","bits","naf","max","bitLength","fill","ws","k","clone","z","mod","andln","isOdd","isubn","iushrn","getJSF","k1","k2","jsf","m8","d1","d2","cmpn","u1","u2","m14","m24","cachedProperty","obj","computer","parseBytes","intFromLE","BaseCurve","conf","red","prime","zero","toRed","one","two","g","pointFromJSON","gRed","_wnafT1","_wnafT2","_wnafT3","_wnafT4","_bitLength","adjustCount","redN","_maxwellTrick","BasePoint","curve","precomputed","point","validate","_fixedNafMul","doubles","_getDoubles","I","step","nafW","repr","a","jpoint","b","mixedAdd","points","neg","toP","_wnafMul","nafPoints","_getNAFPoints","wnd","acc","dblp","_wnafMulAdd","defW","coeffs","len","jacobianResult","wndWidth","comb","y","cmp","toJ","redNeg","ja","jb","tmp","decodePoint","byteLength","pointFromX","encodeCompressed","getX","getY","isEven","precompute","power","beta","_getBeta","_hasDoubles","dbl","create","superCtor","super_","configurable","TempCtor","ShortCurve","Base","tinv","redInvm","zeroA","fromRed","threeA","endo","_getEndomorphism","_endoWnafT1","_endoWnafT2","inherits","Point","isRed","inf","forceRed","JPoint","zOne","modn","lambda","betas","_getEndoRoots","lambdas","redMul","basis","vec","_getEndoBasis","ntinv","redSqrt","redAdd","redSub","a0","b0","a1","b1","a2","b2","prevR","aprxSqrt","ushrn","u","x1","y1","x2","y2","q","len1","sqr","negative","_endoSplit","v1","v2","c1","divRound","p1","p2","q1","q2","odd","redSqr","redIAdd","ax","rhs","redISub","_endoWnafMulAdd","npoints","ncoeffs","ineg","fromJSON","pre","endoMul","toJSON","obj2point","inspect","isInfinity","nx","ny","ys1","dyinv","mulAdd","jmulAdd","_precompute","negate","zinv","zinv2","ay","pz2","z2","s1","s2","h","h2","h3","nz","jx","jy","jz","jz4","jyd","jx2","jyd2","jyd4","t1","t2","dny","_zeroDbl","_threeDbl","_dbl","xx","yy","yyyy","m","yyyy8","d","c8","delta","gamma","alpha","beta4","beta8","ggamma8","jy2","jxd4","jyd8","trpl","zz","mm","ee","yyu4","kbase","z3","pz3","eqXToP","zs","rx","xc","iadd","base","require$$0","short","require$$1","mont","edwards","curves","PresetCurve","defineCurve","HmacDRBG","predResist","outLen","outSize","minEntropy","hmacStrength","_reseed","reseedInterval","K","V","entropy","entropyEnc","nonce","nonceEnc","pers","persEnc","_init","seed","_update","_hmac","kmac","update","digest","reseed","addEnc","generate","temp","KeyPair","ec","priv","pub","_importPrivate","privEnc","_importPublic","pubEnc","fromPublic","fromPrivate","getPublic","getPrivate","derive","sign","verify","Signature","_importDER","Position","place","getLength","buf","initial","octetLen","rmPadding","constructLength","octets","LN2","rlen","slen","toDER","backHalf","rand","EC","nh","keyPair","keyFromPrivate","keyFromPublic","genKeyPair","drbg","ns2","iaddn","_truncateToN","truncOnly","bkey","ns1","iter","kp","kpX","invm","canonical","sinv","recoverPubKey","isYOdd","isSecondKey","rInv","getKeyRecoveryParam","Q","Qprime","elliptic","require$$2","require$$3","eddsa","_curve","getCurve","SigningKey","privateKey","p0","publicKey","digestBytes","otherKey","otherKeyPair","computePublicKey","_isSigningKey","compressed","signingKey","TransactionTypes","handleAddress","handleNumber","recoverAddress","computeAddress","rs","recoverPublicKey","formatNumber","accessSetify","addr","storageKeys","storageKey","accessListify","sort","localeCompare","formatAccessList","_serializeEip1559","gasPrice","maxFeePerGas","fields","maxPriorityFeePerGas","gasLimit","to","accessList","RLP","_serializeEip2930","_parseEipSignature","serialize","recid","rawTransaction","raw","_parse","_parseEip2930","_parseEip1559","transactionType","Formatter","formats","getDefaultFormats","bigNumber","blockTag","allowNull","blockHash","blockNumber","transactionIndex","confirmations","uint256","creates","transactionRequest","receiptLog","transactionHash","arrayOf","logIndex","contractAddress","root","gasUsed","logsBloom","cumulativeGasUsed","effectiveGasPrice","parentHash","timestamp","difficulty","miner","extraData","baseFeePerGas","blockWithTransactions","transactionResponse","fromBlock","toBlock","filterLog","removed","allowFalsish","strict","getContractAddress","author","_difficulty","check","_block","networkId","parseTransaction","byzantium","checkKey","checkValue","nullValue","replaceValue","isCommunityResource","isCommunityResourcable","throttleMessage","showThrottleMessage","allowedTransactionKeys","forwardErrors","Signer","checkAbstract","_checkProvider","getBalance","getTransactionCount","checkTransaction","estimateGas","populateTransaction","signTransaction","signedTx","sendTransaction","getGasPrice","getFeeData","resolveName","__awaiter","catch","hasEip1559","feeData","getChainId","_isSigner","_toUtf8String","codePoints","toUtf8CodePoints","padding","hexTrue","hexFalse","domainFieldTypes","verifyingContract","salt","domainFieldNames","checkString","domainChecks","getBaseEncoder","width","boundsUpper","boundsLower","padOffset","hexPadRight","encodeType","TypedDataEncoder","links","parents","subtypes","field","primaryTypes","checkCircular","found","subtype","primaryType","st","_types","encoder","_encoderCache","_getEncoder","subEncoder","getEncoder","encodedType","encodeData","hashStruct","callback","_visit","domain","domainFields","EIP712Domain","hashDomain","ensCache","visit","domainValues","domainTypes","typesWithDomain","textData","atob","btoa","getUrl","href","request","headers","body","skipFetchSetup","mode","cache","credentials","redirect","referrer","fetch","response","arrayBuffer","statusCode","statusMessage","statusText","staller","duration","bodyify","fetchJson","connection","processFunc","updated","attemptLimit","throttleLimit","assertArgument","throttleCallback","throttleSlotInterval","errorPassThrough","allow304","timeout","allowGzip","user","password","allowInsecureAuthentication","authorization","base64Encode","reData","dataMatch","base64Decode","requestBody","requestMethod","flatHeaders","header","runningTimeout","runningFetch","attempt","location","tryAgain","stall","retryAfter","random","serverError","throttleRetry","race","_fetchData","poll","ceiling","interval","done","retryLimit","oncePoll","once","onceBlock","ForkEvent","_isForkEvent","Provider","getBlock","eventName","listener","on","_isProvider","BaseX","alphabet","charAt","_alphabetMap","source","digits","carry","_leader","byte","reverse","Base58","createTable","createRangeTable","matchMap","ranges","range","Table_A_1_ranges","Table_B_1_flags","Table_B_2_ranges","Table_B_2_lut_abs","Table_B_2_lut_rel","Table_B_2_complex","Table_C_ranges","nameprep","codes","codesTableB2","codepoint","shift","_nameprepTableB2","NFKC","Zeros","Partition","namehash","partition","sha256","checkTopic","serializeTopics","sorted","getEventTag","isForkEvent","PollableEvents","Event","tag","coinInfos","symbol","p2pkh","p2sh","prefix","ilk","bytes32ify","base58Encode","matchers","_parseString","_parseBytes","Resolver","resolvedAddress","formatter","parameters","coinType","hexBytes","coinInfo","words","bech32","HashZero","callAddress","_fetchBytes","_getAddress","linkage","getText","avatar","content","_resolvedAddress","owner","tokenId","tokenOwner","balance","metadataUrl","metadata","image","ipfs","swarm","keyBytes","defaultFormatter","nextPollId","BaseProvider","_events","_emitted","getFormatter","anyNetwork","detectNetwork","_networkPromise","_ready","knownNetwork","emit","_maxInternalBlockNumber","_lastBlockNumber","_pollingInterval","_fastQueryDate","_network","event","maxAge","_internalBlockNumber","internalBlockNumber","respTime","reqTime","checkInternalBlockNumber","perform","networkError","_setFastBlockNumber","pollId","runners","_getInternalBlockNumber","pollingInterval","abs","previousBlockNumber","eventBlockNumber","runner","getTransactionReceipt","getLogs","polling","currentNetwork","_fastBlockNumber","_fastBlockNumberPromise","detectedNetwork","_poller","setInterval","_bootstrapPoll","clearInterval","getBlockNumber","_waitForTransaction","replaceable","cancelFuncs","alreadyDone","minedHandler","removeListener","lastBlockNumber","startBlock","scannedBlock","replaceHandler","getTransaction","mined","getBlockWithTransactions","ti","waitForTransaction","_wrapTransaction","unref","addressOrName","_getBlockTag","position","expectedHash","returnedHash","confirms","signedTransaction","hexTx","_getTransactionRequest","blockHashOrBlockTag","includeTransactions","blockWithTxs","_getBlock","_getFilter","_getResolver","getResolver","resolver","reverseName","resolverAddress","nameOrAddress","getAvatar","pollable","_startEvent","_addEventListener","stopped","eventTag","_stopEvent","removeAllListeners","errorGas","checkError","responseText","getResult","getLowerCase","JsonRpcSigner","addressOrIndex","UncheckedJsonRpcSigner","_address","_index","accounts","fromAddress","estimate","sender","hexlifyTransaction","sendUncheckedTransaction","_TypedDataEncoder","populated","networkOrReady","_nextId","_eventLoopCache","_cache","_uncachedDetectNetwork","connectUnchecked","jsonrpc","action","prepareRequest","_startPending","_pendingFilter","self","pendingFilter","filterId","hashes","seq","listenerCount","allowExtra","properties","allowed","WS","WebSocket","NextId","WebSocketProvider","_wsReady","_websocket","onopen","_requests","onmessage","messageEvent","_subs","subscription","fauxPoll","_detectNetwork","rid","subIdPromise","_subIds","subId","_subscribe","emitReceipt","readyState","CONNECTING","onerror","close","StaticJsonRpcProvider","_super","UrlJsonRpcProvider","apiKey","defaultApiKey","AlchemyWebSocketProvider","host","getTransactionPostData","maxFeePerGs","getJsonResult","checkLogTag","getBaseUrl","query","baseUrl","apikey","post","getPostUrl","getPostData","procFunc","payloadStr","txhash","postData","topic0","blocks","parseFloat","ethusd","endBlock","startblock","endblock","timeStamp","shuffled","checkNetworks","median","maxDelta","middle","nextRid","getPromise","ForwardErrors","ForwardProperties","exposeDebugConfig","weight","getProcessFunc","configs","_highestBlockNumber","tally","normalizedTally","waitForSync","getRunner","currentBlockNumber","getEtherPrice","getStorageAt","providerConfigs","configOrProvider","isProvider","stallTimeout","priority","total","first","t0","inflightWeight","backend","waiting","errorCode","props","defaultProjectId","InfuraWebSocketProvider","projectId","projectSecret","apiKeyObj","NodesmithProvider","defaultApplicationIds","applicationId","loadBalancer","applicationSecretKey","buildWeb3LegacyFetcher","sendFunc","fetcher","Web3Provider","path","jsonRpcFetchFunc","subprovider","isMetaMask","buildEip1193Fetcher","sendAsync","getDefaultProvider","IpcProvider"],"sourceRoot":""}